[{"title":"I can't accept my mediocrity","date":"2019-10-28T05:34:19.000Z","path":"post/ffd08d43.html","text":"I ever had a big dream. When I participated in NOIP Junior, I dreamt to be selected as provincial team member and take part in NOI. But I failed in the baby step. I only scored 100 points in NOIP 2012 Junior with a total score of 400 points. I remember I was very frustrated on the day I was informed the result. When I entered high school, I found the Informatics teacher teaching so slowly that we were still learning loops in pascal before NOIP. Then I dropped out of OI. However, this decision is now proved to be the worst decision I have ever made. I really admire those guys who achieve excellent result in NOI. They are so cool. It’s the long-lasted effort and 1000+ difficult problems solved to enable them enter the stage. But I have never paid such an effort. I love math too. Taking part in CMO and even IMO is another big dream that I was looking forward to before I entered high school. I loved reading the book Mathematics Olympics Tutorials at that time. But I felt extremely difficult when I learned trigonometric functions in the book. It was so hard for me that I even couldn’t solve any problems in the attached practices. Later I dropout of mathematics contest too and start to live a common high school life. Even though I gave up contests, I should have worked hard in college entrance examination subjects. But regrettably, I didn’t do it. I struggled in depressed mood during 2nd year of high school. And my biggest drawback is procrastination. I couldn’t arrange my time properly. Hence, I wasted nearly the whole 2nd year. It’s so disappointing. I abandon my OI dream and also lost the chance to get into a better university. I also dreamt to get into Hongkong University. But looking back now, these are simply a dream. My actions can not be commensurate with the big dreams.","tags":[{"name":"reflection","slug":"reflection","permalink":"http://dafenghh.github.io/tags/reflection/"}]},{"title":"Practice Competitive Programming Record","date":"2019-10-28T03:54:36.000Z","path":"post/f615b6ab.html","text":"","tags":[]},{"title":"Must-know Words for IELTS: Listening","date":"2019-10-21T08:58:42.000Z","path":"post/9b6b2b03.html","text":"Refreshment","tags":[]},{"title":"Course Note: Wireless Communications","date":"2019-07-05T09:55:23.000Z","path":"post/3a162640.html","text":"绪论香农信道容量定理及其应用功率可以无限止地换取带宽、带宽不能无限止地换取功率。 香农信道容量定理 信道分类 多径扩散 相干带宽 多普勒扩散 相干时间 色散信道（信号带宽大于多径扩散） 非色散信道 变参信道(码元周期大于相干时间） 恒参信道 信道 21世纪通信的二大平台 光纤通信平台 无线通信平台 系统组成无线通信系统的组成 系统组成 基带、中频、射频、天线单元的组成 基带单元 中频单元 射频单元 天线单元 传输容量表示法、传输质量表示法传输容量指对用户有效的传输信息容量 传输容量表示法 传输质量表示法 误码门限和哪些因素有关？误码门限和噪声系数、绝对温度、信道速率、信噪比有关。 为达到一定误码率所需要的最小接收电平，称为该 系统的误码门限。 误码门限 双工方式、调制方式、解调方式、信道编码方式、信源编码方式举例 FDD和TDD 调制方式和解调方式 信道编码的目的： 消除由于信道不理想所带来的误码 在理想信道上取得一定的功率增益 考虑原则： 系统对信道编码的要求 系统能提供多少冗余度 常用信道编码： 分组码 卷积码 Turbo码 无线通信系统的有效性和可靠性如何提高。 有效性：在给定的频率、功率和空间条件下实现最大的传输容量。 提高有效性的技术： 信源编码技术： 采用有效的信源编码技术，在保证原始消息质量的条件下，尽可能压缩传输所需的比特率。 调制技术： 采用高效率的调制技术（包括频谱成形技术），尽可能压缩传输给定比特率所需的带宽。 蜂窝技术：控制发射机的功率，在通信区域内划分出许多蜂窝状小区， 从而提高无线频谱的利用率。 智能天线技术：利用天线的自动定向或扇区划分，在通信区域内形成许多定向的小区，从而提高无线频谱利用率。 可靠性：在给定的信道衰落和干扰条件下实现最好的业务质量。 提高可靠性的技术： 冗余度技术 抵消技术（均衡、分集） 信道无线传播信道的主要指标。 传播衰减 衰减的平均值 衰减的最大值 衰减的统计特性 传播延时 延时的平均值 延时的最大值 延时的统计特性 延时扩展 对信道色散效应的描述 多普勒扩展 对信道时变效应的描述 干扰 干扰的性质 干扰的强度 无线信道传输的模型 自由空间传播 自由空间传播含义。其损耗和距离、频率成什么关系。（注意：信道传输损耗，天线增益降低损耗） 自由空间是无任何衰减、无任何阻挡、无任何多径的传播空间。 无线电波在自由空间传播时， 其单位面积中的能量会因为扩散而减少。这种减少，称为自由空间的传播损耗。 自由空间传播 自由空间传播损耗 视距传播含义。视距传播除考虑自由空间传播外，还要考虑什么效应？ 地面微波通信属于视距传播。 视距传播的主要特点是收发天线都在视距范围内。 视距传播要考虑大气效应和地面效应。 地面视距传播的大气效应 吸收衰减 主要发生在高频段,水蒸汽的最大吸收峰 在23GHz(1.3cm)； 氧气的最大吸收峰在 60GHz(5mm)； 雨雾衰减 在10GHz以下频段，雨雾衰减并不严重，一般只有几dB。 在10GHz以上频段(厘米/毫米波)，雨雾衰减大大增加，达到几dB/km。 下雨衰减是限制高频段微波传播距离的主要因素。 大气折射 大气折射导致无线电波有效传输距离减小， 相当于地球有效半径减少 地面视距传播的地面效应 根据波动光学的惠更斯－费涅尔原理，遇到障碍物时将产生附加损耗。 地面反射：产生电平衰落的主要原因。 地面反射的影响 平衰落、频率选择性衰落 平衰落-非色散信道 接收点的场强为随机变量，当衰落较严重时，场强接近瑞利分布 频率选择性衰落 移动传播的特点移动无线传播面临的是随时变化的、复杂的环境。 首先，传播环境十分复杂，传播机理多种多样。 几乎包括了电波传播的所有过程，如：直射、 绕射、反射、散射。 其次，由于用户台的移动性，传播参数随时变化，引起接收场强的快速波动。 移动传播大尺度模型和小尺度模型的含义 大尺度路径损耗传播模型描述发射机和接收机之间长距离上平均场强的变化，用于预测平均场强并估计无线覆盖范围。 小尺度多径衰落传播模型描述移动台在极小范围内移动时，短距离或短时间上接收场强的快速变化(瞬时值)，用于确定移动通信系统应该采取的技术措施。 移动传播的对数路径衰减规律的含义, 路径衰减指数的含义根据理论和测试结果，无论室内还是室外信道，平均接收信号功率随距离的对数衰减（用于大尺度模型）. n*log(d) n为路径衰减指数。 蜂窝核心思想：频率复用 本章重点： 区群，区群大小，同频小区的确定，同频复用距离D。 切换，切换的策略，硬切换，软切换。 干扰的类型，同频干扰。 中继理论及其有关计算。 重要数量值对于AMPS系统，接收机可以允许的有用信号和同频干扰信号的功率比一般要大于18dB。即， 有用信号功率≥63＊同频干扰功率。 因此，这就为AMPS系统（FDMA的蜂窝系统）的设计做出了基本的限定。 区群区群（cluster，也译作簇） 对于蜂窝系统，系统所提供的全部频率资源将在若干个相互邻接的小区上予以分配，分配的基本原则是每个小区将获得彼此不同的一部分频率资源，一般可以考虑 平均分配。我们将上述这些相邻接的一组小区称作一个区群。换句话说，在一个区群内部是不进行频率复用的。 将蜂窝系统的组成由小区（系统的最小组成单位）放大到区群，即整个系统服务区域的覆盖也可以看作由一个个区群覆盖完成，在区群之间进行频率复用。 相邻连接 区群大小一个区群中包含的小区数称作区群大小。 要满足以下两个条件： 各个区群实现整个面状服务区域的无缝无重叠覆盖； 使用相同频率的小区之间的最小距离在整个系统范围内为常数。 区群大小不是可以取任意值的。而应当服从$N=i^2+ij+j^2$ 一般，系统可使用的全部频率资源在区群范围内进行平均分配。 同频小区 在蜂窝系统设计和规划时位于不同区群内，采用相同的频道组的小区称作同频小区。 要想对由于采用相同频率工作而引起的相互干扰进行有效的控制，同频小区的分布应当存在规律性。 具体地，就是要求在整个系统范围内，同频小区之间的最小距离为常数。这个最小距离，一般称之为同频复用距离，记作D。 同频小区的确定 沿某正六边形小区一条边的垂线方向行进i 个小区 逆时针旋转60°后再向前行进j个小区, 所到达的小区可以与原始小区使用相同的频道组。 (限定i≥j) 同频小区的分布 相邻小区的中心距$d=\\sqrt{3}R$ R为小区的半径 同频复用距离D的计算 信道分配信道分配指的是蜂窝系统如何将可用信道资源在区群范围内进行分配， 以减小干扰并保证足够的用户容量。 固定信道分配系统拥有的信道资源（如载频或频道） 采用某种方式进行划分以后，各信道组被固定地分配到区群内各个小区上去。 一旦分配完毕，一般情况下，各小区只固定使用分配到本小区的那组信道。若小区内暂时没有空闲信道，呼叫将被阻塞（到达用户的呼叫无法接通或用户发起的呼叫无法拨出）。 可能造成频率资源的浪费。 如何划分信道组？ 邻频干扰和远近效应 远近效应 邻道干扰产生的原因 已调信号带外衰减不够快——采用带宽效率更高的调制技术 接收滤波器不够理想——改进接收滤波器性能 无线移动通信对约束邻频干扰的要求 发射频谱的主瓣 应比旁瓣高60-70dB 动态信道分配信道不是固定地分配给每个小区，而是全部信道形成“信道池”，由MSC统一管理。 呼叫发生时由BS向MSC申请信道。注意：MSC既是交换中心，又负责信道管理，更重要的是它还进行移动性管理（如切换管理）。 动态信道分配考虑的因素 同频道复用距离 不会对本小区已经使用的其他频率产生明显干扰 以后呼叫阻塞的可能性，候选频道使用的频次 优点 频率利用率高，可适应业务分布的动态变化。 降低了呼叫阻塞的概率，增加了系统的用户容量 缺点 控制复杂，开销较大（要求MSC 增加存储量和运算量） 切换 过区切换 切换的依据 接收信号强度(RSS，Received Signal Strength) 信干比S/I或载干比C/I（C_Carrier) 传统的切换启动准则 相对信号强度准则 具有门限规定的相对信号强度准则 具有滞后余量的相对信号强度准则 具有滞后余量和门限规定的相对信号强度准则（GSM采用） 门限规定：设定接收信号强度门限，若当前小区的接收信号强度低于门限，并且移动台接收到了比当前小区信号更强的相邻小区信号则启动切换。滞后余量：相邻小区的平均接收信号强度大于当前小区的平均接收信号强度，并且超过的数值大于一个滞后余量时才启动切换。避免来回切换的“乒乓效应”。 硬切换和软切换硬切换和软切换类型的区分是基于具体实施切换时对新、旧链路的不同处理方式的。 硬切换采用“先断(旧), 后建(新)” 的方式。 1G的FDMA系统和2G的TDMA系统采用。 软切换采用“先建(新), 综合利用(新\\旧), 后断(旧)”的方式。 2G和3G的CDMA系统广泛采用。 之所以存在上述差别，是因为CDMA相邻基站可以采用相同载频，所以同时保持新旧链路是可以做到的。像FDMA这样的系统，相邻小区绝不能使用相同载频，而移动台一般不能够同时工作在两个不同载频上。 干扰和系统容量 干扰的类型 同频干扰 邻频干扰 互调干扰 其他的外界干扰和噪声 其中同频干扰，邻频干扰和互调干扰的影响最大，且无法根除 同频干扰 就蜂窝系统而言，最重要的干扰来自于系统本身，也就是同频干扰。同频干扰即由于频率的复用，系统中存在同频小区，它们相互之间存在着无法滤除的干扰。同频干扰是不能简单地通过增加发射功率来克服的！ 同频复用比例$Q=\\frac{D}{R}=\\sqrt{3N}$ 由对数距离路径损耗模型可知同频干扰随着同 频复用距离（或同频复用比例）的增大而减小， 反之亦然。 中继理论 话务量 服务等级GOS 服务等级用来表示在中继系统最忙的时间用户进入系统的能力。 在具有特定数量的可用信道的系统中，通过定义希望用户能够获得信道从而接入系统的概率，可以把服务等级作为某个中继无线系统的预定性能基准。 GOS通常定义为呼叫阻塞的概率，或是呼叫延迟大于某一特定排队时间的概率。 阻塞处理 清除 延时 呼损概率公式 中继效率$\\eta = \\frac{A(1-GOS))}{C} (Erlangs/ch)$ 大尺度路径损耗本章重点： 自由空间传播了解非视距传播的三种机制：反射、绕射和散射对数路径损耗模型和对数阴影模型 信号强度的度量 功率(dBm)=10lg(功率(mW)/1mW)电平(dBμV)=20lg(电平(μV)／1 μV) dB重要数值 3dB的概念 功率每增加一倍，其分贝值增大3dB 功率每减小一半，其分贝值减少3dB 1dB的概念 功率每增加25%，其分贝值增大约1dB 功率每减小20%, 其分贝值减少约1dB 天线概述 理想化各向同性天线(点源) 没有体积、不存在损耗的点源辐射器。方向图为球体，即在空间各个方向具有相同的辐射强度(无方向性) $S=\\frac{P}{4\\pi r^2}$ S是功率密度 方向性天线 波瓣图 天线的增益 工程应用上，常把$P_{t}G$称作等效各向同性辐射功率(Effective Isotropically Radiated Power), 简记作EIRP 此时, G(dB)=10lgG. 为明确起见，采用dBi标记这个分贝值。i：isotropical。 天线的有效面积 接收场强和功率与距离的关系 接收天线获得的功率 自由空间传播损耗可以认为$P_R=P_T/PL$PL(dB) = 32.44+20lg d(km)+20lg f(MHz) LOS极限距离$d=4.12(\\sqrt{h_t}+\\sqrt{h_r})$ 非视距传播的三种基本传播机制 反射 当电波所投射到的表面尺寸远大于电波波长，并且该表面比较光滑，将发生电波的反射。 绕射 当电波传播过程中遇到与电波波长具有可比性的阻挡物时，电波会绕过阻挡物而传播到它的背面去。 散射 当波穿行的介质中存在小于波长的物体并且单位体积内阻挡体的个数非常巨大，将发生散射。可以理解为“乱”反射。 反射 双线模型下：$P_r=P_t\\frac{G_tG_rh_t^2h_r^2}{d^4}$ 由于直射波场强和反射波场强的共同作用下，随着距离(d)的延伸，接收功率按距离的四次方衰减。 菲涅尔带域 求附加路径长度 求得$\\Delta=\\frac{h^2}{2}\\frac{d}{d_1d_2}$ 第n菲涅尔区的半径是 $r_n=h=\\sqrt{\\frac{n\\lambda d_1d_2}{d}}$ 第一菲涅尔带域：n＝1时对应的圆面称作第一菲涅尔带域.$r_1=\\sqrt{\\frac{\\lambda d_1d_2}{d}}$ 当d{1}=d{2}=\\frac{d}{2}$ 有 要在接收端Rx处达到自由空间的场强，不一定需要许多的菲涅尔区，也不一定需要全部的第一菲涅尔区，只要第一菲涅尔区截面积的1/3就可以获得自由空间场强。这样最小菲涅尔半径为$r_0=\\frac{1}{\\sqrt{3}}r_1=0.577r_1$ 要保证电波的有效传播（获得与自由空间相当的接收场强），在这个最小菲涅尔椭球的范围内应该不存在阻挡物， 否则将造成严重衰减。这个衰减就是由阻挡引起的绕射衰减. 计算绕射损耗不会……假装考试不考 路径损耗指数n 路径损耗指数 对数距离路径损耗模型 阴影衰落信号在无线信道传播过程中遇到的障碍物会使信号发生随机变化，从而造成给定距离处接收信号功率的随机变化，反射面和散射体的变化也会造成接收功率的随机变化。因此，需要建立一个模型来描述这些因素造成的信号随机衰减。我们将主要由障碍物的阻挡（如建筑物会形成电波传播的阴影）所造成的这种信号的随机变化称为阴影衰落(Shadowing)。 对数正态阴影模型 对数正态阴影模型公式 X是均值为0dB的正态随机变量。 平均接收功率 中断概率 小尺度路径损耗本章重点： 多径信道冲激响应模型 多径信道的参数及小尺度衰落的类型 基于多径时延的小尺度衰落的分类 基于多普勒扩展的小尺度衰落的分类 熟悉本章的习题 小尺度衰落效应在小尺度（几倍波长）上，移动无线信道主要对传播信号存在以下几种效应： 由多径传播造成的信号强度在短距离（短时间）上的急剧变化 -&gt; 接收信号幅度变化 多普勒频移 -&gt; 接收信号载频变化 多径时延引起信号的时间色散 -&gt; 基带解调信号波形失真 我们将这些效应统称为多径效应或小尺度衰落效应。 多径传播的每个多径波到达的接收机的路径不同，因此他们到达的时间也不同， 每个多径波在接收机处并不是完全对齐的，这样一个基带信号的符号所占用的 时间将会超过其本来符号周期。从而对其它的符号产生串扰，即码间串扰，这 样就会引起信号模糊。 多普勒频移匀速原理时的频移：$f_d=-\\frac{v}{\\lambda}$匀速靠近时的频移：$f_d=\\frac{v}{\\lambda}$ 影响小尺度衰落的因素 多径传播 移动台的运动速度 环境物体的运动速度 信号的传输带宽 信号传输带宽的影响 频率选择性衰落 基于多径时延扩展的小尺度衰落分类 基于多径时延扩展的小尺度衰落比较 信道的相干时间 基于多普勒扩展的小尺度衰落分类 基于多普勒扩展的小尺度衰落比较 信号的基本参数 码元周期/信号频率 信号的基本参数 延迟扩展 多普勒频移 分类 无线调制技术本章重点： 数字调制的概念。 带宽效率，功率效率。 基带信号的编码。 脉冲成形的概念。 数字调制：ASK，PSK，FSK，QPSK，MSK，根据数字信号绘制调制波形。 调制的定义将要传输的信号(一般为数字脉冲)变换为适合信道特性的形式(一般为波形信号)的过程。 要传输的信号——调制信号。 转换后的信号——已调信号。在接收端需将已调信号还原成要传输的原始信号，该过程称为解调。 两大类适用的数字调制技术 线性调制：特点是调制过程表现为对基带信号谱的简单搬移，因此具有较窄的主瓣，但不能保证已调信号的相位连续变化。 连续相位的频率调制：特点为已调信号相位连续变化, 已调信号包络恒定(恒包络调制). 但属于非线性调制, 即射频谱并不是基带谱的简单搬移, 因此往往具有较宽的主瓣. 功率效率和带宽效率 功率效率 带宽效率 恒包络调制：信息调制在频率和相位上。 线路码型可分为两大类，即归零(Return to Zero，RZ) 码和不归零(Non- Return to Zero，NRZ)码。RZ意味着每比特周期脉冲要回到零值，这会使频谱展宽，但便于同步定时。而NRZ码在每个比特 周期不回到零值，即信号在每个比特周期内保 持定值，NRZ码比RZ码频谱效率高，但是同步能力差。 就二进制基带数据而言，又分为单极性(Unipolar)和双极性(Bipolar)的。 脉冲成形 为什么要进行脉冲成形？ 前面介绍的线路码都采用矩形脉冲进行数据的脉冲成形，如双极性NRZ码中， 用正矩形脉冲代表二进制的“1”，用负的矩形脉冲代表二进制的“0”。直接将这种脉冲用于调制会使已调信号频谱具有较高的旁瓣，无法满足无线移动通信的要求。 对基带信号进行低通滤波（称作脉冲成形）可以降低射频旁瓣。 常用的滤波器有两种。一种是升余弦滤波器，一般用于线性调制；另一种是高斯滤波器，常用于恒包络调制 脉冲成形带来的影响 脉冲成形滤波器都是低通滤波器，因此这些滤波器的冲激响应不可能是时间有限的。 低通滤波器会造成信号在时域上的扩展，一个符号的脉冲将会延伸到相邻符号的之间间隔内，因此，进行脉冲成形就意味着“人为地”引入码间干扰。 所以，要么我们选择可以消除码间干扰影响的滤波器作为脉冲成形滤波器，要么就应该将人为引入的码间干扰控制在对系统性能影响较小的程度以内。升余弦滤波器属于前一种情形；高斯滤波器则属于后一种情形 数字调制的原理数字调制器的作用就是针对不同的输入比特（或以多个比特代表的输入符号）来选择不同的调制波形并加以输出。","tags":[{"name":"notes","slug":"notes","permalink":"http://dafenghh.github.io/tags/notes/"}]},{"title":"系统分析与设计 Homework 6","date":"2019-07-04T12:24:50.000Z","path":"post/78defc7e.html","text":"使用 UMLet 建模使用类图，分别对 Asg_RH 文档中 Make Reservation 用例以及 Payment 用例开展领域建模。然后，根据上述模型，给出建议的数据表以及主要字段，特别是主键和外键 注意事项：对象必须是名词、特别是技术名词、报表、描述类的处理；关联必须有多重性、部分有名称与导航方向属性要注意计算字段数据建模，为了简化描述仅需要给出表清单，例如：Hotel（ID/Key，Name，LoctionID/Fkey，Address…..） Make Reservation 1234567Hotel(hotelID/key, address)RoomCatalog(catalogID/key, hotelID/Fkey)RoomDescription(descriptionID/key, catalogID/Fkey, price, type, address)Room(roomID/key, date, descriptionID/Fkey, availability)ReservationLineItem(roomID/Fkey, reservationID/Fkey, adultCount, childCount)Reservation(revervationID/key, customerID/Fkey)Customer(name, customerID/key) Payment 1234Customer(name, customerID/key)Card(cardID/key, customerID/Fkey, bank, number)Payment(paymentID/key, customerID/Fkey, cardID/Fkey, totalCost)Item(itemID/key, paymentID/Fkey, details) 使用 UML State Model，对每个订单对象生命周期建模 建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。 State Model","tags":[{"name":"homework","slug":"homework","permalink":"http://dafenghh.github.io/tags/homework/"}]},{"title":"Course Note: Software System Analysis and Design","date":"2019-07-03T04:22:05.000Z","path":"post/956bf9e0.html","text":"intro软件工程的定义软件工程是：(1) 将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件；(2) 在(1)中所述方法的研究. Analysis Analysis emphasizes an investigation of the problem and requirements, rather than a solution. Design Design emphasizes a conceptual solution (in software and hardware) that fulfils the requirements, rather than its implementation. Object-oriented analysis Object-oriented analysis emphasizes on finding and describing the objects or concepts in the problem domain. Object-oriented design Object-oriented design emphasizes on defining software objects and how they collaborate to fulfill the requirements. Unified Modeling Language The UML is standard diagramming language to visualize the results of analysis and design. UML is not a process or methodology object-oriented analysis and design guidelines for design 过程模型瀑布模型 瀑布模型 统一过程 The Unified Process (UP) represents a mainstream approach for software development across the spectrum of project scales. The process is scalable: you need not use the entire framework of the process for every project, only those that are effective. The process is effective: it has been successfully employed on a large population of projects. Improves productivity through use of practical methods that you’ve probably used already (but didn’t know it). Iterative and incremental approach allows start of work with incomplete, imperfect knowledge. Unified Process Workflows Workflows define a set of activities that are performedWorkflows cut across the phases, but with different levels of emphasis in each phase The core workflows Business Modeling Requirements analysis Design Implementation Test and Integration Use Case Driven Use Case A prose representation of a sequence of actions Actions are performed by one or more actors (human or nonhuman) and the system itself These actions lead to valuable results for one or more of the actors, helping the actors to achieve their goals. Use cases are expressed from the perspective of the users, in natural language, and should be understandable by all stakeholders Use-case-driven means the development team employs the use cases from requirements gathering through code and test Architecture Centric Software architecture captures decisions about: The overall structure of the software system The structural elements of the system and their interfaces The collaborations among these structural elements and their expected behavior Architecture-centric: software architecture provides the central point around which all other development evolves provides a ‘big picture’ of the system provides an organizational framework for development Iterative and Evolutionary迭代和进化式开发 An iterative and evolutionary approach allows start of development with incomplete, imperfect knowledge Advantages: Logical progress toward a robust architecture（逐步趋向稳定） Effective management of changing requirements（有效管理需求变化） Continuous integration（持续集成） Early understanding of the system （尽早接触整个系统） Ongoing risk assessment（在线风险评估） UP Phases Inception 初始：大体上的构想、业务案例、范围和模糊评估 Elaboration 细化：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估 Construction 构造：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署。 Transition 移交：进行beta测试和部署。 RUP Process model InceptionEnvision the product scope, vision, and business case. 初始阶段更关注对基本范围的理解以及10%的需求。 Evolutionary Requirement进化式需求 在统一过程中，需求按照”FURPS+”模型进行分裂。 Functional: features, capability, security Usability: human factors, help, documentation Reliability: frequency of failure, recoverability, predictability Performance: response times, throughput, accuracy,availability, resource usage. Supportability: adaptability, maintainability, internationalization, configurability The ‘+’ in FURPS+ indicates sub-factors Implementation: resource limitation, languages and tools, hardware… Interface: constraint imposed by interfacing with external systems Operations: system management in its operational setting Packaging: a physical box Legal (授权): 许可证等 Use Case用例是文本形式的情节描述。 用例建模主要是编写文本的活动，而非制图。 Actors Primary actor has user goals fulfilled through using services. (e.g. the cashier) Supporting actor provides a service (e.g. the automated payment authorization service is an example) to clarify external interfaces and protocols 明确外部接口和协议 Offstage actor has an interest in the behavior of the use case, but is not primary or supporting (e.g. a government tax agency) 详述用例(fully dressed use case)是结构化的，展示了更多细节，并且更为深入。 用例模板 用例名称 范围 级别 主要参与者 涉众及其关注点 前置条件 主成功场景 扩展 特殊需求 技术和数据变元表 发生频率 Guideline to Write Use Case Write in an essential UI-free style Write terse use case Write black-box use case take an actor and actor-goal perspective How to find use case? Use cases are defined to satisfy the goals of the primary actors. The basic procedure is: Choose the system boundary. Is it just a software application, the hardware and application as a unit, that plus a person using it, or an entire organization? Identify the primary actors that have goals fulfilled through using services of the system. Identify the goals for each primary actor. Define use cases that satisfy user goals; name them according to their goal. Find Actors and Goals: Event Analysis Event Based to identify external events that a system must respond to. What are they, where from, and why? Often, a group of events belong to the same use case. Relate the events to actors and use cases. 识别用例准则 Boss Test EBP Test (Elementary Business Process) A task performed by one person in one place at one time, in response to a business event, which adds measurable business value and leaves the data in a consistent state. Size Test UML 活动图应用场合 描述某一用例中执行的步骤，使复杂的多场景用例以及与Include或extend用例的关系可视化。描述用户和系统之间的业务流程协作。描述软件中的方法、函数或操作。（描述算法） UML activicy Domain Model领域模型表示真实世界概念类。 Provides a conceptual perspective: domain objects or conceptual classes associations between conceptual classes attributes of conceptual classes Guideline: Find Conceptual Classes Identify noun phrases. Identify the nouns and noun phrases in textual descriptions of a domain, and consider them as candidate conceptual classes or attributes Some of these noun phrases may refer to conceptual classes that are ignored in this iteration (e.g., “Accounting” and “commissions”), and some may be simply attributes of conceptual classes. A weakness of this approach is the imprecision of natural language; different noun phrases may represent the same conceptual class or attribute, among other ambiguities. A Common Mistake with Attributes vs. Classes If we do not think of some conceptual class X as a number or text in the real world, X is probably a conceptual class, not an attribute. When to Model with ‘Description’ Classes何时需要描述类： 需要有关商品或服务的描述，独立于任何商品或服务的现有实例。 避免删除所有示例后，原有的商品描述信息丢失。 减少冗余或重复信息。 Association A is a part of B A contains B A descibes B A is logged/recorded/reported/captured in B A is a member of B A is a subunit of B A uses or manages or owns B Attribute导出属性在属性名称前加’/‘ 准则：任何属性都不表示外键领域模型中，不能将外键作为属性，应当使用关联。 准则：对数量和单位建模大部分用数字表示的数量不应该表示为纯数字，应该加上单位。 状态模型 状态图描述一个 事物或对象 受 事件或消息 刺激产生 可见的状态（属性/属性组合） 的数据变化。 基础符号 起始状态（Initial） 终止状态（Final） 取消/对象取消（Termination） 状态（State） 变迁（Transform），含条件（Condition）、事件（Event）和事件处理动作（Action/Handler） 扩展符号 复合状态 信号 states notation 绘图注意事项： 必须有起始状态，通常有终止和取消状态 状态命名要用名词短语、动词过去时或正在进行时等具有延续性的词汇 在需求分析过程中，尽可能不涉及动作 期末复习活动图活动图：一种有助于使工作流和业务过程可视化的图。 注意事项： 一定要有起点终点，起点只有一个，终点可以有多个（活动终点、流程终点） 有箭头的线，如果有循环一定有归并节点，如果有条件的话，一定要写guard（写在guard里面会自动加上左右中括号[ ]的，guard在constraint选项卡里面）。 作图时不要追求画的太详细，否则来不及画完！ 主要注意图中存在开始、结束、循环！特别注意循环的表达，分支循环 活动图中的基本动作一般都会——对应该用例内的子用例（用例图中的子用例），不过每个人画的差异会很大 可能会考什么是活动状态Activity： 活动状态用于表达状态机中的非原子的运行，特点如下： a) 活动状态可以分解成其他子活动或者动作状态 b) 活动状态的内部活动可以用另一个活动图来表示 c) 和动作状态不同，活动状态可以有入口动作和出口动作，也可以有内部转移 d) 动作状态(Action)是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态。 活动图 状态图状态图主要用于描述一个对象在其生存期间的动态行为，表现为一个对象所经历的状态序列，引起状态转移的事件（Event），以及因状态转移而伴随的动作（Action）。一般可以用状态机对一个对象的生命周期建模，状态图用于显示状态机，重点在与描述状态图的控制流。 重要概念定义：事件、状态和转换 事件：指一件值得注意的事情的发生。 状态：指对象在事件发生之间某时刻所处的情形。 转换：两个状态之间的关系。它表明当某事件发生时，对象从先前的状态转换到后来的状态。 状态无关和状态依赖对象 如果一个对象对某事件的响应总相同，则认为此对象对该事件状态无关（或非模态）。例如，如果对象接收某个消息，响应该消息的方法总做相同的事情，则该对象对于该消息状态无关。如果，对所有事件，对象的响应总是相同的，则该对象是一个状态无关对象。 相反，状态依赖对象对事件的响应根据对象的状态或模式而不同。 有关准则： a.考虑为具有复杂行为的状态依赖对象而不是状态无关对象建立状态机图 b.一般来讲，业务信息系统通常只有少数几个复杂的状态依赖类，对此，状态机建模通常作用不大。与此相反，在过程控制、设备控制、协议处理和通信等领域通常有许多的状态依赖对象。如果你在这些领域工作，应该熟悉和考虑使用状态机建模。 注意事项A.注意状态图的对象是什么。它可能是一个system，也可能是一个用例，也可能是一个对象，一定要看清楚题目要求画什么东西的状态图。 B.画系统和用例的状态图一般是画它的过程，而画对象的状态图是画它的生命周期。 C.然后就是找状态了，一定要知道状态变量是什么，一定要能枚举状态有哪些情况。 D.接下来是操作。 1、 识别状态图的对象 2、 识别状态：考试是有组合状态的。 3、 转换边： 格式：触发事件 [监护条件] / 动作 触发事件：触发转换的事件，包括调用、触发信号、时间等（对象或系统里面创建什么计划，发生什么变化） 监护条件（guard）：决定是否能转换的条件，监护条件为true才能转换 动作：转换被激活时会发生的操作（外部发生的事件） √ 事件一般用被动语态写出来（用被动语态写出来的叫做触发，如onKeyPressed，一般是与代码对应的函数名相同的）。 √ 如果程序显式告诉你，“如果什么，怎么样”，则一定要写guard，否则要扣分 √ 动作可以不写，写错了要扣分 √ 一定要在连线上写出各种条件！ √ 文档详细告诉有何状态，一定要完整写出 E.状态图不一定有终点，一定有起点！ 5.绘制状态机图步骤 绘制状态机图的理想步骤是：寻找主要的状态，确定状态之间的转换 ，细化状态内的活动与转换，用复合状态来展开细节 a.寻找主要状态：对于航班机票预订系统而言，显然包括的状态主要有 – 在刚确定飞机计划时，显然是没有任何预订的，并且在有人预订机票之前都将处于这种“无预订”状态 – 对订座而言显然有“部分预订”和“预订完”两种状态 – 而当航班快要起飞时，显然要“预订关闭” 总结一下，主要有四种状态：无预订、部分预订、预订完以及预订关闭 b.确定状态间转换。表格进行表示：表格横向是转出，表格纵向是转入 c.细化状态内的活动与转换 d.使用复合状态 6.转换的5要素： •源状态：即受转换影响的状态 •目标状态：当转换完成后对象的状态 •触发事件：用来为转换定义一个事件，包括调用、改变、信号、时间四类事件 •监护条件：布尔表达式，决定是否激活转换、 •动作：转换激活时的操作 状态图 领域模型重要概念 领域模型：是对领域内的概念类或现实世界中对象的可视化表示。领域模型也称为概念模型，领域对象模型和分析对象模型。 应用UML表示法，领域模型被描述为一组没有定义操作的类图。它提供了概念透视图。它可以展示： 1）领域类之间的关联2）概念类之间的关联3）概念类的属性 领域模型是可视化字典，表示领域的重要抽象、领域词汇和领域的内容信息。 如何找到概念类 1）重用和修改现有的模型：这是首要、最佳且最简单的方法。2）使用分类列表3）通过识别名词短语寻找概念类 准则：属性和类的常见错误 在创建领域模型时最常见的错误是，把应该是概念类的事物表示为属性。 如果我们认为某概念类X不是现实世界中的数字或文本，那么X可能是概念类而不是属性 准则：何时需要描述类？ 在以下情况下需要增加描述类（例如，ProductDescription）： 1）需要有关商品或服务的描述，独立于任何商品或服务的现有实例 2）删除其所有描述事物的实例后，导致信息丢失，而这些信息是需要维护的，但是被错误地与所删除的事物关联起来 3）减少冗余或重复信息 关联： 关联是类之间的关系，表示有意义和值得关注的连接 在UML中，关联被定义为“两个式多个类元之间的主义联系，涉及这些元实例之间的连接” 准则：为什么应该避免加入大量关联？ 我们要避免在领域模型中加入太多的关联。回顾离散数学的相关知识，可以知道，在具有N个节点的图中，节点间有（n*(n-1)）/2个关联，这可能是个非常大的数值。连线太多会产生“视觉干扰”，使图变得混乱。所在要谨慎地增加关联线。 准则：在UML中如何对关联命名 以“类名—动词短语—类名”的格式为关联命名，其中的动词短语构成了可读的和有意义的顺序。 例如，Sale Paid—by CashPayment 反面示例，应改为Sale Uses CashPayment Player Is—on Square 反面示例，应以为 Player Has Square 关联名称应该使用首字母大写的形式。在UML中，类元应该首字母大写。以下是复合性关联名称的两种常见并且等价的合法格式： Records—current RecordsCurrent 应用UML：角色 关联的每一端称为角色。角色具有如下可选项：1）多重性表达式2）名称3）导航 应用UML：多重性 多重性定义了类A有多少个实例可以和类B的一个实例关联 应用UML：两个类之间的多重关联 在UML类图中，两个类之间可能会有多重关联，这并不罕见。 属性：是对象的逻辑数据值 准则：何时展示属性当需求建议或暗示需要记住信息时，引入属性。例如，在处理销售用例中的票据通常含有工期和时间、店名和地址以及收银员ID等因此， 1）Sale需要dataTime属性 2）Store需要name和address属性 3）Cashier需要ID属性在UML中，属性的完整语法是： visibility name：type multiplicity=default{property—string} 准则：什么样的属性类型是适当的十分常见的数据类型包括：Boolean、Date(or DataTime)、Number、Character、String(Text)和Time等准则：何时定义新的数据类型类下述情况下，在领域模型里，把最初被认为是数字或字符串的数据类型表示为新的数据类型类：1）由不同的小节组成2）具有与之相关的操作，例如解析或校验3）具有其他属性4）单位的数量5）具有以上性质的一个或多个类型的抽象 注意事项 1.名词法：找一堆名词，然后把这堆名词之间的关系给建立起来 2.名词里面有属性。要判断名词是不是概念类，是不是属性。 3.考试的时候是针对一个用例来画领域模型，一定要看清楚是要对哪个用例建模，没有那么多时间对整个系统建模。 （1）先找到所有名词，判断它是类还是属性 找名词的原则（下面不要的名词标红）： 1) 跟UI相关的名词不要 2) 跟database相关的名词不要 3) 跟业务流程没有关系的名词不要，如技术相关的术语，如下面的workflow，list 4) 任何计算出来的结果，不参与业务运算，不要，如果留下了这个会扣分 5) 模糊的术语一定要过滤掉 （2）如果出现动词，扣分 （3）没有名词，扣分 （4）多重性（关联的一对多，一对一等）没有，扣分 （5）漏掉一两个类，不扣分 6、 属性，假如每一个类有七八个属性，只写一两个典型的代表即可，考试没有那么多时间 7、 领域模型的类不能有操作（也就是类的函数），如果写出来要扣分。 8、 如果有描述类，一定要画出来。 描述类是包含其他事物的信息的类。命名方式：被描述类名Description 被描述的事物存在，并且描述独立于事物的实例 比如酒店的每一个同类型的房间价格都是一样的，它并不随着房间号的变化而变化，所以把房间描述独立出来会比较好 9、 没有描述类一定会扣分！ 整个画图的最重要步骤就是找出名词！ 系统顺序图重要概念1.对象： 对象是特定行为与属性的集合。 对象的表示方式有三种： a.包括对象名和类名 b.只有类名。 c.只有对象名 2.消息表示形式： 消息用于描述对象间交互的方式及内容。 消息分为四种：同步消息、异步消息、返回消息、自关联消息 a.同步消息：一个对象向另一个对象发出同步消息后，将处于阻塞状态，一直等到另一个对象的回应。 表示方式： b.异步消息：一个对象向另一个对象发出异步消息后，这个对象可以进行其他的操作，不需要等到另一个对象的响应。 表示方式： c.返回消息：同步消息的返回消息 表示方式： 注意：创建对象的表示法也是用虚线箭头表示！ d.自关联消息：用来描述对象内部函数的互相调用。 表示方式： 3.复合片段 为了支持有条件和循环的构造（以区别于其他事物），UML使用了图框。图框是图的区域或片段，在图框中具有操作符或标签（例如loop）和保护信息（条件子句）。 复合片段有多种，在此主要介绍一下几种：条件判断、可选、循环、同步 a.条件判断：用于描述代码中if…else…这种结构 标记为“alt” b.可选：是一种特殊的“条件判断”，它只是一个if，没有else if或else 可选的标记为：opt c.循环：是指代码中的for、while之类的语句块。 循环的标记为：loop 例如：下图中[m,n]是指至少执行m次，最多执行n次 d.同步：用于描述多线程的情况。 同步的标记是：par 除此之外，顺序图中还包含一种特殊的形式，引用： 在一个顺序图中，可以引用另一个顺序图，其引用方式类似于复合片段， 4.系统顺序图： UML没有定义所谓的“系统顺序图”，而只是定义了“顺序图”。这一限定强调将系统的应用视为黑盒。 系统顺序图是为了阐述与讨论系统相关的输入和输出事件而快速、简单的创建新的制品。 通常，软件系统主要对以下三种时间进行响应： 1）来自参与者（人或计算机）的外部事件 2）时间事件 3）错误或异常（通常源于外部） 注意事项： 通常用系统顺序图来画一个用例场景（例如主场景或复杂的常用的场景）。 1、首先要画一个system，前面要加个冒号，不写system，扣全部分，不写冒号扣1分，位置放错扣1分。 因为要画的是系统事件，没有系统还画什么 2、顺序：最左边是actor（前面也要加冒号），然后是system，然后就是用例的外部实体 3、通常只要求描述一个场景（主场景）。主场景是按照最理想的情况把事情做完就可以了，不需要考虑细节 4、系统顺序图通常只有3-5个事件，消息不应该超过5个！一定要仔细审题，如果某个事件操作很多，直接忽略后面那些细节，否则后面的很难做，越少越好 5、后置条件：直接用注释写在后面 6、后置条件只能写这3句话中的一句或几句： 创建什么对象或删除什么对象，修改什么属性，生成什么关联 这是整个画图考试唯一需要文字的地方 7、操作契约： 操作、交叉引用（用例）、前置条件、后置条件 包图 包图的M里面的元素全都来自领域模型里面。 临时变量都属于控制层，动作的命名规则是在动作后面加个Action或者Controller，一个用例就一个控制器。 用例中出现的界面都属于V 对一个用例画包图就是把这个用例的领域模型里面的元素填到M（domain layer）和C（controller）包里面，然后给界面起个名字，然后写在V（UI）包里面即可。（老师没说要画包之间的关系，他自己画的图也没有画关系，所以干脆还是不要画了吧） 如果有外部支持资源，写在foundation包里面就可以了。 包图 顺序图 实例的创建 UML中要求在创建实例是使用虚线表示。实心箭头表示常规的同步信息，开放箭头表示异步调用。 对象生命线和对象的销毁 在某些情况下，需显式表示对象的销毁。例如当使用没有自动垃圾回收机制的C++时，或者当需要特别指明对象不再使用时（例如关闭数据库连接），都需要如此表示。 UML生命线表示法提供了表示销毁的方式。 4、引用： 在一个顺序图中，可以引用另一个顺序图，其引用方式类似于复合片段， 标签为：ref 注意事项： 1.重点表示主场景是怎么实现的，不关注不成功的情况。 2.遵循使用BCE方法：boundary、control、entity 3.注意名称都是以冒号开头，冒号不写要扣分，画下划线的是静态对象 4.最左边的方法是把SSD里面的方法copy过来，方法不能多也不能少，顺序图是研究系统事件是如何实现的，所以必须和SSD一样的事件。只是把系统的职责转移到控制器中来实现它。 5.记住一定要简洁，遇到并行的就不管了，把意思表达出来就可以了 6.图中的控制器一定要来源于包图中的控制器 7.控制器左边的对象一定是UI的对象 8.控制器中的方法应是在顺序图和交互图中保持一致 9.本题重点是围绕单词，故方法都直接连到单词 设计类图重要概念： 类图（Class Diagram）: 类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。UML用类图表示类、接口及其关联。 表示类元属性的方法： a.属性文本：如currentSale：Sale b.关联线表示法 c.两者兼有 属性文本表示法的完整格式：visibility name : type multiplicity = default {property-string} 关联线表示的属性：导航性箭头+多重性（放在目标一端，而不是源的一端）+角色名（只放在目标一段，用以表示属性名称）+不需要关联名称 准则：通常对数据类型对象使用属性文本表示法，对其他对象使用关联线。 3.关联端点的描述法 关联的端点可以附加导航性箭头，也可包含可选的角色名（关联端点名）来表示属性名称。 关联端点还可以附加多重性值。 关联端点还可以使用{ordered}、{ordered、list}这样的特殊字符串。 4.对象之间的关系 a. 依赖（Dependency） 实体之间一个“使用”关系暗示一个实体的规范发生变化后，可能影响依赖于它的其他实例。更具体地说，它可转换为对不在实例作用域内的一个类或对象的任何类型的引用。其中包括一个局部变量，对通过方法调用而获得的一个对象的引用（如下例所示），或者对一个类的静态方法的引用（同时不存在那个类的一个实例）。也可利用“依赖”来表示包和包之间的关系。由于包中含有类，所以你可根据那些包中的各个类之间的关系，表示出包和包的关系。 b. 关联（Association）——单向关联、双向关联、多维关联、自身关联 实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。 单向关联：实线箭头表示 双向关联：实线无箭头表示 多维关联：关联中心有一个◇（菱形）、实线无箭头进行连接表示 自身关联：由自身出发，回到本身 c. 聚合（Aggregation）——较强的关联关系，局部离开整体之后不会失效 聚合是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。 关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。 d. 合成（Composition）——更强的关联关系，局部离开整体之后失效 合成是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。 局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。 e. 泛化（Generalization）——继承关系 泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。 f. 实现（Realization）——接口的实现 实例关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。 接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。UML类图中接口有两种表示方法：矩形表示法（如图-2中的飞翔的接口）和棒棒糖表示法(如图-2中唐老鸭类中实现讲人话的接口)。矩形表示法，顶端有&lt;&lt;接口&gt;&gt;或者&lt;&gt;，第一行：接口名称，第二行：接口方法。棒棒糖表示法，圆圈旁为接口名称，接口方法在实现类中出现，如唐老鸭类中的讲话。 5.约束 UML约束是对UML元素的限制条件。约束以花括号之间的文本表示，如{size&gt;10} 对属性的约束条件，写在属性后面。对操作的约束，以注释或后置条件的形式写出。但是都要有{}。 绘制要点： 具体方法：http://www.cnblogs.com/riky/archive/2007/04/07/704298.html http://www.uml.org.cn/oobject/201104212.asp http://www.cnblogs.com/silent2012/archive/2011/09/07/2169946.html http://developer.51cto.com/art/201007/209503.htm 实现实例：http://blog.csdn.net/flanet/article/details/7746004 根据实例来看，可以很好的理解掌握类图中需要可以熟练运用的知识点。 注意事项： 1.画图步骤 首先把顺序图里面的类抄过来。 然后查看领域模型，把领域模型里面对应这里的类的属性copy过来，然后把领域模型里面的关联到这里变成实现。 补充类的方法。 控制器类方法的数量只能与前面的系统事件数量一样，系统事件有多少个就只能写多少个方法。 1) 前面的has，own这种关联不能留下来，如果留下来，扣分，应把概念类图中的关联改为有箭头没文字（或有在关联端点有文字）的表示 2) 多重性要保持 3) 不要写什么set方法、get方法，这是编程的问题，不是这里的问题 2.一定要与交互图一一对应 方法和对象都要一一对应！！ 3.Domain中先把除了UI和Controller之外的都放进去 分别确定每个对象的属性，依赖，实现 画出domain中的各个对象之间的关系（存在的方法） 4.领域模型==》概念透视图 设计模型（DCD）==》软件透视图 设计类图 部署图 重要概念： 1. 部署图 部署图表示的是，如何将具体的软件制品（例如可执行文件）分配到计算节点（具有处理服务的某种事物）上。部署图表示了软件元素在物理架构上的部署，以及物理元素之间的通信（通常通过网络进行）。 2. 部署图中最基本的元素是节点。有两种节点： a.设备节点——具有处理和存储能力，可执行软件的物理（电子数字式）计算资源，例如典型的计算机或移动电源。 •设备（《device》）：没有处理能力的节点，至少是不关心其处理能力的节点。例如打印机、IC卡读写器，如果我们的系统不考虑它们内部的芯片，就可建模为设备 b.执行环境节点——在外部节点（如计算机）中运行的软件计算资源，其自身可以容纳和执行其他可执行软件元素。 •处理器（《process》）：具有处理能力的节点，即可以执行构件 如，操作系统（OS）是容纳和执行操作程序的软件。 虚拟机（VM）容纳和执行程序。 数据库引擎（如PostgreSQL）接受SQL语句并执行之，并且容纳和执行内部存储过程（用Java或其它专有语言编写） web浏览器容纳和执行JavaScript、Java Applets、Flash和其他可执行的元素。 工作流引擎。 Servlet容器或EJB容器。 节点属性和操作：可以为一个节点提供处理器速度、内存容量、网卡数量等属性，可以为其提供启动、关机等操作 3. 通信路径： 节点之间的一般连接表示一种通信路径，上面可以标记协议。他们通常表示网络连接。为了更好地表示两个节点之间的关系，我们可以通过“约束”来对连接进行描述。约束表示为{}。 4. 节点命名 实例名称格式：Node Instance : node 与结点的区别在于名称有下划线和结点类型前面有冒号，冒号前面可以有示例名称也可以没有示例名称 通常在UML中，具体实例的名称带有下划线，如果没有下划线则代表类，而不是实例。注意，该规则对于交互图中的实例具有例外，以生命线框图表示实例，其名称没有下划线。通常，在任何情况下，我们可以看到部署图中对象实例名称带下划线。但是UML规范中规定，部署图中的下划线可以忽略。 5. 物件（Artifact） 物件是软件开发过程中的产物，包括过程模型（比如用例图、设计图等等）、源代码、可执行程序、设计文档、测试报告、需求原型、用户手册等等。物件表示如下，带有关键字«artifact»和文档图标，或者表示为《artifact》+name。 6. 节点和构件的联系与区别： 节点的概念和构件有许多相同之处，例如二者有多名称，都可以参与依赖、泛化和关联关系，都可以被嵌套，都可以有实例，都可以参与交互。 但它们之间也存在明显的区别：构件是参与系统执行的事物，而节点是执行构件的事物；构件表示逻辑元素的物理打包，而节点表示构件的物理部署 注意事项： 1.节点：分类题目中已告知 根据图中所给的信息，将部署图对应画出来就可以了。 2.操作系统等信息在节点中表示为{OS=XXXX} 3.数据库与其他的通信协议为JDBC。","tags":[{"name":"notes","slug":"notes","permalink":"http://dafenghh.github.io/tags/notes/"}]},{"title":"系统分析与设计 Homework 5","date":"2019-05-15T01:24:11.000Z","path":"post/e1d7adc4.html","text":"订旅馆建模绘制用例图模型（到子用例） Rerserve Hotel Use Case 给出 make reservation 用例的活动 Rerserve Hotel Activity 课程练习“投递员使用投递箱给收件人快递包裹”的业务场景分别用多泳道图建模三个场景的业务过程 场景1 场景2 场景3 根据上述流程，给出快递柜系统最终的用例图模型 用正常色彩表示第一个业务流程反映的用例用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor 快递柜 Use Case","tags":[{"name":"homework","slug":"homework","permalink":"http://dafenghh.github.io/tags/homework/"}]},{"title":"系统分析与设计 Homework 4","date":"2019-05-04T02:12:52.000Z","path":"post/96d09d52.html","text":"简答题用例的概念用例是一组相关的成功和失败场景集合，用来描述参与者如何使用系统来实现其目标。 用例和场景的关系？什么是主场景或 happy path？场景也称为用例实例。一个用例代表了场景的集合，包含主场景和一些可选场景。主场景相当于主要的系统交互，即成功场景。 用例有哪些形式？ Brief 摘要 Casual 非正式 Fully 详述 对于复杂业务，为什么编制完整用例非常难？复杂业务涉及的故事和场景非常多，用例的完全性依赖于其编写者。 什么是用例图？用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。 用例图（User Case）是外部用户（被称为参与者）所能观察到的系统功能的模型图。 用例图的基本符号与元素？ 符号 含义 椭圆 表示每个用例 矩形框 表示整个系统 小人 绘制在矩形框外，表示参与者 连线 连接某一参与者与某一用例，表示该参与者和该用例有交互 箭头 用例之间的包含关系/扩展关系/泛化关系 用例图的画法与步骤 绘制“子系统”边界, 重命名“子系统” 绘制参与者（放在所有系统边界之外）, 重命名参与者 绘制用例 a) 使用参与者自身能够理解的名称重命名用例，不要使用与代码有关的名称 b) 从主要的事务开始，直到后面较小的交互为止 c) 将每个用例放入支持它的系统或主要子系统（忽略只与用户有关的外观或组件） d) 可以在系统边界外绘制用例，表明系统不支持该用例 将参与者与用例相连 使用“包括”、“扩展”和“泛化”关系结构化用例 用例图给利益相关人与开发者的价值有哪些？ 利益相关人：更加清楚系统的功能和用途 开发者：更加清楚用户需求和软件使用方式，使软件架构的设计思路更清晰。 建模练习题（用例模型） 选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求： 请使用用户的视角，描述用户目标或系统提供的服务 粒度达到子用例级别，并用 include 和 exclude 关联它们 请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例 尽可能识别外部系统和服务 选择背单词APP百词斩，绘制用例图。 百词斩 扇贝 然后，回答下列问题：为什么相似系统的用例图是相似的？ 因为相似系统的需求也相近，用户需要的功能相近，所以用例图也是相似的。 如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用 因为用例图可以表示出用户在实现某个目标所需要经过的关键步骤，因此可以在这些关键步骤中寻找业务创新、技术创新、商业模式创新。比如背单词APP可以在问题的设置上寻求创新，百词斩的创新是以图片帮助记忆，扇贝的创新是由用户选择是否记得一个单词。","tags":[{"name":"homework","slug":"homework","permalink":"http://dafenghh.github.io/tags/homework/"}]},{"title":"系统分析与设计 Homework 3","date":"2019-04-29T08:37:16.000Z","path":"post/8b408f1.html","text":"简答题简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。 从项目特点、风险特征、人力资源利用角度思考 瀑布模型瀑布模型试图在编程之前详细定义所有或大部分需求，通常在编程之前创建出完整的设计，会试图在开始前定义“可靠的”计划或时间表，但往往事与愿违。 瀑布模型带来了高失败率，低生产率和高缺陷率。原因：软件开发的需求是时常变化的。变更对于软件项目来说是永恒的。计划很难是一成不变的，几乎不可能在开始阶段就确立好详细计划。计划必须要随项目进行而动态修改，以适应新的需求和风险。 增量模型增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件。运用增量模型的软件开发过程是递增式的过程。相对于瀑布模型而言，采用增量模型进行开发，开发人员不需要一次性地把整个软件产品提交给用户，而是可以分批次进行提交。 增量模型适用于具有以下特征的软件开发项目： 软件产品可以分批次地进行交付。 待开发的软件系统能够被模块化。 软件开发人员对应用领域不熟悉，难以一次性地进行系统开发。 项目管理人员把握全局的水平较高。 增量模型对软件设计有更高的技术要求，特别是对软件体系结构，要求它具有很好的开放性与稳定性，能够顺利地实现构件的集成。增量构件要求具有相当好的功能独立性，其接口应该简单，以方便集成时与系统的连接。$[1]$ 螺旋模型螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级的软件应用。$[2]$ 简述统一过程三大特点，与面向对象的方法有什么关系？ 可伸缩性(scalable)：不需要使用统一过程的全部框架，只需要有用的部分。 有效性(effective): 统一过程已被大量项目成功实践。 用已有的实践方法提高生产效率(productivity)。 简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？划分准则是达成里程碑的时间点。 初始阶段生命周期目标里程碑：评价项目基本的生存能力。 细化阶段生命周期结构里程碑：为系统的结构简历管理基准并使得项目小组能够在构建阶段中进行衡量，需要检验详细的系统目标和范围、结构的选择以及主要风险的解决方案。 构造阶段初始功能里程碑：决定产品是否可以在测试环境中进行部署，要确定软件、环境、用户是否可以开始系统的运作。 交付阶段产品发布里程碑：确定目标是否实现，是否应该开始另一个开发周期。 软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？软件企业可以按固定节奏生产，固定周期发布软件产品，是因为软件企业有规范的管理体系和方法，了解软件的本质特征，能够很好地认识项目的工期、质量、范围、预算，遵循先做到再做好的原则，运用了正确的开发模型。 它可以使得企业项目管理具有明确的阶段划分，由于每个阶段都会有显著的里程碑，使得每个迭代阶段都有明确的目标。这反逼项目管理确定合理的产品范围，不投入大量时间在冗余的工作中，从而提到团队生产效率。 Reference:1: 增量模型_百度百科2: 螺旋模型_百度百科","tags":[{"name":"homework","slug":"homework","permalink":"http://dafenghh.github.io/tags/homework/"}]},{"title":"系统分析与设计 Homework 2","date":"2019-04-03T03:59:59.000Z","path":"post/7fb33867.html","text":"简答题用简短的语言给出对分析、设计的理解。分析是捕捉现实世界的业务的特性，描述处理的数据和处理数据的各种过程，得到软件需求。 设计是根据软件需求，对软件结构、功能进行规划、拆分，构建可实现的解决方案。 用一句话描述面向对象的分析与设计的优势。对象的引入方便了在软件虚拟世界中模拟现实世界，面向对象方法带来更强的封装能力，有利于模块化开发。封装、抽象、继承和多态，提高了软件的可重用性、可维护性和可扩展性。 简述 UML（统一建模语言）的作用。考试考哪些图？ UML以图形作为表现形式，产生的模型清晰简洁，易于理解。 有利于开发人员与用户之间的沟通。 用UML进行系统建模得到的建模制品不仅仅包含各种模型框图，还有大量丰富的文档，这些文档给系统后期的维护工作带来了便捷。 用UML作为编程语言，使用UML完成软件系统的执行规范，可运行的代码就能够被自动生成。 用UML敏捷建模，与草图的功能类似，通过建立UML顺序图，能够提高开发的质量和速度。 考试要考： 用例图：(用户角度) 功能、执行者 静态图：系统静态结构 类图：概念及关系 对象图：某种状态或时间段内，系统中活跃的对象及其关系 包图：描述系统的分解结构 行为图：系统的动态行为 交互图：描述对象间的消息传递 顺序图：强调对象间消息发送的时序 合作图：强调对象间的动态写作关系 状态图：对象的动态行为。状态 - 事件 - 状态迁移 - 响应动作 活动图：描述系统为完成某功能而执行的操作序列 实现图：描述系统的组成和分布状况 构件图：组成部件及其关系 部署图：物理体系结构及与软件单元的对应关系 从软件本质的角度，解释软件范围（需求）控制的可行性对需求进行限制，有利于需求更加清晰明确，降低管理成本。需求频繁变更会带来严重成本，限制需求范围可减少变更数量，使开发更有效率。 项目管理实践看板使用练习 看板练习 UML绘图工具练习画系统顺序图，课本129页 P10-3 系统顺序图","tags":[{"name":"homework","slug":"homework","permalink":"http://dafenghh.github.io/tags/homework/"}]},{"title":"系统分析与设计 Homework 1","date":"2019-03-17T13:45:28.000Z","path":"post/e6ba69dd.html","text":"简答题1. 软件工程的定义简单来讲，软件工程即软件开发领域里对工程方法的系统应用。 IEEE对软件工程的定义是将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中。 2. 解释导致 software crisis 本质原因、表现，述说克服软件危机的方法软件危机是由于计算机能力的迅速增加以及无法解决的问题的复杂性，而导致软件危机的本质原因是软件的复杂性、一致性、可变性和不可视性。典型表现有以下几种： 项目运行超出预算 项目运行时间过长 软件效率低 软件质量差 软件不符合要求 项目难以管理，代码难以维护 软件无法成功交付 克服软件危机的方法是系统化、与时俱进的软件工程。 3. 软件生命周期软件生命周期是软件的产生直到报废的生命周期，周期内有问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级到废弃等阶段，这种按时间分程的思想方法是软件工程中的一种思想原则，即按部就班、逐步推进，每个阶段都要有定义、工作、审查、形成文档以供交流或备查，以提高软件的质量。 4. SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）(1) Software Requirements软件需求。 软件需求知识域关注的方面是软件需求的启发，协商，分析，规范和验证。人们普遍认为，若需求不清晰，则软件项目会变得很脆弱。软件需求表达了对软件产品的需求和限制，这些需求和约束有助于解决一些现实问题。 (2) Software Design软件设计。 设计的定义是：定义体系结构、组建、接口以及其他系统或组建特性的过程和结果。 软件设计知识域涵盖了设计过程和最终产品。软件设计过程是软件工程生命周期活动，包括分析软件需求以产生软件内部结构及其行为的描述，将其作为其构造的基础。软件设计（结果）必须描述软件体系结构，即软件如何分解和组织成组件与组件之间的接口。 (3) Software Construction软件构建。 软件构建是指通过结合详细设计，编码，单元测试，集成测试，调试和验证来详细创建工作软件。 (4) Software Testing软件测试。 测试是一项旨在评估产品质量并通过识别缺陷来改进产品质量的活动。软件测试涉及在有限的测试用例集上针对预期行为动态验证程序的行为。这些测试用例是从（通常非常大的）执行域中选择的。软件测试知识域包括软件测试的基础知识、测试技术、交互界面测试与评估、与测试有关的方法和实际考虑。 (5) Software Maintenance软件维护。 软件维护包括增强现有功能，调整软件以在新的和修改的操作环境中运行，以及纠正缺陷。这些类别分别称为完善，自适应和纠正性软件维护。软件维护知识域包括软件维护的基础知识（维护的性质和需求，维护类别，维护成本）、软件维护中的关键问题（技术问题，管理问题，维护成本估算，软件维护测量）、维护过程、 软件维护技术（程序理解，重新设计，逆向工程，重构，软件退役）、 灾难恢复技术和软件维护工具。 (6) Software Configuration Management软件配置管理。 系统的配置是硬件，固件，软件或这些的组合的功能和物理特征。软件配置管理（SCM）是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。软件配置管理知识域涵盖SCM过程的管理、软件配置识别，控制，状态核算，审计、软件发布管理和交付. (7) Software Engineering Management软件工程管理。 软件工程管理涉及规划，协调，测量，报告和控制项目或程序，以确保软件的开发和维护是系统化的，规范化的和量化的。软件工程管理知识域涵盖了启动和范围定义（确定和协商要求，可行性分析以及要求的审查和修订）; 软件项目计划（过程计划，工作量估算，成本和进度，资源分配，风险分析，质量计划）; 软件项目制定（计量，报告和控制;收购和供应商合同管理）; 产品验收; 审查和分析项目绩效; 项目结束; 和软件管理工具。 (8) Software Engineering Process软件工程过程。 (9) Software Engineering Models and Methods软件工程模型和方法。软件工程模型和方法知识域提出了不同生命周期阶段的工程方法。包括建模、模型类型、分析和软件开发方法。 (10) Software Quality软件质量。软件质量是软件生命周期中无处不在的关注点。软件质量知识域涵盖了软件质量基础、软件质量管理过程和实际考虑。 (11) Software Engineering Professional Practice软件工程专业实践。 软件工程专业实践是关于软件工程师进行专业、负责、合乎道德的软件工程实践时所需要的知识、技术和态度。软件工程专业实践知识域包含敬业精神、道德准则、小组活力和交流技巧。 (12) Software Engineering Economics软件工程经济学。 软件工程经济学知识域关注的是在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。涵盖的主题包括软件工程经济学的基本原理、非营利性决策、经济风险和不确定性估计和多属性决策。 (13) Computing Foundations计算基础。计算基础知识域涵盖了提供软件工程实践所需的计算基础主题。涵盖的主题包括问题解决技术，抽象，算法和复杂度，编程基础，并行和分布式计算的基础知识，计算机组成原理，操作系统和网络通信。 (14) Mathematical Foundations数学基础。数学基础知识域涵盖了提供软件工程实践所必需的数学背景的基础主题。涵盖的主题包括集合，关系和函数; 基本命题和谓词逻辑; 证明技巧; 图形和树; 离散概率; 语法和有限状态机和数论。 (15) Engineering Foundations工程基础。 工程基础知识域涵盖了提供软件工程实践所必需的工程背景的基础主题。涵盖的主题包括经验方法和实验技术; 统计分析; 测量和指标; 工程设计; 仿真与建模以及根本原因分析。 5. 简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。6. 用自己语言简述 SWEBok 或 CMMI （约200字）","tags":[{"name":"homework","slug":"homework","permalink":"http://dafenghh.github.io/tags/homework/"}]},{"title":"CCPC-Wannafly Winter Camp 2019 Day 4 题解","date":"2019-01-24T23:49:58.000Z","path":"post/5505493b.html","text":"H 命命命运题意wls等六人在玩大富翁。 大富翁的棋盘上一共有n块地，这些地围成了一个圈（n号地的下一块地是1号地）。 每一轮，六个玩家会依次掷出一颗骰子（编号小的玩家先掷），并往前走骰子上显示的数字那么多步。 第一个踩到某块地的玩家能够得到这块地。 给出p[i][j], 表示第i个玩家掷出j的概率。 现在请问，500轮以后，每个玩家拥有的地的块数的期望分别是多少？ 所有人都从1号点出发，出发前大家不能买地（第二次到1号点才能买这块地）。 分析我们需要求出对于i号玩家，第j轮，获得第k块地的概率，然后把所有j,k取值下的概率累加起来，就是每个人获得地的块数的期望。i号玩家，获得第j块地等价于1..(i-1)号玩家前j轮不曾走到k，i号玩家第j轮第一次走到k，(i+1)..6号玩家前(j-1)轮未曾走到k. 于是我们要求出两个概率来，never[i][j][k]表示i号玩家前j轮未曾走到k的概率，first[i][j][k]表示i号玩家第j轮第一次走到k的概率。 为了求出这两个东西，我们还需要一维状态，即玩家当前所处的位置。所以pos[i][j][k][m]表示i号玩家前j轮未曾走到k，走完第i轮后位于m的概率。 转移式很好写出来。于是我们得到了一个个复杂度O(6*6*500*n^2)的优秀算法, n为500， 爆了。 那么怎么优化这个东西呢？ 突破口在于，pos数组的k只需要求前7块地就可以了。这样由pos的结果得到前7块地的first和never值，而后面8..n块地的first,never值可以直接由前面7块地的first,never值分别递推出来。因为每一轮掷骰子的概率是独立的，跟所处位置无关，j轮移动可以看成1+(j-1)轮，即走完第一轮再走j-1轮。例如，我们求first[i][j][k], 可以枚举第一轮移动的步数t，贡献就是p[i][t]*first[i][j-1][k-t]. never同理。 于是我们得到了正解。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 502;int n;double p[6][6], first[6][N][N], never[6][N][N], pos[6][N][7][N];void solve(double p[], double first[N][N], double never[N][N], double pos[N][7][N]) &#123; for (int j = 0; j &lt;= 6; j++) pos[0][j][0] = 1; for (int i = 0; i &lt;= 500; i++) for (int j = 0; j &lt;= 6; j++) for (int k = 0; k &lt; n; k++) &#123; never[i][j] += pos[i][j][k]; for (int t = 0; t &lt; 6; t++) &#123; int nk = (k+t+1)%n; if (nk == j) first[i+1][j] += pos[i][j][k] * p[t]; else pos[i+1][j][nk] += pos[i][j][k] * p[t]; &#125; &#125; for (int k = 0; k &lt; n; k++) never[0][k] = 1; for (int i = 1; i &lt;= 500; i++) for (int j = 7; j &lt; n; j++) for (int t = 0; t &lt; 6; t++) &#123; first[i][j] += p[t] * first[i-1][j-t-1]; never[i][j] += p[t] * never[i-1][j-t-1]; &#125;&#125;double ans[6];int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; 6; i++) for (int j = 0; j &lt; 6; j++) scanf(\"%lf\", &amp;p[i][j]); for (int i = 0; i &lt; 6; i++) solve(p[i], first[i], never[i], pos[i]); for (int i = 0; i &lt; 6; i++) for (int j = 1; j &lt;= 500; j++) for (int k = 0; k &lt; n; k++) &#123; double prob = first[i][j][k]; for (int t = 0; t &lt; i; t++) prob *= never[t][j][k]; for (int t = i+1; t &lt; 6; t++) prob *= never[t][j-1][k]; ans[i] += prob; &#125; for (int i = 0; i &lt; 6; i++) printf(\"%.3lf\\n\", ans[i]); &#125;","tags":[{"name":"DP","slug":"DP","permalink":"http://dafenghh.github.io/tags/DP/"}]},{"title":"CCPC-Wannafly Winter Camp 2019 Day 3 题解","date":"2019-01-24T23:49:44.000Z","path":"post/5fc04022.html","text":"","tags":[]},{"title":"CCPC-Wannafly Winter Camp 2019 Day 2 题解","date":"2019-01-24T23:48:22.000Z","path":"post/936a40bc.html","text":"","tags":[]},{"title":"CCPC-Wannafly Winter Camp 2019 Day 1 题解","date":"2019-01-24T23:48:10.000Z","path":"post/1de5475f.html","text":"","tags":[]},{"title":"Computer Networking, Chapter 4, THE NETWORK LAYER, Notes","date":"2018-11-06T02:27:49.000Z","path":"post/77b83dd5.html","text":"Forwarding involves the transfer of a packet from an incoming link to an outgoing link within a single router. Routing involves all of a network’s routers, whose collective interactions via routing protocols determine the paths that packets take on their trips from source to destination node.","tags":[{"name":"Computer Networking","slug":"Computer-Networking","permalink":"http://dafenghh.github.io/tags/Computer-Networking/"}]},{"title":"codeforces 1025G Company Acquisitions 题解","date":"2018-09-11T09:07:52.000Z","path":"post/d05b63c9.html","text":"题目大意n家公司，每个公司有两种状态，独立或者附属于某一独立公司。每天发生这样一次操作：等概率选择两个独立公司A和B，等概率指定A吞并B,或者B吞并A。假设A吞并B，那么B就成为A的附属公司，然后原来附属B的公司全部独立。给定初始每个公司的状态，求期望多少天后，只有一家独立公司。 solution超有意思的数学（构造）题……一直在想DP做法，但这个状态没办法表示。所以要转化思路。设一个有k个附属公司的独立公司的potential值为$2^k-1$，则可证明，一次操作后，potential和的增量的期望为1. 然后这就简单了，将终态和初始态的potential相减就行了。 source code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int Mod = 1e9+7;typedef long long ll;ll mod_pow(ll x, ll n) &#123; ll res = 1; for (; n &gt; 0; n &gt;&gt;= 1) &#123; if (n &amp; 1) res = res * x % Mod; x = x * x % Mod; &#125; return res;&#125;int cnt[600];void add(int &amp;a, ll b) &#123; a = (a + b) % Mod;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); int ans = 0; add(ans, mod_pow(2, n - 1) - 1); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); if (x != -1) ++cnt[x]; &#125; for (int x = 1; x &lt;= n; x++) &#123; if (cnt[x] &gt; 0) add(ans, 1 - mod_pow(2, cnt[x])); &#125; add(ans, Mod); printf(\"%d\\n\", ans);&#125;","tags":[{"name":"constructive algorithms","slug":"constructive-algorithms","permalink":"http://dafenghh.github.io/tags/constructive-algorithms/"},{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"Computer Networking, Chapter 1, Computer Networks and the Internet, Notes","date":"2018-09-04T02:13:08.000Z","path":"post/527c28.html","text":"1.1.3 What’s Protocol?A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event. 1.2 Network Edgeend systems = hosts (Two categories: clients and servers) Today, most of the servers from which we receive search results, e-mail, Web pages, and videos reside in large data centers. 1.2.1 Access NetworksThe access network: the network that physically connects an end system to the first router (also known as the “edge router”) on a path from the end system to any other distant end system. Home AccessToday, the two most prevalent types of broadband residential access are digital subscriber line (DSL) and cable. DSL: 数字用户线路，是以电话线为传输介质的传输技术组合。DSLAM: DSL access multiplexer DSL Internet access Fiber optics connect the cable head end to neighborhood-level junctions, from which traditional coaxial cable is then used to reach individual houses and apartments. A hybrid fiber-coaxial access network Because both fiber and coaxial cable are employed in this system, it is often referred to as hybrid fiber coax (HFC). Coaxial cable: 同轴电缆 cable modem termination system (CMTS) Ethernet and Wi-FiLAN: local area networkAlthough there are many types of LAN technologies, Ethernet is by far the most prevalent access technology. Wide-Area Wireless Access: 3G and LTELTE: Long-Term Evolution 长期演进技术 1.2.2 Physical MediaPhysical media fall into two categories: guided media and unguided media. With guided media, the waves are guided along a solid medium, such as a fiber-optic cable, a twisted-pair copper wire, or a coaxial cable. With unguided media, the waves propagate in the atmosphere and in outer space, such as in a wireless LAN or a digital satellite channel. Twisted-Pair Copper Wire Coaxial Cable Fiber Opticshigh-speedoperation, low error rate Terrestrial Radio Channels Satellite Radio Channelsgeostationary satellites, low-earth orbiting (LEO) satellites 1.3 Network Core1.3.1 Packet Switchingpacket switches (for which there are two predominant types, routers and link layer switches) Store-and-Forward Transmission The packet switch must receive the entire packet before it can begin to transmit the first bit of the packet onto the outbound link. Queuing Delays and Packet Lossoutput bufferIn addition to the store-and-forward delays, packets suffer output buffer queuing delays. Packet loss may occur when buffer is completely full. Forwarding Tables and Routing ProtocolsEach router has a forwarding table that maps destination addresses (or portions of the destination addresses) to that router’s outbound links. The Internet has a number of special routing protocols that are used to automatically set the forwarding tables. Ad. &amp; Disad. great for bursty data (resource sharing, simpler) excessive congestion possible. 1.3.2 Circuit SwitchingIn circuit-switched networks, the resources needed along a path (buffers, link transmission rate) to provide for communication between the end systems are reserved for the duration of the communication session between the end systems. e.g. traditional telephone networks guaranteed constant rate Multiplexing in Circuit-Switched NetworksA circuit in a link is implemented with either frequency-division multiplexing (FDM) or time-division multiplexing (TDM). 频分/时分多路复用 1.3.3 A Network of Networks regional ISPs tier-1 ISPs PoP: points of presence, a group of one or more routers (at the same location) in the provider’s network where customer ISPs can connect into the provider ISP. Any ISP (except for tier-1 ISPs) may choose to multi-home, that is, to connect to two or more provider ISPs. ISPs at the same level of the hierarchy can peer. When two ISPs peer, it is typically settlement-free, that is, neither ISP pays the other. Internet Exchange Point (IXP): a meeting point where multiple ISPs can peer together. content provider networks 见P61 图片 1.4 Delay, Loss, and Throughput in Packet-Switched Networks1.4.1 overviewProcessing DelayThe time required to: examine the packet’s header and determine where to direct the packet check for bit-level errors in the packet(on the order of microseconds)Queuing DelayThe number of packets that an arriving packet might expect to find is a function of the intensity and nature of the traffic arriving at the queue.Transmission DelayL/RPropagation Delayd/s 1.4.2 Queuing Delay and Packet Losstraffic intensity: La/R (a: the average rate at which packets arrive at the queue, in units of packets/sec)Golden rule: Design your system so that the traffic intensity is no greater than 1.As the traffic intensity approaches 1, the average queuing delay increases rapidly. Packet Loss1.4.3 End-to-End DelayTraceroute 1.4.4 Throughput in Computer NetworksWhen transferring a large file from Host A to Host B, the instantaneous throughput at any instant of time is the rate (in bits/sec) at which Host B is receiving the file. Average throughput: F/T bits/sec","tags":[{"name":"Computer Networking","slug":"Computer-Networking","permalink":"http://dafenghh.github.io/tags/Computer-Networking/"}]},{"title":"Codeforces Round #493 Summary","date":"2018-07-21T14:07:54.000Z","path":"post/96fa61b.html","text":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://dafenghh.github.io/tags/codeforces/"}]},{"title":"CodeChef - SCIENCEF Science Fair 题解","date":"2018-05-09T13:43:01.000Z","path":"post/a5930d20.html","text":"题目大意有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。 大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下： cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）) 司机会选择一条使cost最小的路线行驶。问cost的期望。 solution扩展版旅行商问题。关键是先重构图。压缩至只有S，F跟学生所在点。而这些点间的边权应该定义为原图中不经过别的学生的最短路长度。用$n^2$次dijkstra重构图完成后，就是一个旅行商问题了。之后状态压缩DP解决。 dp1[x][i]表示当前走到第i个点，访问过的点集为x的最小cost。dp2[x]表示访问学生集合为x以及x的超集的最小cost。这就是最终答案了。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll Mod = 1e9+7;ll sum(ll a, ll b) &#123; return (a + b) % Mod;&#125;ll&amp; Add(ll &amp;a, ll b) &#123; return a = sum(a, b);&#125;ll product(ll a, ll b) &#123; return a * b % Mod;&#125;ll&amp; Mul(ll &amp;a, ll b) &#123; return a = product(a, b);&#125;const ll iv = 570000004LL;ll talkative[1 &lt;&lt; 17], ti[17], pi[20], mi[17];int V, E, S, F, n;const int N = 1020;const ll INF = 253432145421354LL;ll sp[20][20], d[N];struct edge&#123; int to; ll cost; edge(int to = 0, ll cost = 0):to(to), cost(cost)&#123;&#125;&#125;;vector&lt;edge&gt; G[N];int studentOnVertex[N];void Mini(ll &amp;a, ll b) &#123; if (b &lt; a) a = b;&#125;typedef pair&lt;ll, int&gt; P;typedef pair&lt;ll, P&gt; Tuple;ll dp[1&lt;&lt;17][20], dp2[1&lt;&lt;17];int main() &#123; scanf(\"%d%d%d%d%d\", &amp;V, &amp;E, &amp;S, &amp;F, &amp;n); S--, F--; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%lld%lld%lld\", pi + i, ti + i, mi + i); pi[i]--; &#125; for (int i = 0; i &lt; E; i++) &#123; int x,y,w; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); --x,--y; G[x].push_back(edge(y, w)); G[y].push_back(edge(x, w)); &#125; talkative[0] = 1; for (int x = 0; x &lt; (1 &lt;&lt; n); x++) &#123; for (int i = 0; i &lt; n; i++) &#123; if ((x &amp; (1 &lt;&lt; i)) == 0) &#123; talkative[x|(1&lt;&lt;i)] = product(talkative[x], ti[i]); &#125; &#125; &#125; memset(studentOnVertex, -1, sizeof studentOnVertex); for (int i = 0; i &lt; n; i++) &#123; studentOnVertex[pi[i]] = i; &#125; pi[n] = S; pi[n + 1] = F; for (int s = 0; s &lt;= n + 1; s++) for (int t = s + 1; t &lt;= n + 1; t++) &#123; fill(d, d + V, INF); d[pi[s]] = 0; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; que.push(P(0, pi[s])); while (!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second; if (p.first &gt; d[v]) continue; for (auto e: G[v]) &#123; int u = e.to; ll cost = e.cost; int stui = studentOnVertex[u]; if (stui != -1 &amp;&amp; stui != s &amp;&amp; stui != t) continue; if (d[u] &gt; d[v] + cost) &#123; d[u] = d[v] + cost; que.push(P(d[u], u)); &#125; &#125; &#125; sp[s][t] = sp[t][s] = d[pi[t]]; &#125; for (int x = 0; x &lt; (1 &lt;&lt; n); x++) for (int i = 0; i &lt;= n; i++) dp[x][i] = INF; dp[0][n] = 0; priority_queue&lt;Tuple, vector&lt;Tuple&gt;, greater&lt;Tuple&gt; &gt; que; que.push(Tuple(0, P(0,n))); while (!que.empty()) &#123; Tuple tup = que.top(); que.pop(); int x = tup.second.first, i = tup.second.second; if (tup.first &gt; dp[x][i]) continue; for (int j = 0; j &lt; n; j++) &#123; if (j == i) continue; int nx = x | (1 &lt;&lt; j); if (dp[nx][j] &gt; dp[x][i] + sp[i][j]) &#123; dp[nx][j] = dp[x][i] + sp[i][j]; que.push(Tuple(dp[nx][j], P(nx,j))); &#125; &#125; &#125; for (int x = 1; x &lt; (1 &lt;&lt; n); x++) &#123; dp2[x] = INF; for (int i = 0; i &lt; n; i++) &#123; if (x &amp; (1 &lt;&lt; i)) Mini(dp2[x], dp[x][i] + sp[i][n+1]); &#125; dp2[x] += talkative[x]; &#125; for (int x = (1 &lt;&lt; n) - 1; x &gt; 0; x--) &#123; for (int i = 0; i &lt; n; i++) Mini(dp2[x], dp2[x|(1&lt;&lt;i)]); &#125; ll ans = 0; for (int x = 1; x &lt; (1 &lt;&lt; n); x++) &#123; ll temp = 1; for (int i = 0; i &lt; n; i++) &#123; if (x &amp; (1 &lt;&lt; i)) &#123; Mul(temp, mi[i]); &#125; else &#123; Mul(temp, 100 - mi[i]); &#125; Mul(temp, iv); &#125; Mul(temp, dp2[x]); Add(ans, temp); &#125; printf(\"%lld\\n\", ans);&#125;","tags":[{"name":"DP","slug":"DP","permalink":"http://dafenghh.github.io/tags/DP/"},{"name":"shortest path","slug":"shortest-path","permalink":"http://dafenghh.github.io/tags/shortest-path/"},{"name":"graph","slug":"graph","permalink":"http://dafenghh.github.io/tags/graph/"}]},{"title":"CodeChef - GENPERM Generating A Permutation 题解","date":"2018-05-09T13:15:57.000Z","path":"post/75299267.html","text":"题目大意对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, p3) + … + max(pN-1, pN) 给出N，K。构造排列P， 使f(P) = K. 如果不存在，就输出-1. solutionf(P)的值是N-1个数的和。而原排列中的数，最多贡献两次答案。 考虑排列是正序时，f(P)取到最小值，为2+3+…+N。也即2到N的数，每个数贡献1次。最大值应该是在最大的那些数都贡献2次时取到。 怎么让最大那个数贡献2次？只需要不把它放两端就可以了。 另外注意到，一个大的数a多贡献一次的同时，就会剥夺另外一个较小的数b的贡献机会，这时候就会使答案增加a-b. 所以这道题的构造方法就是，设a为下一个贡献多一次的数，b为下一个被剥夺贡献机会的数。考虑当前的和，如果加上b-a比答案大，我们就让b大一些，直到满足条件。然后把刚刚考虑过的b依次append到答案数组，再append a就行。 source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10;typedef long long ll;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; ll k; int n; scanf(\"%d%lld\", &amp;n, &amp;k); if (n == 1) &#123; if (k == 0) &#123; printf(\"1\\n\"); &#125; else &#123; printf(\"-1\\n\"); &#125; continue; &#125; ll x = 0; for (int i = 2; i &lt;= n; i++) x += i; if (k &lt; x) &#123; printf(\"-1\\n\"); continue; &#125; int l = 1, r = n; vector&lt;int&gt; vec; while (l + 1 &lt; r) &#123; if (x + r - l - 1 &lt;= k) &#123; x += r - l - 1; vec.push_back(l++); vec.push_back(r--); &#125; else &#123; vec.push_back(l++); &#125; &#125; for (int i = l; i &lt;= r; i++) vec.push_back(i); if (x != k || vec.size() != n) &#123; printf(\"-1\\n\"); continue; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(\"%d%c\", vec[i], \" \\n\"[i==n-1]); &#125; &#125;&#125;","tags":[{"name":"constructive algorithms","slug":"constructive-algorithms","permalink":"http://dafenghh.github.io/tags/constructive-algorithms/"}]},{"title":"Hello World","date":"2018-05-02T06:38:13.860Z","path":"post/4a17b156.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Codeforces Educational Codeforces Round 43 Summary","date":"2018-05-01T01:57:28.000Z","path":"post/af1c4a82.html","text":"Summary比赛中仅仅做出3道水题。 卡E。E一直想不出。曾有猜测“所有1st type spells全部用于一个creature”，但无法证明，也不敢下定论。没想到这就是正解。 题解E. Well played!题目大意有n个物品，每个物品有两个值hp和dmg. 现有a个第一类道具和b个第二类道具。第一类道具可以使某个物品的hp翻倍，第二类道具可以将某个物品的hp赋值给dmg. 问使用了这些道具后，所有物品dmg和的最大值。 数据范围: $1\\leq n\\leq2\\cdot10^5,0\\leq b\\leq2\\cdot10^5,0\\leq a\\leq 20$ solution下面先证明，最优解一定是全部第一类道具用于同一个物品。分别用x和y表示物品的hp和dmg. 那么如果两个物品同时用了第一类道具，分别用了$a_1$和$a_2$个，它们的总dmg就是$d_1 = {x_1}2^{a_1}+{x_2}2^{a_2}$. 如果将第一类道具全部用于第1个物品，总dmg为$d_2={x_1}2^{a_1+a_2}+\\max(x_2, y_2)$ 假设d1更优，则有$${x_1}2^{a_1}+{x_2}2^{a_2} &gt; {x_1}2^{a_1+a_2}+\\max(x_2, y_2)$$ 移项，有$${x_1}2^{a_1}(2^{a_2}-1) &lt; {x_2}2^{a_2} - \\max(x_2, y_2)$$ 考虑到$\\max(x_2, y_2) \\geq x_2$,则有$${x_1}2^{a_1}(2^{a_2}-1) &lt; {x_2}(2^{a_2}-1)$$ 即$${x_1}2^{a_1}&lt; {x_2}$$ 同理，为了让$d_1$比第一类道具全部用于第2个物品的情况更优，有$${x_2}2^{a_2}&lt; {x_1}$$ 两个不等式矛盾，证毕。 这样一来，就可以O(n)枚举每个物品使用第一类道具的情况。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5+10;struct P &#123; ll h, d; bool used; P(ll h = 0, ll d = 0): h(h), d(d), used(false)&#123;&#125; bool operator &lt; (const P &amp;b) &#123; return h - d &gt; b.h - b.d; &#125;&#125;a[N];void Maxi(ll &amp;a, ll b) &#123; if (b &gt; a) a = b;&#125;int main() &#123; int n, A, b; scanf(\"%d%d%d\", &amp;n, &amp;A, &amp;b); ll k = 1; for (int i = 0; i &lt; A; i++) k &lt;&lt;= 1; for (int i = 0; i &lt; n; i++) &#123; int h,d; scanf(\"%d%d\", &amp;h, &amp;d); a[i] = P(h, d); &#125; sort(a, a + n); ll tot = 0, cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (a[i].h &gt; a[i].d &amp;&amp; cnt &lt; b) &#123; ++cnt; tot += a[i].h; a[i].used = true; &#125; else &#123; tot += a[i].d; &#125; &#125; ll ans = tot; for (int i = 0; i &lt; n; i++) &#123; ll h = a[i].h * k; if (h &lt;= a[i].d) continue; if (a[i].used) &#123; Maxi(ans, tot - a[i].h + h); &#125; else &#123; ll temp = tot - a[i].d + h; if (cnt == b) &#123; temp = temp - a[b - 1].h + a[b - 1].d; &#125; Maxi(ans, temp); &#125; &#125; printf(\"%lld\\n\", ans);&#125;","tags":[{"name":"summary","slug":"summary","permalink":"http://dafenghh.github.io/tags/summary/"},{"name":"codeforces","slug":"codeforces","permalink":"http://dafenghh.github.io/tags/codeforces/"},{"name":"greedy","slug":"greedy","permalink":"http://dafenghh.github.io/tags/greedy/"}]},{"title":"2018.04.22 Kharagpur Regional 2017 集训总结","date":"2018-04-29T12:13:01.000Z","path":"post/9ffddd26.html","text":"Summary赛中通过3题，FDK. F是暴力水题，D和K一共7记罚时，做得不好。D的错误是考虑错了复杂度，所以超时，加上输出%lld写成%d（经典错误）。K的错误是思考不谨慎，连边时加了一个多余的判断条件。 赛后没把H想出来。已经想得差不多，不过看错数据范围。一直以为要O(n^2)算法，其实是O(n^3). 要是看仔细点说不定就能想出来。（经典DP套路，请把训练指南的DP章节刷一遍，锻炼思维！） 赛后补了AHJ。还差EIB。加油，补完！ A J B E I A Science Fair题目大意有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。 大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下： cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）) 司机会选择一条使cost最小的路线行驶。问cost的期望。 solution扩展版旅行商问题。关键是先重构图。压缩至只有S，F跟学生所在点。而这些点间的边权应该定义为原图中不经过别的学生的最短路长度。用$n^2$次dijkstra重构图完成后，就是一个旅行商问题了。之后状态压缩DP解决。 dp1[x][i]表示当前走到第i个点，访问过的点集为x的最小cost。dp2[x]表示访问学生集合为x以及x的超集的最小cost。这就是最终答案了。 见Science Fair题解 B Black DiscsC Uniform StringsD SAD QueriesE Chef and XOR QueriesF Taxi Making Sharp TurnsG Spam Classification Using Neural NetH Non Overlapping SegmentsI Spanning TreeJ Generating A Permutation题目大意对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, p3) + … + max(pN-1, pN) 给出N，K。构造排列P， 使f(P) = K. 如果不存在，就输出-1. solutionf(P)的值是N-1个数的和。而原排列中的数，最多贡献两次答案。 考虑排列是正序时，f(P)取到最小值，为2+3+…+N。也即2到N的数，每个数贡献1次。最大值应该是在最大的那些数都贡献2次时取到。 怎么让最大那个数贡献2次？只需要不把它放两端就可以了。 另外注意到，一个大的数a多贡献一次的同时，就会剥夺另外一个较小的数b的贡献机会，这时候就会使答案增加a-b. 所以这道题的构造方法就是，设a为下一个贡献多一次的数，b为下一个被剥夺贡献机会的数。考虑当前的和，如果加上b-a比答案大，我们就让b大一些，直到满足条件。然后把刚刚考虑过的b依次append到答案数组，再append a就行。 见Generating A Permutation题解 K Number Game","tags":[{"name":"summary","slug":"summary","permalink":"http://dafenghh.github.io/tags/summary/"}]},{"title":"codeforces gym 101635C [Macarons] 2017-2018 ACM-ICPC, Southwestern European Regional Programming Contest (SWERC 2017) 题解","date":"2018-01-26T07:22:09.000Z","path":"post/9049154c.html","text":"题目大意用1*1或者1*2的小长方形完整覆盖N*M的长方形（不可重叠），问有多少种覆盖方式？ 题目分析行数很少，N &lt;= 8, 列数很多，M &lt;= 10^18 对于每一列，用一个长度为N的二进制串表示它的状态，0表示这一个位置放置着1*1的方块，1表示这一个位置放置着1*2的方块。 构造这样一个转移矩阵，T[i][j]表示状态i的列右边连着状态j的列的时候，有多少种状态j的列是可行的。 然后对矩阵求快速幂即可。 source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9;int get()&#123; char ch; int v,f=0; while (!isdigit(ch=getchar())) if (ch=='-') break; if (ch=='-') f=1;else v=ch-48; while (isdigit(ch=getchar())) v=v*10+ch-48; return f?-v:v;&#125; int n;typedef long long ll;const int maxn =300;ll mat[maxn][maxn], M,sz;int trans(int X, int Y)&#123; int dp[10][2]; dp[0][0]=1, dp[0][1]=0; for (int i = 1, bin = 1; i &lt;= n; i++, bin &lt;&lt;= 1) &#123; int x = ((X &amp; bin) &gt; 0), y = ((Y &amp; bin) &gt; 0); if (y == 1) &#123; dp[i][0] = dp[i-1][1] + (x==0?dp[i-1][0]:0); dp[i][1] = dp[i-1][0]; &#125; else &#123; dp[i][0] = dp[i-1][0]; dp[i][1] = 0; &#125; &#125; return dp[n][0];&#125;long long tmp[maxn][maxn],Map[maxn][maxn];int ksm(ll m[maxn][maxn],ll t,int N)&#123; memcpy(Map,m,sizeof(Map)); t--; while (t)&#123; if (t%2==1)&#123; for (int i=1;i&lt;=N;i++) for (int j=1;j&lt;=N;j++) tmp[i][j]=0;//清空临时数组 for (int i=1;i&lt;=N;i++) for (int k=1;k&lt;=N;k++) if (m[i][k]) for (int j=1;j&lt;=N;j++) tmp[i][j]+=m[i][k]*Map[k][j]%mod,tmp[i][j]%=mod; //矩阵乘法 for (int i=1;i&lt;=N;i++) for (int j=1;j&lt;=N;j++) Map[i][j]=tmp[i][j]; //赋值到原数组 &#125; for (int i=1;i&lt;=N;i++) for (int j=1;j&lt;=N;j++) tmp[i][j]=0;//清空临时数组 for (int i=1;i&lt;=N;i++) for (int k=1;k&lt;=N;k++) if (m[i][k]) for (int j=1;j&lt;=N;j++) tmp[i][j]+=m[i][k]*m[k][j]%mod,tmp[i][j]%=mod; for (int i=1;i&lt;=N;i++) for (int j=1;j&lt;=N;j++) m[i][j]=tmp[i][j]; t&gt;&gt;=1; &#125; ll ans=0; for (int i=1;i&lt;=N;++i) ans=(ans+Map[N][i])%mod; return ans;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; M; sz = (1 &lt;&lt; n); for (int i = 1; i &lt;= sz; i++) for (int j = 1; j &lt;= sz; j++) &#123; mat[i][j] = trans(i-1, j-1); &#125; cout &lt;&lt; ksm(mat,M,sz)&lt;&lt;endl; return 0;&#125;","tags":[]},{"title":"codeforces gym 101635J [Frosting on the Cake] 2017-2018 ACM-ICPC, Southwestern European Regional Programming Contest (SWERC 2017) 题解","date":"2018-01-26T06:32:45.000Z","path":"post/8e378f9.html","text":"题目大意 将一块蛋糕，横切n-1刀，竖切n-1刀。使水平方向上，各块宽度分别为B1, B2…Bn；垂直方向上，各块宽度分别为A1, A2…An. 现在，按从左到右，从上到下的顺序，给每一小块依次循环染色“白 黄 粉”三种颜色。 求出每一种颜色的方块的总面积。 题目分析其实就是一个简单的取余问题。 source code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int get()&#123; char ch; int v,f=0; while (!isdigit(ch=getchar())) if (ch=='-') break; if (ch=='-') f=1;else v=ch-48; while (isdigit(ch=getchar())) v=v*10+ch-48; return f?-v:v;&#125; const int maxn = 100020;typedef long long ll;ll a[maxn], b[maxn];ll am[3],ans[3];int n;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i], am[i%3] += a[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 3; j++) ans[j] += b[i] * (am[((ll)j-(ll)i*n-2+3*(ll)maxn*maxn)%3]); &#125; cout &lt;&lt; ans[0] &lt;&lt;\" \" &lt;&lt; ans[1] &lt;&lt; \" \" &lt;&lt; ans[2] &lt;&lt; endl; return 0;&#125;","tags":[{"name":"implementation","slug":"implementation","permalink":"http://dafenghh.github.io/tags/implementation/"}]},{"title":"codeforces gym 101620L [Lunar Landscape] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解","date":"2018-01-26T05:40:19.000Z","path":"post/96671495.html","text":"题目大意卫星拍下了地面的很多照片。每张照片覆盖了平面的一个正方形区域，这个正方形要么边与坐标轴平行，要么对角线与坐标轴平行，保证中心点和顶点都在坐标整点的位置。 求被覆盖的区域面积。 题目分析如果题目只给出边与坐标轴平行的正方形的话，那这道题很简单，直接二维前缀和就OK。 但这道题有侧着放的正方形（对角线与坐标轴平行），又该怎么处理呢？ 首先发现，一个正方形小格可以按对角线分成4块小三角形，有多少块小三角形被覆盖，则要看侧正方形的分布情况。 如果用一下坐标变换，将坐标系向由旋转45度，再将单位长度设置为小三角形的直角边长。可以求出，这个坐标变换的表达式为：$x’=x-y,y’=x+y$ 旋转坐标系后，将每一个小三角形视为一个元素，然后对这些小三角形用二维前缀和即可。 找出变换后的坐标跟原来坐标的对应关系，本题解答完成。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 1600;int f[2 * N][2 * N], g[8 * N][4 * N];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++)&#123; char s[10]; int x,y,d; scanf(\"%s%d%d%d\",s, &amp;x,&amp;y,&amp;d); d /= 2; if (s[0] == 'A') &#123; f[x-d+N][y-d+N]++; f[x+d+N][y-d+N]--; f[x-d+N][y+d+N]--; f[x+d+N][y+d+N]++; &#125; else &#123; int x0 = x - y, y0 = x + y; x = x0, y = y0; g[2*x-2*d+4*N][y-d+2*N]++; g[2*x+2*d+4*N][y-d+2*N]--; g[2*x-2*d+4*N][y+d+2*N]--; g[2*x+2*d+4*N][y+d+2*N]++; &#125; &#125; for (int i = 0; i &lt; 2 * N; i++) for (int j = 0; j &lt; 2 * N; j++) &#123; if (i &gt; 0) f[i][j] += f[i-1][j]; if (j &gt; 0) f[i][j] += f[i][j-1]; if (i &gt; 0 &amp;&amp; j &gt; 0) f[i][j] -= f[i-1][j-1]; &#125; for (int i = 0; i &lt; 8 * N; i++) for (int j = 0; j &lt; 4 * N; j++) &#123; if (i &gt; 0) g[i][j] += g[i-1][j]; if (j &gt; 0) g[i][j] += g[i][j-1]; if (i &gt; 0 &amp;&amp; j &gt; 0) g[i][j] -= g[i-1][j-1]; &#125; double ans = 0; for (int x = -1510; x &lt; 1510; x++) for (int y = -1510; y &lt; 1510; y++) &#123; if (f[x+N][y+N]) ans++; else &#123; int x0 = x - y, y0 = x + y; if (g[2*x0-1+4*N][y0+1+2*N]) ans += 0.25; if (g[2*x0-1+4*N][y0+2*N]) ans += 0.25; if (g[2*x0+4*N][y0+1+2*N]) ans += 0.25; if (g[2*x0+4*N][y0+2*N]) ans += 0.25; &#125; &#125; printf(\"%.2lf\\n\", ans); &#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"codeforces gym 101620H [Hidden Hierarchy] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解","date":"2018-01-26T05:39:40.000Z","path":"post/1dd196f0.html","text":"题目大意给出n个文件的路径和大小，然后要像Windows资源管理器的侧边栏那样输出文件夹的分层结构。当一个文件夹里的所有子文件夹大小都不超过t时，它会折叠起来。 题目分析模拟题，集训的时候打崩了。关键是建树的过程，将路径拆分成文件夹名的vector，然后利用这个vector创建这个路径上的所有文件夹的结点。 所有结点按创建次序保存在数组中，每一个结点包含一个map, 存放它的子节点，“文件夹名”到结点位置的映射。 这样一来，这道题就很好写了。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct dir&#123; string name; int sz; map&lt;string, int&gt; subdir;&#125;a[60000];int tot = 0, t;void addFile(vector&lt;string&gt; &amp;path, int pi, int sz, int ai) &#123; a[ai].sz += sz; if (pi &gt;= path.size()) return; if (!a[ai].subdir.count(path[pi])) &#123; a[++tot].name = path[pi]; a[ai].subdir[path[pi]] = tot; &#125; addFile(path, pi + 1, sz, a[ai].subdir[path[pi]]);&#125;bool canFold(int ai) &#123; for (auto i:a[ai].subdir) if (a[i.second].sz &gt;= t) return false; return true;&#125;void printDir(int ai = 0, string ps = \"\") &#123; ps += a[ai].name + \"/\"; if (a[ai].subdir.empty()) &#123; printf(\" %s %d\\n\", ps.c_str(), a[ai].sz); &#125; else if (canFold(ai)) &#123; printf(\"+ %s %d\\n\", ps.c_str(), a[ai].sz); &#125; else &#123; printf(\"- %s %d\\n\", ps.c_str(), a[ai].sz); for (auto i:a[ai].subdir) printDir(i.second,ps); &#125;&#125;char str[1024];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; int sz; scanf(\"%s%d\", str, &amp;sz); vector&lt;string&gt; path; string buf; int len = strlen(str); for (int i = 1; i &lt; len; i++) &#123; if (str[i] == '/') path.push_back(buf),buf.clear(); else buf += string(1, str[i]); &#125; addFile(path, 0, sz, 0); &#125; scanf(\"%d\", &amp;t); printDir();&#125;","tags":[{"name":"dfs and similar","slug":"dfs-and-similar","permalink":"http://dafenghh.github.io/tags/dfs-and-similar/"},{"name":"tree","slug":"tree","permalink":"http://dafenghh.github.io/tags/tree/"}]},{"title":"NWERC 2017 H [High Score] (The 2017 Northwestern Europe Regional Contest) 题解","date":"2018-01-24T02:34:18.000Z","path":"post/54cee541.html","text":"题目大意题目链接 （可能需要翻墙） 给定a,b,c, 定义 $score = a^2 + b^2 + c^2+7\\cdot \\min(a,b,c)$ 现在给出一个d，要将d拆成三份作为a，b，c的增量，即赋值a += d1, b += d2, c += d3, 满足d1, d2, d3 &gt;= 0, d1 + d2 + d3 = d 求score的最大值。 题目分析注意到加上d后，前面平方项的增量是O(d^2)级别，后面min(a,b,c)这项是O(d)级别，所以当d比较大时，把d全部加给a b c中的最大值即可；d比较小时，暴力一一验证即可。 source code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123;trueint n;truecin&gt;&gt;n;truefor (int i=1;i&lt;=n;++i)&#123;truetruell a,b,c,d;truetruecin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;truetruell sz0 = 4, sz1 = 10;truetrueif (a &lt; sz0 &amp;&amp; b &lt; sz0 &amp;&amp; c &lt; sz0 &amp;&amp; d &lt; sz1) &#123;truetruetruell ans = a*a+b*b+c*c+7*min(a,min(b,c));truetruetruefor (ll d1 = 0; d1 &lt;= d; d1++)truetruetruefor (ll d2 = 0, d3 = d - d1 - d2; d2 &lt;= d &amp;&amp; d3 &gt;= 0; d2++, d3 = d - d1 - d2) &#123;truetruetruetrueans = max(ans, (a+d1)*(a+d1)+(b+d2)*(b+d2)+(c+d3)*(c+d3)+7*min(a+d1, min(b+d2,c+d3)));truetruetrue&#125;truetruetruecout &lt;&lt; ans &lt;&lt; endl;truetruetruecontinue;truetrue&#125;truetruell mat=max(max(a,b),c);truetruell t1=ll(a+d)*(a+d)+(ll)b*b+(ll)c*c+ll(7)*min(min(a+d,b),c);truetruell t2=ll(a)*a+ll(b+d)*(b+d)+(ll)c*c+ll(7)*min(min(a,b+d),c);truetruell t3=ll(a)*a+ll(b)*b+ll(c+d)*(c+d)+ll(7)*min(min(a,b),c+d);truetruecout&lt;&lt;max(t1,max(t2,t3))&lt;&lt;endl;true&#125;truereturn 0;&#125;","tags":[]},{"title":"codeforces gym 101630B [Box] 2017-2018 ACM-ICPC, Northern Eurasia (Northeastern European Regional) Contest (NEERC 17) 题解","date":"2018-01-23T12:47:49.000Z","path":"post/5f7aa68.html","text":"题目大意给定一张w*h大小的纸片，要求裁剪出一个a*b*c的长方体的展开图，问是否可行。 题目分析长方体展开图共有11种情况，分别算出每种情况所需要的长宽，然后枚举验证即可。 P.S. 小学奥数题的升级版。一开始用蛮力想象展开图平起来后的边的情况。但毕竟自己的空间想象能力并不是很强，而且这样很费时，所以并不是好的做法。其实只要在展开图中根据相邻关系标上边的长度即可。 P.S. opentrain的测试数据很弱，集训时1A。回来交CF，WA了第40个点。改了一个小时后，WA第55个点。原来自己的next_permutation用在了原边长数组上，犯了一个低级错误。 source code12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int A[3],inx[3]=&#123;0,1,2&#125;;trueint w, h;bool comp(int a, int b) &#123;trueif (a &lt;= w &amp;&amp; b &lt;= h) return true;trueif (b &lt;= w &amp;&amp; a &lt;= h) return true;truereturn false;&#125;int main() &#123;truefor (int i = 0; i &lt; 3; i++) scanf(\"%d\", A + i);truetruescanf(\"%d%d\", &amp;w, &amp;h);truebool find = false;truedo &#123;truetrueint a = A[inx[0]], b= A[inx[1]], c = A[inx[2]];truetrueif (comp(2*(a+c), b + 2 * c)||truetruetruecomp(3*b+a+c,a+c)|| truetruetruecomp(a+b+c,a+b+2*c)|| truetruetruecomp(a+b+c,2*b+2*c)||truetruetruecomp(a+2*b+c,a+2*c)) find = true;true&#125;while (!find &amp;&amp; next_permutation(inx, inx + 3));trueputs(find?\"Yes\":\"No\");&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"codeforces gym 101630C [Connections] 2017-2018 ACM-ICPC, Northern Eurasia (Northeastern European Regional) Contest (NEERC 17) 题解","date":"2018-01-23T11:01:49.000Z","path":"post/a35a5595.html","text":"题目大意给定一个强连通的有向图，n个点，m条边；要求，去掉m-2n条边，使剩下的图仍然强连通。 题目分析采用DFS，将需要保留下的边打上记号。然后任意输出m-2n条不需要保留的边即可。 哪些边需要保留呢？ DFS前进的那些边（即搜索树中的边，“实边”）一定要保留，至于虚边，则保留得越少越好。 所以优先从搜索树的靠叶子端取虚边。比如DFS依次经过1-&gt;2-&gt;3-&gt;4, 我们就先从4开始取回去的边，回去得越前越好，即如果同时存在(4,3)和(4,2）就取（4，2）,然后回到结点2，再取一条(2,1)就能构成一个环，也即强连通的子图。 具体实现的话，dfs返回当前访问子树能够回去的最前结点（有点类似tarjan的lowlink）。对一个结点来说，所有虚边只需考虑最优那条（即返回的点index越小越好）。然后拿它跟子树返回结果的最小值（代表子树能够回去的最前结点）比较，如果这条虚边更有，就连上。 P.S. 1A这题，很开心！ source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;using namespace std;int n,m;const int maxn = 100020;vector&lt;int&gt; G[maxn];typedef pair&lt;int, int&gt; P;map&lt;P, int&gt; M;bool used[maxn];int index[maxn], cnt;int dfs(int v) &#123; index[v] = cnt++; used[v] = true; int bv = v, nbi = index[v]; for (auto i: G[v]) &#123; if (!used[i]) &#123; M[P(v,i)] = 1; nbi = min(nbi, dfs(i)); &#125; else if (index[i] &lt; index[bv]) bv = i; &#125; if (index[bv] &lt; nbi) &#123; M[P(v, bv)] = 1; &#125; return min(nbi, index[bv]);&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); M.clear(); cnt = 0; memset(used, 0, sizeof(used)); memset(index, 0, sizeof(index)); for (int i = 1; i &lt;= n; i++) G[i].clear(); for (int i = 0; i &lt; m; i++) &#123; int x,y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); M[P(x,y)] = 0; &#125; dfs(1); int tot = 0; for (auto i: M) &#123; if (!i.second) &#123; tot++; printf(\"%d %d\\n\", i.first.first, i.first.second); if (tot == m - 2 * n) break; &#125; &#125; &#125;&#125;","tags":[{"name":"graphs","slug":"graphs","permalink":"http://dafenghh.github.io/tags/graphs/"},{"name":"dfs and similar","slug":"dfs-and-similar","permalink":"http://dafenghh.github.io/tags/dfs-and-similar/"}]},{"title":"POJ 3470 [Walls] 题解","date":"2018-01-22T15:11:51.000Z","path":"post/7d2ff651.html","text":"题目大意平面上有n条与坐标轴平行的互不相交的线段，代表墙；还有m个不在线段上的点，代表鸟。鸟会沿着坐标轴方向，飞向离它最近的墙，并撞上去。求每一面墙会有多少只鸟撞上来。 题目分析先离散化坐标。 按其中一个坐标（比如y）排好序后，使用扫描线算法，对于另一个坐标（比如x）建一棵支持区间更新和单点查询的线段树，表示每一个点当前会撞向的墙的序号。 自己写的扫描线啰嗦地惨不忍睹，WA很多次都没过。 参考了下forever97 的代码，非常简洁优雅，落落大方。真是感激不尽！ source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int maxn = 200020;int tr[maxn * 2];int query(int x, int v = 0, int l = 0, int r = maxn - 20) &#123; if(tr[v] != -2) return tr[v]; if (l + 1 == r) return tr[v]; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; if (x &lt; mid) return query(x, chl, l, mid); return query(x,chr,mid, r);&#125;void update(int L, int R, int val, int v = 0, int l = 0, int r = maxn - 20) &#123; if (r &lt;= L || R &lt;= l) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; tr[v] = val; return; &#125; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; if (tr[v] != -2) &#123; tr[chl] = tr[chr] = tr[v]; tr[v] = -2; &#125; update(L, R, val, chl, l, mid); update(L, R, val, chr, mid, r); &#125;int X[maxn], Y[maxn], X_inx[maxn], Y_inx[maxn],X_comp[maxn], Y_comp[maxn], wall_to_fly[maxn], total_for_wall[maxn],dis[maxn];int *arr;int wn,pn; // wall pointbool cmp(int a, int b) &#123; return arr[a] &lt; arr[b];&#125;void compress(int *X, int *Comp,int *Inx, int n=pn) &#123; arr = X; for (int i = 0; i &lt; n; i++) Inx[i] = i; sort(Inx, Inx + n, cmp); int cnt = 0;Comp[Inx[0]] = 0; for (int i = 1; i &lt; n; i++) &#123; if (X[Inx[i]] != X[Inx[i-1]]) cnt++; Comp[Inx[i]] = cnt; &#125;&#125;void scan(int *X, int *Y, int *X_comp, int i) &#123; if (i &lt; wn) &#123; int i_ = i^1; if (X_comp[i_] &gt;= X_comp[i]) &#123; update(X_comp[i], X_comp[i_]+1,i/2); &#125; &#125;else &#123; int q = query(X_comp[i]); if (q != -1) &#123; int d = min(abs(Y[i] - Y[2*q]), abs(Y[i] - Y[2*q+1])); i-=wn; if (dis[i] == -1 || d &lt; dis[i]) &#123; dis[i] = d; wall_to_fly[i] = q; &#125; &#125; &#125;&#125;void fly(int *X, int *Y, int *X_comp, int *Inx) &#123; tr[0] = -1; for (int i = 0; i &lt; pn; i++) scan(X, Y, X_comp, Inx[i]); tr[0] = -1; for (int i = pn; i &gt;= 0; i--) scan(X, Y, X_comp, Inx[i]);&#125;int main() &#123; memset(dis, -1, sizeof(dis)); int n_, m_; scanf(\"%d%d\", &amp;n_, &amp;m_); wn = 2 * n_; pn = wn + m_; for (int i = 0; i &lt; pn; i++) scanf(\"%d%d\", X + i, Y + i); compress(X, X_comp, X_inx); compress(Y, Y_comp, Y_inx); fly(X, Y, X_comp, Y_inx); fly(Y, X, Y_comp, X_inx); for (int i = 0; i &lt; m_; i++) total_for_wall[wall_to_fly[i]]++; for (int i = 0; i &lt; n_; i++) printf(\"%d\\n\", total_for_wall[i]);&#125;","tags":[{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"scanline","slug":"scanline","permalink":"http://dafenghh.github.io/tags/scanline/"}]},{"title":"NWERC 2017 A [Ascending Photo] (The 2017 Northwestern Europe Regional Contest) 题解","date":"2018-01-22T15:08:38.000Z","path":"post/7c1f2f41.html","text":"题目大意题目链接 给定一个序列，将它切割成若干段，使得对每一段进行移动之后可以重排成非严格升序。求最少的切割数。 题目分析（集训的时候就差DP这步没想出来。） 首先先将相邻的相同元素合并，并进行离散化（不影响答案）。 然后现在将数组的每一个元素都切开（即切n-1下），比如1|2|3|0|4 于是问题可以转化为，这n-1块“挡板”最多有多少块可以去掉，如果为s，那么最终答案就是n-1-s. 在上面的例子中，唯一能够去掉的挡板是(2,3), 即变成1|2 3|0|4 很显然，挡板能够去掉首先要满足，左右两个元素相差1. 另外，假如有多块(2,3)挡板，比如对于1|2|3|4|2|3 (2,3)的挡板只能去掉其中一块（不然装不回来）。所以，我们可以先将所有值出现的位置保存到vector中，然后从小到大考虑值，每两个相邻的值应该去掉哪一块挡板（有可能去不掉）。 另外，如果去掉前面的(2,3)挡板，这时候会发现，紧接着后面的(3,4)挡板就去不了了。 否则会变成：1|2 3 4|2|3 可以看到最右边的3落下了。 所以可以看到，去掉一个挡板有可能会产生一个冲突位置。具体地说，如果存在连续序列(a,a+1,a+2), 并且a+1在数组中不唯一，那么去掉(a,a+1)挡板将会导致(a+1,a+2）的挡板无法去除。 用dp[i]表示去除值(0,1)到值(i,i+1)的所有可去除的挡板数量。 注意到，dp[i]的值与每一步去除哪一块可选挡板有关，所以要加多一维。dp[i][j]的j表示，去除值(i,i+1)的挡板时，考虑的是位置(j,j+1) 即首先i和j有条件，h[j] = i, h[j+1] = i+1 dp[i][j] = max(dp[i-1][j&#39;] + （j是不是j&#39;产生的冲突位置?0:1）) “j是不是j’产生的冲突位置” 等价于j = j&#39; + 1 &amp;&amp; h[j]不唯一 从这个条件可以看出，对于一个j’，最多产生一个冲突位置，j’+1(当h[j’+1]唯一就不是冲突位置）。 对于一个j，只可能是一个位置j’ = j - 1的冲突位置。（条件*） 如果我们把dp[i]看成一张表，那么最后我们求的就是dp[n]的最大值。 观察转移方程，从dp[i]向dp[i+1]转移的时候，求max的是dp[i]这张表的所有元素，但其中有些元素加了1（条件j不是j’的冲突位置）。 所以，我们只需保存这张表最大的那些值就行了。比如某个dp[i]={1,2,3,4,5,5,5}, 我们只需要保存{5,5,5}就行，因为前面的数，比如4，加上1也才是5，并不会更优。 dp[i+1]的值有可能是5，也有可能是6，要看三个5之中，有没有一个5对应的冲突位置不是j，这个5就能加上1，变成6. 回顾条件*，当我们保存了两个dp值最大的j’对应的冲突位置时，那么求 dp[i][j] 就能一定找到一个不冲突的位置，然后累计加上1. 所以，每一步dp求出的表中，只需要保存最大两个值以及它们对应的冲突位置即可，下面代码，用best[0]和best[1]保存最大两个值以及对应的冲突位置。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int get()&#123;truechar ch; int v=0,f=0;truewhile (!isdigit(ch=getchar())) if (ch=='-') break;trueif (ch=='-') f=1;else v=ch-48;truewhile (isdigit(ch=getchar())) v=v*10+ch-48;truereturn f?-v:v;&#125; typedef pair&lt;int, int&gt; P;const int maxn = 1000020;int b[maxn];int main() &#123; vector&lt;int&gt; H; int n = get(); for (int i = 0; i &lt; n; i++) &#123; int x = get(); if (H.empty() || H.back() != x) H.push_back(x); &#125; n = (int)H.size(); for (int i = 0; i &lt; n; i++) b[i] = H[i]; sort(b, b + n); int sz = unique(b, b + n) - b; vector&lt;vector&lt;int&gt; &gt; posi(sz); for (int i = 0; i &lt; n; i++) H[i] = lower_bound(b, b + sz, H[i]) - b, posi[H[i]].push_back(i); P best[2] = &#123;P(0, n), P(0, n)&#125;; for (int h = 0; h &lt; sz - 1; h++) &#123; P nbest[2] = &#123;best[0], best[1]&#125;; for (int i = 0; i &lt; posi[h].size(); i++) &#123; int p = posi[h][i]; if (p == n - 1 || H[p] + 1 != H[p + 1]) continue; P s(0, n); if (p != best[0].second) s = best[0]; else s = best[1]; s.first++, s.second = p + 1; if (posi[h + 1].size() == 1) s.second = n; if (s &gt; nbest[0]) nbest[1] = nbest[0], nbest[0] = s; else if (s &gt; nbest[1]) nbest[1] = s; &#125; best[0] = nbest[0], best[1] = nbest[1]; &#125; printf(\"%d\\n\", n - 1 - best[0].first); &#125;","tags":[{"name":"dp","slug":"dp","permalink":"http://dafenghh.github.io/tags/dp/"}]},{"title":"codeforces gym 101620D [Donut Drone] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解","date":"2018-01-21T12:41:28.000Z","path":"post/a74fadaa.html","text":"题目大意一个矩形方块，有r*c个格子，水平和垂直方向上都可以将它视为首尾相连的（也即从最右边向右移会回到最左边，从最下边向下移会回来最上边，以此类推）。每个格子上有一个数。每一次移动会往相邻的右边、右上、右下的三个格子中选最大数的格子移动。初始位置在左上角。两种操作：1. 移动k步，输出新位置；2.修改某个格子的数。 数据范围：r，c $\\leq$ 2000, 询问数5000以内。 题目分析移动k步时，列数的增量是确定的（k），行数未知，由二维数组确定。 可以很自然地想到用线段树解决这个问题。线段树的每一个结点，维护的是一张从第l列到第r列, 即[L,r)，行数y的转移表（本来行数应该用x来表示，但是一开始敲时就弄混了，所以后面只好交换了x和y的定义）。 这样，当我们从第y行第x列出发时，若k比较小直接模拟。k比较大时，先查询线段树，拿到y在[x, c)的转移值y’。这样就回到了(y’,0) 即第一列。 然后一次走c步，即采用[0,c)的转移表，意思就是从第一列一直往右走，知道走回第一列。不断重复这个过程，每一次可以使步数+c。 理论上这么模拟可以使单次询问的复杂度达到O(k/c*log c); 但考虑到行数只有r个，所以只会产生长度不超过r的环。所以把经过的点记录一下，产生环即跳出。这样复杂度可以优化至O(r*log c). source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 2010;const int INF = 1234567890;int dat[4 * maxn][maxn], row, col , a[maxn][maxn], NY[maxn][maxn],circle[maxn],posi[maxn];int query(int y, int x1, int x2, int v = 0, int l = 0, int r = col) &#123; // [l, r) if (x2 &lt;= l || r &lt;= x1) return y; if (x1 &lt;= l &amp;&amp; r &lt;= x2) return dat[v][y]; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; int LAns = query(y, x1, x2, chl, l, mid); return query(LAns, x1, x2, chr, mid, r);&#125;void update(int x, int y, int val, int v = 0, int l = 0, int r = col) &#123; if (x &lt; l || x &gt;= r) return; if (l + 1 == r) &#123; dat[v][y] = val; return; &#125; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; update(x, y, val, chl, l, mid); update(x, y, val, chr, mid, r); for (int i = 0; i &lt; row; i++) dat[v][i] = dat[chr][dat[chl][i]];&#125;void build(int v = 0, int l = 0, int r = col) &#123; if (l + 1 == r) &#123; for (int i = 0; i &lt; row; i++) dat[v][i] = NY[l][i]; return; &#125; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; build(chl, l, mid); build(chr, mid, r); for (int i = 0; i &lt; row; i++) dat[v][i] = dat[chr][dat[chl][i]];&#125;int read()&#123; int v; char ch; while (!isdigit(ch=getchar())); v=ch-48; while (isdigit(ch=getchar())) v=v*10+ch-48; return v;&#125;int getNY(int x, int y) &#123; int nx = (x + 1) % col, Max = -INF, res; for (int dy = -1; dy &lt;= 1; dy++)&#123; int ny = (y + dy + row) % row; if (a[nx][ny] &gt; Max) &#123; Max = a[nx][ny]; res = ny; &#125; &#125; return res;&#125;int main() &#123; row = read(), col = read(); for (int i = 0; i &lt; row; i++) for (int j = 0; j &lt; col; j++) a[j][i] = read(); for (int i = 0; i &lt; row; i++) for (int j = 0; j &lt; col; j++) NY[j][i] = getNY(j, i); build(); int m = read(); int y = 0, x = 0; while (m--) &#123; char s[10]; scanf(\"%s\",s); if (s[0] == 'm') &#123; int k = read(); if (k &gt; col) &#123; if (x != 0) k-= col-x, y = query(y,x,col),x=0; memset(posi, -1, sizeof(posi)); circle[0] = y; posi[y] = 0; int ci = k / col; k -= ci * col; for (int i = 1; i &lt;= ci; i++) &#123; circle[i] = y = query(y, 0, col); if (posi[y] != -1) &#123; int len = i - posi[y]; y = circle[posi[y] + (ci - posi[y]) % len]; break; &#125; posi[y] = i; &#125; if (k &gt; 0) y = query(y, 0, k); x = k; &#125; else &#123; for (int i = 0; i &lt; k; i++)&#123; y = NY[x][y];x = (x + 1) % col; &#125; &#125; printf(\"%d %d\\n\", y + 1, x + 1); &#125; else &#123; int cy = read() - 1, cx = read() - 1, val = read(); a[cx][cy] = val; int px = (cx + col - 1) % col; for (int dy = -1; dy &lt;= 1; dy++) &#123; int py = (cy + dy + row) % row; int temp = getNY(px, py); if (NY[px][py] != temp) &#123; NY[px][py] = temp; update(px, py, temp); &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"}]},{"title":"HDU 5249 [KPI] 题解","date":"2018-01-17T07:59:57.000Z","path":"post/a54ea176.html","text":"题目大意n次操作，有3种操作的类型：入队、出队、查询队列中的中位数。 题目分析区间第K大的简单版本。用权值线段树可以轻松解决。这里尝试使用一下树状数组。这里搞明白树状数组的原理后，findK函数可以写得很清晰。 稍微解释一下findK函数，从x=1&lt;&lt;16（值的上界）开始定位答案，判定bit[]数组的值来定位答案位于权区间的左半部分还是右半部分。反复执行这个过程，逐步缩小区间得到答案。 source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10020;int tot, bit[maxn];void update(int i, int x) &#123; for (; i &lt;= tot; i += i &amp; -i) bit[i] += x;&#125;int findK(int k) &#123; int ans = 0; for (int x = (1 &lt;&lt; 16); x; x &gt;&gt;= 1) &#123; if (ans + x &lt; tot &amp;&amp; bit[ans + x] &lt; k) &#123; k -= bit[ans += x]; &#125; &#125; return ans;&#125;char Q[maxn];int a[maxn], b[maxn], n;void init() &#123; n = 0; memset(bit, 0, sizeof(bit));&#125;int main() &#123; int qn, ti = 0; while (scanf(\"%d\", &amp;qn) != EOF) &#123; init(); ++ti; printf(\"Case #%d:\\n\", ti); for (int i = 0; i &lt; qn; i++) &#123; char s[10]; scanf(\"%s\", s); Q[i] = s[0]; if (Q[i] == 'i') &#123; scanf(\"%d\", &amp;a[n]); b[n] = a[n]; n++; &#125; &#125; sort(b, b + n); tot = n; for (int i = 0; i &lt; n; i++) a[i] = lower_bound(b, b + n, a[i]) - b + 1; int ql = 0, qr = 0; for (int i = 0; i &lt; qn; i++) &#123; if (Q[i] == 'i') &#123; update(a[qr++], 1); &#125; else if (Q[i] == 'o') &#123; update(a[ql++], -1); &#125; else &#123; printf(\"%d\\n\", b[findK((qr - ql + 2)/ 2)]); &#125; &#125; &#125;&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"}]},{"title":"POJ 1201 [Intervals] 题解","date":"2018-01-17T03:18:14.000Z","path":"post/a568ae24.html","text":"题目大意给定n个区间，现在要从每个区间$[a_i, b_i]$中取出$c_i$个数，所有被取出的数组成一个集合。求这个集合的最小size. 题目分析这种区间覆盖问题，首先考虑贪心法。如果将所有顶点按右端点排序后，依次取数。对每一个区间，尽量取靠右边的数。这是一个挺好的贪心策略，容易证明其正确性。 那么，对每个区间，需要做的事情有两步： （统计）统计这个区间上已经被取过的数的数量，如果已满足要求，则OK；否则进行第二步。 （取数）从右往左依次取新数，直到满足要求。 朴素做法，统计这一步就需要O(n)复杂度，总计O(n^2), 显然不可行。 我们可以采用BIT，把统计这一步优化到O(log n）。 但第二步，取数的复杂度呢？ 直觉来看，最坏情况下，每次取数要O(n)的时间，那么总体是O（n^2）复杂度。 但是，考虑到区间长度有限，也是O(n)的级别，所以实际上达到最坏情况的区间很少；换句话说，需要频繁取数的区间是很少的。（如果一个区间取出了很多数，那么相应的，它之后的重叠区间需要取数的区间个数就会少一些。） 于是，第二步用朴素算法即可。虽然没能估计确切的复杂度，但提交后跑起来很快，94ms就过了。 第二种做法，转化成差分约束问题。 如果用d[i]表示做法一中，BIT的前缀和，那么条件(区间[a,b]中有c个数被取出来)可以表示成不等式d[b]-d[a-1]&gt;=c 有了这个不等关系，就可以很方便的转成差分约束问题了，另外还要加上初始约束：d[i]&lt;=d[i+1]&lt;=d[i]+1 很好理解。 然后求解最短路，即可得到答案。 这道题我们求的是d[Max] - d[Min]的最小值，但是最短路求出来后对应的是一个最大值。 于是我们可以加个负号，求出d[Min] - d[Max]的最大值x，那么-x就是答案。如果一开始将d[Max]赋值为0，那么最后答案就是-d[Min]. 采用经队列优化的Bellmen Ford算法，最坏情况下复杂度仍然为O(VE).但考虑到这题中的图对应了一个规则良好的差分约束系统，很难出现一个极端不均匀的图。所以这种做法耗时仅200ms。 P.S. POJ没有开O2优化，所以用vector表示邻接表，再一次跪了…… source codesolution 1 (贪心+BIT)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int maxn = 50050;int bit[maxn];int lowbit(int i) &#123; return i &amp; -i;&#125;int sum(int i) &#123; int s = 0; for (; i; i -= lowbit(i)) s+= bit[i]; return s;&#125;void add(int i, int x) &#123; for (; i &lt; maxn; i += lowbit(i)) bit[i] += x;&#125;struct node &#123; int l, r, c; bool operator &lt; (const node &amp;b)const &#123; return r &lt; b.r; &#125; &#125;a[maxn];bool used[maxn];int main() &#123; int n = read(); for (int i = 0; i &lt; n; i++) a[i].l = read() + 1, a[i].r = read() + 1, a[i].c = read(); sort(a, a + n); for (int i = 0; i &lt; n; i++) &#123; int need = a[i].c - (sum(a[i].r) - sum(a[i].l - 1)); for (int x = a[i].r; x &gt;= a[i].l &amp;&amp; need &gt; 0; x--) &#123; if (!used[x]) &#123; used[x] = true; add(x, 1); need--; &#125; &#125; &#125; printf(\"%d\\n\", sum(maxn - 1));&#125; solution 2 (差分约束)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int maxn = 50050, INF = 12345634;struct edge&#123; int to, cost, next; edge(int to = 0, int cost = 0, int next = 0):to(to), cost(cost), next(next)&#123;&#125;&#125;a[4 * maxn];int head[maxn], ei = 0;void add_edge(int u, int v, int c) &#123; a[ei] = edge(v, c, head[u]); head[u] = ei++;&#125;bool used[maxn];int d[maxn];void Mini(int &amp;a, int b) &#123; if (b &lt; a) a = b;&#125;void Maxi(int &amp;a, int b) &#123; if (b &gt; a) a = b;&#125;int main() &#123; memset(head, -1, sizeof(head)); int n_ = read(); int L = INF, R = -INF; // [L, R] for (int i = 0; i &lt; n_; i++) &#123; int a = read() + 1, b = read() + 1, c = read(); add_edge(b, a - 1, -c); Mini(L, a - 1); Maxi(R, b); &#125; for (int i = L; i &lt; R; i++) add_edge(i, i + 1, 1), add_edge(i + 1, i, 0); fill(d, d + R + 10, INF); d[R] = 0; queue&lt;int&gt; que; que.push(R); used[R] = true; while (!que.empty())&#123; int v = que.front(); que.pop(); used[v] = false; for (int i = head[v]; i != -1; i = a[i].next) &#123; int to = a[i].to, cost = a[i].cost; if (d[v] + cost &lt; d[to]) &#123; d[to] = d[v] + cost; if (!used[to]) que.push(to), used[to] = true; &#125; &#125; &#125; printf(\"%d\\n\", -d[L]);&#125;","tags":[{"name":"greedy","slug":"greedy","permalink":"http://dafenghh.github.io/tags/greedy/"},{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"graphs","slug":"graphs","permalink":"http://dafenghh.github.io/tags/graphs/"},{"name":"差分约束","slug":"差分约束","permalink":"http://dafenghh.github.io/tags/差分约束/"}]},{"title":"POJ 3368 [Frequent Values] 题解","date":"2018-01-11T01:54:21.000Z","path":"post/c9635eac.html","text":"题目大意给定一个长度为N的单调不下降的数组，M次询问，每次询问原数组区间[i, j]中，出现频数最多的数的频数。 题目分析先使用离散化，然后用lower_bound很方便的求出每一个值在原数组中的始点和终点。（终点可以用下一个值的始点表示） 然后构造一棵值分布的线段树，也就是说这棵线段树的每一个结点维护的是它所对应区间[l, r）中的值的最大的出现频数。 询问区间[i, j]， 先求出a[i], a[j]在[i,j]中的出现频数（用第一步求出的a[i]、a[j]的始点、终点位置很容易得到结果）。 然后往线段树中查询[a[i] + 1, a[j])即可。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;using namespace std;int N, n, Q;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int maxn = 100010;int a[maxn], b[maxn], lt[maxn], tr[maxn * 2];//leftvoid build(int v = 1, int l = 0, int r = n) &#123; // [l, r) if (l + 1 == r) &#123; tr[v] = lt[r] - lt[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1, chl = v * 2, chr = chl + 1; build(chl, l, mid); build(chr, mid, r); tr[v] = max(tr[chl], tr[chr]); &#125;&#125;int query(int L, int R, int v = 1, int l = 0, int r = n) &#123;// query [L, R) if (l &gt;= r || R &lt;= l || r &lt;= L) return -12344; if (L &lt;= l &amp;&amp; r &lt;= R) return tr[v]; int mid = (l + r) &gt;&gt; 1, chl = v * 2, chr = chl + 1; return max(query(L, R, chl, l, mid), query(L, R, chr, mid, r));&#125;void update(int &amp;a, int b) &#123; if (b &gt; a) a = b;&#125;int main() &#123; for(;;) &#123; N = read(); if (!N) break; Q = read(); for (int i = 0; i &lt; N; i++) a[i] = b[i] = read(); n = unique(b, b + N) - b; for (int i = 0; i &lt; N; i++) a[i] = lower_bound(b, b + n, a[i]) - b; for (int i = 0; i &lt; n; i++) lt[i] = lower_bound(a, a + N, i) - a; lt[n] = N; build(); while (Q--) &#123; int l = read(), r = read(); //[l, r] l--; r--; int ans = -1244; if (a[l] == a[r]) ans = r - l + 1; else &#123; update(ans, lt[a[l] + 1] - l); update(ans, r - lt[a[r]] + 1); int L = a[l] + 1, R = a[r]; // [L, R) if (L &lt; R) update(ans, query(L, R)); &#125; printf(\"%d\\n\", ans); &#125; &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"}]},{"title":"POJ 2104 [K-th Number] 题解","date":"2018-01-11T01:51:08.000Z","path":"post/76b5095a.html","text":"题目大意给定一个长度为n的数组，m次查询。每次查询给出三个数（i, j, k），表示要求原数组的区间[i, j]升序排列中的第k个数。 题目分析求区间第k小的经典题目！来源于《挑战程序设计竞赛》P185例题。然后发现，这道题在4个月之前，我学习主席树的时候就做过一次。 书上提供了平方分割和归并树的两种做法，下面我也将重现下这两种解法以及主席树的解法，并在最后对这三种优雅的解法作下对比。 solution 1 (分块)假如题目提供了一个函数cnt(i, j, x)，返回原数组区间[i, j]中小于x的数的个数。那么我们要求的区间[i,j]第k小的数，也就是要求满足cnt(i, j, x) &lt; k的最大的x。 于是，对x进行二分搜索，即可得到答案。 那么，我们怎么样才能自己写出一个类似于cnt(i, j, x)的函数呢？ 假如数组区间[i, j]是有序的，那么我们很容易用lower_bound写出这个函数。 虽然原数组不是有序的，但这么想能够给我们带来灵感。 我们不妨把原数组分成若干块区间，然后对每一块区间进行排序。这就是分块算法。这样，数组在每一块区间内都是有序的。 于是对于要查询的区间[i, j]所包含的那些完整的区间块，我们采用lower_bound算出cnt值。 而区间[i, j]两端有一些元素是不在一个完整区间块的，对这些元素逐一检查即可。（反正这部分元素的个数不超过两倍块的长度，所以数量较少，逐一检查OK） solution 2 (归并树)除了使用分块算法算出函数cnt(i, j, x)的值外，我们还可以采用归并树的做法。 这里的归并树是一种特别的线段树，它完整记录下了归并排序的每一步结果。 也就是，归并树的每一个结点，维护的是一个vector，这个vector就保存着结点对应区间排序后的结果。 于是，建树的过程也就是归并排序的过程，只不过每一步merge的时候，要把中间的结果保存在线段树的结点的vector里。 所以我们计算cnt(i, j, x)的值的时候，用线段树的思想求解即可。 即，若查询区间与当前结点对应区间无交集，返回0；查询区间完整包含当前结点对应区间在内，则对当前结点的vector采用lower_bound返回结果；否则对线段树左右儿子递归查询，求和即可。 solution 3 (主席树)前面两种做法都是采用使数组部分有序后统计cnt值的思想。Solution1 中的部分有序指块数组的部分有序，Solution2中部分有序指线段树维护区间的部分有序。 而主席树的做法采用完全不一样的思路。 主席树也是一种特殊的线段树。它不是像Solution2或者往常RMQ问题一样，维护原数组的区间；而是像维护值域的区间。 就是说，假如这个特殊的线段树的一个结点，维护的区间是[l, r), 记录值为dat，那么dat的意义是原数组中有多少个值位于[l, r)的范围内。 现在考虑，假设我们已经对要查询的区间[i, j]构造了这样一棵线段树，要查询第k小的值，怎么找？ 其实很简单，从根结点找起，其实根结点对应的区间就是整个值域。考察左儿子的dat值，如果它大于等于k，也就是说有大于等于k个数位于左边的值域，于是我们就对左儿子进行递归查找；否则查找右儿子。直到查找的区间长度为1，那么这个就是答案。 那么，假如我们对所有O(n^2)个区间都建这样一棵关于值分布的线段树，我们就能对任意区间，查询到第k小的答案了。 显然，O(n^2)棵线段树是不现实的，根本没有这么多空间。 用一下前缀和的思想，考虑原数组区间[i, j]对应的线段树，其实它可以由[1, j]和[1, i - 1]两棵线段树的值作差而来。（这里的“作差”就是对线段树每一个结点的dat值求一次差） 所以我们实际上，只需要n棵线段树即可，n指值域长度。 但是， O(n)棵线段树仍然不现实，没有这么多空间。 主席树的巧妙之处就在这里。 考察第i棵线段树和第i+1棵线段树的区别，也就是原数组区间[1, i]和[1, i + 1]分别对应的线段树。我们发现，后一棵线段树，比前一棵线段树，仅仅多更新了原数组中的一个数，即a[i+1]. 这样一来，两棵线段树仅仅只有从根到a[i+1]对应的叶这一条链是不同了（增加了1），其他结点完全相同。于是我们，只给这更新的一条链创建新结点可以，其他结点沿用旧的线段树的结点即可。 那么，更新的线段树高度为O(log n)，所以会有O(log n)个结点更新，也就是，这棵线段树实际只占用O(log n)的内存空间，但在逻辑上，它依然是棵完整的线段树。 另外，对于第零棵线段树，即原数组区间[1, 0]对应的线段树，所有结点dat值都为0，所以这整棵线段树用一个零结点来存就可以。 这样一来，我们就能够实现，只用了O(nlogn)的内存空间，存放下了n + 1棵线段树（包括第零棵）的信息，因为很多结点都被多棵线段树共享了嘛。 P.S.其实这种做法与第二种归并树的做法，有异曲同工之妙。归并树是把归并排序的中间结果全部记录下来。而主席树，实际上也是，把更新时的中间结果全部记录下来。对这样一棵表示值分布的线段树，我们依次从左往右拿原数组的值去更新线段树，每一次更新会修改O(log n)个结点，而主席树没有直接修改原树上的O(log n)个结点，而是新建了O(log n)个结点。这样，线段树在动态更新的过程中，每一个历史版本都被完整记录。 source codesolution 1 (分块)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include&lt;cctype&gt;using namespace std;const int maxn = 100002;const int B = 1000;int bucket[maxn / B][B];int a[maxn],nums[maxn];inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;int main() &#123; int n = read(), m = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); bucket[i/B][i%B] = a[i]; nums[i] = a[i]; &#125; sort(nums, nums + n); for (int i = 0; i &lt; n / B; i++) sort(bucket[i], bucket[i] + B); while (m--) &#123; int l = read(), r = read(), k = read(); int ul = 0, ur = n; while (ul + 1 &lt; ur) &#123; int mid = (ul + ur) &gt;&gt; 1; int cnt = 0, tl = l - 1, tr = r; // the number of items less than nums[mid] while (tl &lt; tr &amp;&amp; tl % B) cnt += (a[tl++] &lt; nums[mid]); while (tl &lt; tr &amp;&amp; tr % B) cnt += (a[--tr] &lt; nums[mid]); while (tl &lt; tr) &#123; int bi = tl / B; cnt += lower_bound(bucket[bi], bucket[bi] + B, nums[mid]) - bucket[bi]; tl += B; &#125; if (cnt &gt;= k) ur = mid; else ul = mid; &#125; printf(\"%d\\n\", nums[ul]); &#125; &#125; solution 2 (归并树)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int maxn = 100010;int a[maxn],n,m,nums[maxn];vector&lt;int&gt; vec[maxn * 20];void build(int v = 1, int l = 0, int r = n) &#123; if (l &gt;= r) return; if (l + 1 == r) &#123; vec[v].push_back(a[l]); &#125; else &#123; int mid = (l + r) &gt;&gt; 1, chl = v * 2, chr = v * 2 + 1; build(chl, l, mid); build(chr, mid, r); vec[v].resize(vec[chl].size() + vec[chr].size()); merge(vec[chl].begin(), vec[chl].end(), vec[chr].begin(), vec[chr].end(), vec[v].begin()); &#125;&#125;int query(int L, int R, int x, int v = 1, int l = 0, int r = n) &#123; if (l &gt;= r || r &lt;= L || R &lt;= l) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; int res = lower_bound(vec[v].begin(), vec[v].end(), x) - vec[v].begin(); return res; &#125; int mid = (l + r) &gt;&gt; 1, chl = v * 2, chr = v * 2 + 1; int res= query(L, R, x, chl, l, mid) + query(L, R, x, chr, mid, r); return res;&#125;int main() &#123; n = read(),m = read(); for (int i = 0; i &lt; n; i++) &#123; nums[i] = a[i] = read(); &#125; sort(nums, nums + n); build(); while (m--) &#123; int l = read(), r = read(), k = read(); l--; int ul = 0, ur = n; while (ul + 1 &lt; ur) &#123; int mid = (ul + ur) &gt;&gt; 1; if (query(l, r, nums[mid]) &gt;= k) ur = mid; else ul = mid; &#125; printf(\"%d\\n\", nums[ul]); &#125;&#125; solution 3 (主席树)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;struct node&#123; int l, r, dat; node(int l = 0, int r = 0, int dat = 0):l(l),r(r),dat(dat)&#123;&#125;&#125;T[maxn * 20];int rt[maxn], a[maxn], b[maxn], sz = 0;void update(int &amp;o, int x, int last, int l, int r) &#123; // [l, r) o = ++sz; T[o] = T[last]; T[o].dat++; if (l + 1 &gt;= r) return; int mid = (l + r) &gt;&gt; 1; if (x &lt; mid) update(T[o].l, x, T[last].l, l, mid); else update(T[o].r, x, T[last].r, mid, r);&#125;int query(int t1, int t2, int l, int r, int k) &#123; // [l, r) if (l + 1 &gt;= r) return l; int cnt = T[T[t2].l].dat - T[T[t1].l].dat, mid = (l + r) &gt;&gt; 1; if (cnt &gt;= k) return query(T[t1].l, T[t2].l, l, mid, k); return query(T[t1].r, T[t2].r, mid, r, k - cnt);&#125;int main() &#123; fill(T, T + maxn * 20, node()); fill(rt, rt + maxn, 0); int N = read(), Q = read(); for (int i = 0; i &lt; N; i++) b[i] = a[i] = read(); sort(b, b + N); int n = unique(b, b + N) - b; for (int i = 0; i &lt; N; i++) &#123; a[i] = lower_bound(b, b + n, a[i]) - b; update(rt[i + 1], a[i], rt[i], 0, n); &#125; while (Q--) &#123; int l = read(), r = read(), k = read(); printf(\"%d\\n\", b[query(rt[l - 1], rt[r], 0, n, k)]); &#125;&#125; 总结 Solution Time(ms) Memory(MB) Code Length 分块 11516 1.5 1337 归并树 6344 37.1 1662 主席树 1735 25 1469 最后送上三种解法的耗时，内存占用和代码长度的直观对比。 分块的实现最简单，代码最短，空间开销也最小，但非常慢，濒临超时。实际上，如果不加读入优化的话，那么分块就超时了。可见，非常凶险。 完美复现归并排序的归并树显然内存消耗是最高的，因为采用的是和分块一样的思路，也要有两层的二分查找，所以即使使用了线段树，但总耗时也只是节省了一半不到。 最后一种，主席树的做法，从原理上来讲，最复杂，但同时也最优美。从表中可以看出，时间比归并树快很多，空间开销和代码长度都最小，所以毫无疑问是本题的最佳解法。 P.S. 有同学可以提供比主席树更好的做法吗？感激不禁。（发现自己能在不同解法的对比中学到更多）","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"sqrt decomposition","slug":"sqrt-decomposition","permalink":"http://dafenghh.github.io/tags/sqrt-decomposition/"},{"name":"主席树","slug":"主席树","permalink":"http://dafenghh.github.io/tags/主席树/"}]},{"title":"POJ 2886 [Who gets the Most Candies] 题解","date":"2018-01-10T06:46:27.000Z","path":"post/63c20c7e.html","text":"题目大意N个孩子围一圈玩游戏， 按顺时针从1到N编号，每个孩子手上有张牌，牌上有个非零数字。给定数字K，一开始第K个孩子走出圈。每个出圈的孩子的牌上的数字将决定下一个出圈孩子是谁。若此时出圈孩子的牌的数字为x，正则往顺时针方向数到第x个孩子，负则逆时针方向数到第|x|个孩子，即为下一个要走出圈的孩子。 第i个出圈的孩子将获得F[i]个糖果。F[i]定义为正整数i的因数个数。输出获得糖果最多的孩子的名字和糖果数。若有多个答案，则输取出圈最早的孩子作为答案。 题目分析采用取模的方法很容易算出当前需要出圈的是序列中第几个孩子。但这题难在，如果动态、快速地将一个序列中的一项删除呢？ 不妨不存储实际的序列，而只是用一个BIT（树状数组）来表示每个孩子是否在场。 初始时，1-N的每个点的值都为1，表示每一个孩子都在场。若有一个孩子离场，则将它赋值为0即可。 很容易想到，若编号为i的孩子在场，那么前缀和sum(i)就表示他现在在队伍中的实际位置。 所以采用二分法，就可以快速确定队伍中排在第k位的孩子是谁。 时间复杂度为$O(n\\log^2 n)$ n最大为500000，担心超时。但BIT采用lowbit来算的话，时间节省一半，即带上一个1/2的系数。 那么$0.5\\times 500000 \\times log_2^2 500000 = 8.96 \\times 10^7 $ 所以时间复杂度在可接受的范围内。 另外，算F[i]时直接用素数筛的方法做一遍预处理即可， O(n log n)的复杂度。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 500010;int F[maxn];int n, k;void initF()&#123; for (int i = 1; i &lt; maxn; i++) &#123; for (int j = 1; i * j &lt; maxn; j++) F[i * j]++; &#125;&#125;int bit[maxn];int lowbit(int x) &#123; return x &amp; -x;&#125;int sum(int i) &#123; int s = 0; for (; i; i -= lowbit(i)) s += bit[i]; return s;&#125;void add(int i, int x) &#123; for (; i &lt;= n; i += lowbit(i)) bit[i] += x;&#125;struct kid &#123; int p, id; kid(int p = 0, int id = 0):p(p), id(id) &#123;&#125; bool operator &lt; (const kid &amp;b)const &#123; if (F[p] != F[b.p]) return F[p] &lt; F[b.p]; return p &gt; b.p; &#125;&#125;;priority_queue&lt;kid&gt; que;int cards[maxn];char names[maxn][12];typedef long long ll;ll tr(ll x, ll n) &#123; x += n * 100000000LL; return x % n;&#125;int getP(int k) &#123; int l = 0, r = n; while (l + 1 &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (sum(mid) &lt; k) l = mid; else r = mid; &#125; return r;&#125;int solve(int k, int step, int n) &#123; int ni = getP(k); add(ni, -1); que.push(kid(step, ni)); if (n == 0) return 0; k += -1 + cards[ni]; if (cards[ni] &gt; 0) k--; if (k &lt; 0) k = (int)tr(k, n); k %= n; k++; return k;&#125;void Clear(priority_queue&lt;kid&gt; &amp;que) &#123; priority_queue&lt;kid&gt; q1; swap(q1, que);&#125;int main() &#123; initF(); while (scanf(\"%d%d\", &amp;n, &amp;k) != EOF) &#123; for (int i = 1; i &lt;= n; i++) scanf(\"%s%d\", names[i], cards + i); Clear(que); memset(bit, 0, sizeof(bit)); for (int i = 1; i &lt;= n; i++) add(i, 1); for (int i = 1; i &lt;= n; i++) &#123; k = solve(k, i, n - i); &#125; kid ans = que.top(); printf(\"%s %d\\n\", names[ans.id], F[ans.p]); &#125;&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"}]},{"title":"POJ 2155 [Matrix] 题解","date":"2018-01-09T14:15:40.000Z","path":"post/5eb8db9.html","text":"题目大意一个N*N的布尔矩阵，初始值全为0，T次询问，两种操作： 查询某个点的值 将一个矩形方块的布尔值全部翻转。 题目分析二维BIT的简单题目。一维BIT很容易扩展成二维，直接加多一层循环即可，单次操作复杂度由$O(\\log n)$变成$O(\\log^2 n)$ 区间更新转化为4个端点的更新即可。 由于每个点只有两种状态，所以用异或处理非常方便。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1020;int bit[maxn][maxn], n, q;void init() &#123; memset(bit, 0, sizeof(bit));&#125;int lowbit(int i) &#123; return i &amp; -i;&#125;int sum(int x, int y) &#123; // [1..x, 1..y] int res = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) for (int j = y; j &gt; 0; j -= lowbit(j)) res ^= bit[i][j]; return res;&#125;void add(int x, int y) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= n; j += lowbit(j)) bit[i][j] ^= 1;&#125;void update(int x1, int y1, int x2, int y2) &#123; add(x1, y1); add(x1, y2 + 1); add(x2 + 1, y1); add(x2 + 1, y2 + 1);&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;q); init(); while (q--) &#123; char s[10]; scanf(\"%s\", s); if (s[0] == 'Q') &#123; int x,y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", sum(x, y)); &#125; else &#123; int x1, y1, x2, y2; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); update(x1, y1, x2, y2); &#125; &#125; if (T) printf(\"\\n\"); &#125;&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"}]},{"title":"POJ 3468 [A Simple Problem with Integers] 题解","date":"2018-01-09T09:30:31.000Z","path":"post/8b465320.html","text":"题目大意给出长度为N的数组，Q次询问，每次询问有两种操作： 查询某个区间的和。 将某个区间的数全部加上x。 题目分析要同时支持区间更新和区间查询（求和）两种操作，考虑树状数组。 但我们知道，树状数组只支持区间查询和点更新，或者区间更新和点查询。怎么样才能做到同时更新区间以及对区间求和呢？ 我们先来考察区间更新后，前缀和的增量。记前缀和为S(i)，更新区间[l,r]后前缀和为S’(i). $$\\begin{eqnarray}S’(i)= \\begin{cases} S(i), &amp;ir\\end{cases} \\end{eqnarray} $$ 留意到ir时，增量为常数，像普通BIT那样进行一次点更新即可。 难就难在， $l\\leqslant i\\leqslant r$时，增量是一个关于i的一次函数。 如前面所说，普通BIT进行一次点更新只能导致前缀和增加一个常数。既然如此，我们把上面这个一次函数的增量拆成两项，用两个BIT维护： $$\\Delta S(i)=xi + x(1-l) $$一次项系数为x，常数项为x(1-l)，分别对应BIT1和BIT0的增量值。 这样，记BIT0前缀和为s0，BIT1前缀和为s1，则总的前缀和就是s0 + s1 * x 用前缀和来表示原数组的每一个值，然后区间求和就可转化为左右端点的前缀和差值，即点查询+区间更新的模式。 然后，更新的时候，分别对BIT0和BIT1进行区间更新即可（实质上是更新两个端点）。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;typedef long long ll;const int maxn = 100010;ll bit[2][maxn];int n,q;int lowbit(int x) &#123; return x &amp; -x;&#125;ll sum(int x) &#123; ll s0 = 0, s1 = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) s0 += bit[0][i], s1 += bit[1][i]; return s0 + s1 * x;&#125;void add(int ti, int x, ll val) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) bit[ti][i] += val;&#125;void update(int l, int r, ll val) &#123; // [l, r] add(0, l, val * (1 - l)); add(1, l, val); add(0, r + 1, val * r); add(1, r + 1, -val);&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); update(i, i, x); &#125; while (q--) &#123; char s[10]; int l, r, x; scanf(\"%s%d%d\", s, &amp;l, &amp;r); if(s[0] == 'Q')&#123; printf(\"%lld\\n\", sum(r) - sum(l - 1)); &#125; else &#123; scanf(\"%d\", &amp;x); update(l, r, x); &#125; &#125;&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"}]},{"title":"ZOJ 4003 [Distance] 题解","date":"2018-01-09T05:05:12.000Z","path":"post/6c754de8.html","text":"题目大意定义两个维度为n的向量 $(a_1,a_2,a_3\\dots a_n)$ 和 $(b_1,b_2,b_3\\dots bn)$ 间的距离为 $\\sum {i=1} ^n \\left | a_i - b_i \\right |^p$ 现在给出向量$X = (x_1, x_2, x_3 \\dots x_n)$ 和 $Y = (y_1, y_2, y_3 \\dots y_n)$ 定义子向量（subvector）为原向量的项中连续的一段。从X中取出一个子向量x, 从Y中取出一个子向量y，使得x和y长度相同，x和y的距离小于给定值V。求这样的子向量对(x, y)的个数。 题目分析作一个n*n的矩阵diff[][]，记录X中的每一项到Y中的每一项的距离， 即 diff[i][j] = |X[i] - Y[j]| ^ p 取出这个矩阵的每一条斜线的值，用尺取法统计结果即可。 P.S. 写这题时犯了很多智障错误。如%d写成%p，return res写成return x。 诸如此类。 如何避免这类typo的发生呢？ 这是一个问题。 source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll Pow(ll x, ll y) &#123; ll res = 1; while (y--) res *= x; return res;&#125;int count(ll a[], int n, ll V) &#123; ll sum = 0; int r = 0, ans = 0; for (int l = 0; l &lt; n; l++) &#123; r = max(r, l); while (r &lt; n &amp;&amp; sum + a[r] &lt;= V) &#123; sum += a[r]; r++; &#125; ans += r - l; if (r &gt; l) sum -= a[l]; &#125; return ans;&#125;const int maxn = 1003;int x[maxn], y[maxn];ll diff[maxn][maxn],diag[maxn];int abs_(int x) &#123; return x &gt; 0 ? x : -x;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, p; ll V; scanf(\"%d%lld%d\", &amp;n, &amp;V, &amp;p); for (int i = 0; i &lt; n; i++) scanf(\"%d\", x + i); for (int i = 0; i &lt; n; i++) scanf(\"%d\", y + i); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) diff[i][j] = Pow(abs_(x[i] - y[j]), p); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; int di = 0; for (int xi = 0, yi = i; xi &lt; n &amp;&amp; yi &lt; n; xi++, yi++) diag[di++] = diff[xi][yi]; ans += count(diag, di, V); &#125; for (int i = 1; i &lt; n; i++) &#123; int di = 0; for (int xi = i, yi = 0; xi &lt; n &amp;&amp; yi &lt; n; xi++, yi++) diag[di++] = diff[xi][yi]; ans += count(diag, di, V); &#125; printf(\"%d\\n\",ans); &#125;&#125;","tags":[{"name":"尺取法","slug":"尺取法","permalink":"http://dafenghh.github.io/tags/尺取法/"}]},{"title":"POJ 3109 [Inner Vertices] 题解","date":"2018-01-05T08:17:54.000Z","path":"post/c38b5f65.html","text":"题目大意一个无限大的棋盘，给出N个点的坐标，初始时这些点上都放置着黑棋。其他所有点放置着白棋。若一个白棋的上下左右方向上都有黑棋，那么它会被替换成黑棋。求最终黑棋的数量。 题目分析与cf 911G如出一辙的扫描线算法。 将所有点按y坐标排序后（y相同时按x排序），我们可以依次统计，相邻的两个y坐标相同的点之间的白点对答案的贡献。 假设这两个点为(x1, y0) (x2, y0) 那么我们要算的就是${(x, y) | x \\in [x1 + 1, x2 - 1], y = y0}$的范围内有多少个白棋变成了黑棋。 对于此范围中的一个点(xx, yy)，这一个点变成黑棋的充要条件是，(xx, yy)的上方和下方还有别的黑棋。 假设在原黑棋的点集合中，当x = xx时，y的最大、最小值分别为Max, Min。那么上面这个充要条件就可以表示为Min &lt; y &lt; Max. 我们很容易想到，当访问到y = yy的最低点也即(xx, Min)时，给x加上标记（表示此条线x == xx上的点将可能变黑）, 当访问到最高点即(xx, Max)时，给x消除标记（表示此条线x == xx上的点将不再会变黑）。 用BIT快速统计出区间[x1 + 1, x2 - 1]上会变黑的点的数量, 本题完成。 P.S. 这题做得也挺尴尬的，一开始写的扫描线算法还要统计出对每个x、y对应的y、x的极值，然后用很累赘的方法打标记，用了很多次vector，导致TLE。后来把vector全部去掉，全部换成数组才过。 感谢此篇博文by lolicon480 提供的思路！ source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;const ll maxn = 200010;ll cnt = 200020;ll bit[maxn];void Maxi(int &amp;a, int b) &#123; if (b &gt; a) a = b;&#125;ll lowbit(ll x) &#123; return x &amp; -x;&#125;ll sum(ll i) &#123; ll res = 0; for (; i &gt; 0; i -= lowbit(i)) res += bit[i]; return res;&#125;void add(ll i, ll x) &#123; for (; i &lt;= cnt; i += lowbit(i)) bit[i] += x;&#125;struct P &#123; int x, y; P(int x = 0, int y = 0):x(x), y(y) &#123;&#125;&#125;a[maxn];bool cmpx(const P&amp;a, const P&amp;b)&#123; if (a.x != b.x) return a.x &lt; b.x; return a.y &lt; b.y;&#125;bool cmpy(const P&amp;a, const P&amp;b)&#123; if (a.y != b.y) return a.y &lt; b.y; return a.x &lt; b.x;&#125;int mx[maxn];bool sc[maxn]; // scopeint main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); sort(a, a + n, cmpx); int val = 1; for (int i = 0; i &lt; n; i++) &#123; int temp = a[i].x; a[i].x = val; if (temp != a[i + 1].x) val++; &#125; sort(a, a + n, cmpy); val = 1; for (int i = 0; i &lt; n; i++) &#123; int temp = a[i].y; a[i].y = val; if (temp != a[i + 1].y) val++; &#125; for (int i = 0; i &lt; n; i++) Maxi(mx[a[i].x], a[i].y); ll ans = 0; for (int i = 0; i &lt; n - 1; i++) &#123; int x = a[i].x, y = a[i].y, nx = a[i + 1].x, ny = a[i + 1].y; if (!sc[x] &amp;&amp; y &lt; mx[x]) &#123; sc[x] = true; add(x, 1); &#125; if (y == ny &amp;&amp; nx &gt; x + 1) &#123; ans += sum(nx - 1) - sum(x); &#125; if (sc[x] &amp;&amp; y == mx[x]) &#123; sc[x] = false; add(x, -1); &#125; &#125; ans += n; printf(\"%lld\\n\", ans);&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"scanline","slug":"scanline","permalink":"http://dafenghh.github.io/tags/scanline/"}]},{"title":"POJ 1990 [MooFest] 题解","date":"2017-12-30T16:23:57.000Z","path":"post/a0a6f15.html","text":"题目大意N头牛排成一排，现在给出它们的坐标x[i]和听觉阈值v[i]. 两头牛i和j之间谈话的音量为max(v[i], v[j]) * dist(i, j) dist表示两者距离。求所有N*(N-1)对牛谈话音量的总和。 题目分析按v[i]降序排序。然后用BIT求出每一头牛和后面的牛的距离的和即可。（我用了两个BIT，一个维护累计和，一个维护个数） source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 20200;typedef long long ll;int n = 20000;int lowbit(int x) &#123; return x &amp; -x;&#125;ll bit[maxn];ll sum(int i) &#123; ll res = 0; for (; i; i -= lowbit(i)) &#123; res += bit[i]; &#125; return res;&#125;void add(int i, ll x) &#123; for (; i &lt;= n; i += lowbit(i)) &#123; bit[i] += x; &#125;&#125;ll bit2[maxn];ll sum2(int i) &#123; ll res = 0; for (; i; i -= lowbit(i)) &#123; res += bit2[i]; &#125; return res;&#125;void add2(int i, ll x) &#123; for (; i &lt;= n; i += lowbit(i)) &#123; bit2[i] += x; &#125;&#125;struct cow &#123; int v, x; bool operator &lt; (const cow &amp; b) const &#123; return v &gt; b.v; &#125;&#125;a[maxn];int main() &#123; int N; scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) scanf(\"%d%d\", &amp;a[i].v, &amp;a[i].x), add(a[i].x, a[i].x), add2(a[i].x, 1); sort(a, a + N); ll ans = 0; for (int i = 0; i &lt; N - 1; i++) &#123; add(a[i].x, -a[i].x); add2(a[i].x, -1); ll dist_tot = sum2(a[i].x) * a[i].x - sum(a[i].x) + sum(n) - sum(a[i].x) - (sum2(n) - sum2(a[i].x)) * a[i].x; ans += dist_tot * a[i].v; &#125; printf(\"%lld\\n\", ans);&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"}]},{"title":"codeforces 911G [Mass Change Queries] # educational round 35 题解","date":"2017-12-30T13:20:40.000Z","path":"post/360e2773.html","text":"题目大意给定一个数组a，长度为n，q次操作，每次操作给定四个整数，l,r,x,y表示将[l, r]区间中的值为x元素全部变成y，输出最终数组。 数据范围：n, q &lt;= 200000, a[i], x, y &lt;= 100 题目分析educational round的最后一题，本来以为非常难，看了pannibal 的代码后，非常惊奇。这道题竟能如此简洁优美地解决。于是关掉网页，用自己的代码习惯重打一遍（当然大部分雷同哈哈，毕竟这个解法真的太简洁了）。 总结一下思路： 本题的难点在于每次操作，需要更新[l, r]的整段区间。如果直接更新，复杂度将是O(nq) ，不可接受。 我们采用类似于用前缀和快速查询区间和的思想，讲区间转化为两个端点处理，即在区间开始处l打上一个标记，表示从这里开始，x将被视作y ，再在区间结束后的r+1处打上标记，表示还原x的状态（将x重新视为x）。 或者说，这个修改操作包含两个修改，(1) [l, +inf)区间的x变成y; (2) [r+1, +inf)区间的x变回x. 另外，修改的顺序也是很重要的。我们将所有修改按照点的标记位置存在vector里。见main函数代码: 12vec[l].push_back(Change(t, x, y));vec[r + 1].push_back(Change(t, x, x)); 其中t表示修改的顺序。这样一来，我们相当于将所有修改按点的位置重新排序。这么做有什么好处吗？其实，这就是这道题的关键转化步骤。 作为一个经验尚浅的ACM选手，我对这题的直觉思路是依次考虑每次修改操作，寻找一种快速的更新区间方法。但注意到这道题只需要一个最终的结果，对中间结果并不关心。所以我们可以采用离线做法，不必完全跟从修改的次序来求解。 那么我们采用怎样的求解次序呢？ 按数组下标依次求解最终结果。这也是很自然的思路，假如我们要求a[x]的最终结果，那么所有在x之后的点的更新对a[x]的值毫无影响。所以我们在输入完成后，依次拿出vec[i]的修改操作，来修改[i, +inf)这个区间. 这样在i后移的同时，我们就能依次得到a[i]的最终结果。 下面讨论如果实现每次修改操作。 比如现在我们要把x的值变成y，是不是要找出数组中所有的x，然后依次赋值成y呢？显然时间不允许这么做。 我们只需要存一份转移表（transition table）即可。一开始所有数字无变化，对所有的i， 有T[i] = i。 当我们将x修改成y时，修改T[x] = y; 如果这样一份转移表被构造出来，那么我们要求a[i]的最终结果就很简单了，那就是T[a[i]] 但转移表既随时间（修改次序）变化，也随区间变化，即受两个维度影响，t维度（修改次序）和i维度（数组下标）。留意到，刚刚第2点说到，我们沿着i维度来提交修改。那么不妨，我们固定t维度，或称，保留下t维度的所有状态，即对每一个修改的时刻构造一张转移表。这道题最多200000次查询，也就是200000张转移表。 比如我们在时刻t = 5和t = 6分别做了一次修改，得到两个转移表T_5, T_6, 很明显将T_5, T_6的转移表合并（合并的过程非常简单，相当于函数的组合）,就是这两次修改的最终效果。 我们将所有转移表合并后得到的就是最终结果需要的转移表。而在i维度（数组下标）更新的过程中，我们需要快速地修改某些转移表，并将修改结果合并起来，得到a[i]的最终值。 于是，线段树呼之欲出！线段树的每个叶子结点就代表一个时刻的转移表，它们的父结点就是合并后的转移表。对特定的x，所有修改合并操作都能在O(log n)时间内完成了。合并也只需要一条代码： seg[t][i] = seg[chr][seg[chl][i]] 解法非常简洁优美！ source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = (1 &lt;&lt; 18) - 1;struct Change &#123; int t, x, y; Change(int t, int x, int y):t(t),x(x),y(y)&#123;&#125;&#125;;vector&lt;Change&gt; vec[maxn];int a[maxn], seg[maxn * 2 + 20][101];void printAll(int n) &#123; for (int i = 1; i &lt;= n; i++) printf(\"%d%c\", seg[1][i], \" \\n\"[i == n]);&#125;void update(int t, int x, int y) &#123; seg[t += maxn][x] = y; for (t &gt;&gt;= 1; t; t &gt;&gt;= 1) &#123; int chl = t &lt;&lt; 1, chr = chl | 1; for (int i = 1; i &lt;= 100; i++) &#123; seg[t][i] = seg[chr][seg[chl][i]]; &#125; &#125;&#125;void init() &#123; for (int t = 1; t &lt; maxn * 2 + 20; t++) for (int i = 1; i &lt;= 100; i++) seg[t][i] = i;&#125;inline int get() &#123; int ans=0,flag=1; char c=getchar(); while(c&lt;'0' || c&gt;'9')&#123; if(c=='-') flag=-1; c=getchar(); &#125; while(c&gt;='0' &amp;&amp; c&lt;='9')&#123; ans=ans*10+(int)(c-'0'); c=getchar(); &#125; return ans*flag;&#125;int main() &#123; int n = get(), q; for (int i = 1; i &lt;= n; i++) a[i] = get(); q = get(); for (int t = 1; t &lt;= q; t++) &#123; int l = get(), r = get(), x = get(), y = get(); if (x != y) &#123; vec[l].push_back(Change(t, x, y)); vec[r + 1].push_back(Change(t, x, x)); &#125; &#125; init(); for (int i = 1; i &lt;= n; i++) &#123; for (auto cg: vec[i]) update(cg.t, cg.x, cg.y); printf(\"%d%c\", seg[1][a[i]], \" \\n\"[i == n]); &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"scanline","slug":"scanline","permalink":"http://dafenghh.github.io/tags/scanline/"}]},{"title":"codeforces 908F [New Year and Rainbow Roads] (good bye 2017) 题解","date":"2017-12-30T07:05:48.000Z","path":"post/8234636.html","text":"题目大意给定一维直线上的N个点，每个点有一个颜色标记（红、绿、蓝），现在要连边，一条边的代价为两点距离。现求最小总代价，使红、绿点连通，并且蓝、绿点连通。 题目分析考虑到，红、蓝点连线并无意义，所以可忽略；另外考虑假如出现了连续三个点，颜色分别为红绿红，那么红和红之间连线一定不必红-绿-红这样连线优。所以，以绿点为分割点，分成若干个区间单独考虑即可。 对于两个连续的绿点之间的区间，有两种连线方式：（1）连接两个绿点，再以从这两个绿点为端点，连出两条线，分别连接中间的红点和蓝点，接着分别去掉这两条线的最长一个区间；（2）直接从这两个绿点为端点，连出两条线，分别连接中间的红点和蓝点。 分别统计两种连线方式的代价，选最优即可。 代码写得很丑，要看漂亮代码请戳这：by aaaaajack source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;vector&lt;ll&gt; v0, v1, v2;ll ans;void add(vector&lt;ll&gt; &amp;v)&#123; if (v.empty()) return; ans += max(0LL, v0.front() - v.front()) + max(0LL, v.back() - v0.back());&#125;vector&lt;ll&gt;::iterator LB(vector&lt;ll&gt; &amp;v, ll x) &#123; return lower_bound(v.begin(), v.end(), x);&#125;ll calc(ll l, ll r) &#123; if (LB(v1, l) == LB(v1, r) &amp;&amp; LB(v2, l) == LB(v2, r)) return r - l; ll x = l, max_interval = 0; for (auto it = LB(v1, l); it != v1.end() &amp;&amp; (*it) &lt; r; it++) &#123; max_interval = max(max_interval, (*it) - x); x = *it; &#125; max_interval = max(max_interval, r - x); ll ans1 = 3 * (r - l) - max_interval; x = l; max_interval = 0; for (auto it = LB(v2, l); it != v2.end() &amp;&amp; (*it) &lt; r; it++) &#123; max_interval = max(max_interval, (*it) - x); x = *it; &#125; max_interval = max(max_interval, r - x); ans1 -= max_interval; return min(ans1, 2 * (r - l));&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); ll N; cin &gt;&gt; N; for (ll i = 0; i &lt; N; i++) &#123; ll x; string s; cin &gt;&gt; x &gt;&gt; s; if (s[0] == 'G') v0.push_back(x); else if (s[0] == 'B') v1.push_back(x); else v2.push_back(x); &#125; if (v0.size() &lt;= 1) &#123; if (!v1.empty()) ans += v1.back() - v1.front(); if (!v2.empty()) ans += v2.back() - v2.front(); &#125; else &#123; add(v1); add(v2); for (ll i = 0; i &lt; v0.size() - 1; i++) &#123; ans += calc(v0[i], v0[i + 1]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;","tags":[{"name":"greedy","slug":"greedy","permalink":"http://dafenghh.github.io/tags/greedy/"}]},{"title":"codeforces 343D [Water Tree] 题解","date":"2017-12-30T06:26:56.000Z","path":"post/a28d78f2.html","text":"题目大意给定一棵树，可以进行以下三种操作： 选择一个结点v，使v对应的子树全部充满水。 选择一个结点v，除去v和v所有的祖先的水。 选择一个结点v，查询v是否有水。 题目分析看完《挑战程序设计竞赛》的线段树章节后，搜了下codeforces的线段树题目来做，然后就搜到这题。这题做了很长时间哎，而且犯了不少很囧的错误。 首先看错了题，以为第二种操作是除去子树的水，所以很轻巧的敲了个BIT，跑起来不对才发现自己弄错了题意…… 于是删掉代码重写。想到要更新所有祖先结点，岂不是要用树链剖分？参考了下cf的Tutorial，原来使用一个很巧妙的转化，就能变成普通的线段树问题。 我思考这题的时候，总是想着加水就是染成1，去水就是染成0，所以这两个操作分别对应子树的更新和路径的更新，这么做起来就很麻烦。Tutorial将思路倒转一下，便是去水只需要在v（最末端结点）上打个标记，加水是将子树上的所有标记去掉，查询某点是否有水是看这个点对应子树是否有标记，只要有一个标记，说明这点没水；没标记才表示有水。 而初始状态，我们将所有叶子结点打上标记，就可表示全没水的状态。 这样一来，确定dfs序之后，找出每个结点对应子树区间[L,R], 然后使用std::set即可实现这个算法，还很简单，都不需要线段树了。 cf上的前排代码求dfs时，将R[v] = cnt + 1写成R[v] = ++cnt 我一开始很疑惑，这样写有什么区别，因为++后，就相当于对每个子树在末端新建了个虚拟的占位位置。 其实没区别。只是前排代码这么写，那么这一句S.erase(S.lower_bound(L[v]), S.lower_bound(R[v])) 的后半部分S.lower_bound(R[v])既可以用lower_bound, 又可以用upper_bound, 我的代码就只能用lower_bound source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 500010;vector&lt;int&gt; G[maxn];int L[maxn], R[maxn], fa[maxn];int cnt,n ,q;set&lt;int&gt; S;void dfs(int v, int par = -1) &#123; L[v] = ++cnt; for (auto i:G[v]) &#123; if (i != par) &#123; fa[i] = v;dfs(i, v); &#125; &#125; R[v] = cnt + 1; if (R[v] == L[v] + 1) S.insert(L[v]);&#125;bool empty(int v) &#123; auto it = S.lower_bound(L[v]); return it != S.end() &amp;&amp; (*it) &lt; R[v];&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n - 1; i++) &#123; int x,y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); G[y].push_back(x); &#125; dfs(1); scanf(\"%d\", &amp;q); while (q--) &#123; int c, v; scanf(\"%d%d\", &amp;c, &amp;v); if (c == 3) puts((empty(v) ? \"0\" : \"1\")); else if (c == 1) &#123; if (fa[v] &amp;&amp; empty(fa[v])) S.insert(L[fa[v]]); S.erase(S.lower_bound(L[v]), S.lower_bound(R[v])); &#125; else S.insert(L[v]); &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"trees","slug":"trees","permalink":"http://dafenghh.github.io/tags/trees/"},{"name":"dfs and similar","slug":"dfs-and-similar","permalink":"http://dafenghh.github.io/tags/dfs-and-similar/"}]},{"title":"POJ 3264 [Balance Lineup] 题解","date":"2017-12-29T12:56:34.000Z","path":"post/de36ffa1.html","text":"题目大意长度为N的数组，Q次查询，查询区间[A, B]的最大值与最小值之差。 题目分析线段树模板题。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100050;const int INF = 1234567;int mx[2 * maxn], lx[2 * maxn];int n;void update(int x, int y, int v = 0, int l = 0, int r = n) &#123; // a[x] = y; // printf(\"v = %d, l = %d, r = %d\\n\", v, l, r); if (l &gt;= r || x &lt; l || x &gt;= r) return; int chl = v * 2 + 1, chr = v * 2 + 2, mid = (l + r) / 2; if (l + 1 == r) &#123; mx[v] = lx[v] = y; &#125; else &#123; update(x, y, chl, l, mid); update(x, y, chr, mid, r); mx[v] = max(mx[chl], mx[chr]); lx[v] = min(lx[chl], lx[chr]); &#125;&#125;int queryMax(int L, int R, int v = 0, int l = 0, int r = n) &#123; if (l &gt;= r || R &lt;= l || L &gt;= r) return -INF; if (L &lt;= l &amp;&amp; r &lt;= R) return mx[v]; int chl = v * 2 + 1, chr = v * 2 + 2, mid = (l + r) / 2; return max(queryMax(L, R, chl, l, mid), queryMax(L, R, chr, mid, r));&#125;int queryMin(int L, int R, int v = 0, int l = 0, int r = n) &#123; if (l &gt;= r || R &lt;= l || L &gt;= r) return INF; if (L &lt;= l &amp;&amp; r &lt;= R) return lx[v]; int chl = v * 2 + 1, chr = v * 2 + 2, mid = (l + r) / 2; return min(queryMin(L, R, chl, l, mid), queryMin(L, R, chr, mid, r));&#125;int main() &#123; int q; scanf(\"%d%d\", &amp;n, &amp;q); fill(mx, mx + 2 * maxn, -INF); fill(lx, lx + 2 * maxn, INF); int y; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;y); update(i, y); &#125; while (q--) &#123; int A, B; scanf(\"%d%d\", &amp;A, &amp;B); int L = A - 1, R = B; printf(\"%d\\n\", queryMax(L, R) - queryMin(L, R)); &#125;&#125;","tags":[{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"trees","slug":"trees","permalink":"http://dafenghh.github.io/tags/trees/"}]},{"title":"POJ 2991 [Crane] 题解","date":"2017-12-29T11:03:22.000Z","path":"post/a9a98564.html","text":"题目大意N条线段首尾相连，初始时全都垂直于x轴呈一直线。标号从下往上，1到N。C次询问，每次询问给出S和A，将第S条线段和第S+1条线段的角度修改成A，角度指的是从S开始沿逆时针方向旋转到S+1经过的角度。求每次询问时第N条线段的末端点坐标。 题目分析《挑战程序设计竞赛》P170 例题，线段树的经典应用，很启发思维！ 如何转化成线段树问题呢？ 其实也是一种分治的思想。用v(i,j)表示第i条线段的始点到第j条线段的终点的向量，那么题目要求的就是每次更新后的v(1, n)如何求得v(1, n)呢？分而治之，将区间折半，v(1, n) = v(1, n / 2) + v(n / 2 + 1, n),。 如果我们旋转第i条线段，那么显然i到n的线段坐标都要变化。这样一来，我们就需要对这所有的点更新坐标一次，很明显效率是不足够的。 我们需要将旋转的特征提取出来，在上面这个例子中，(i..n)的点的相对位置是不变的，只是整体发生了旋转。 所以，我们可以只记录一个整体旋转的角度$\\alpha$ （相对于竖直方向的角度增量，逆时针为正），外加修改原来v(i, j)的定义，变成将第i条线段旋转至与地面垂直的时候，第i条线段的始点到第j条线段的终点的向量。 这样一来，我们求v(i,j)的实际值时，乘上$\\alpha$对应的旋转变换矩阵即可：\\begin{bmatrix} \\cos \\alpha &amp; -\\sin \\alpha\\\\ \\sin \\alpha &amp; \\cos \\alpha \\end{bmatrix} 所以构造这样一棵线段树，每个结点表示一段连续的线段区间，维护这两个值： 将线段区间的第一条线段旋转至垂直方向后，第一条线段的起点到最后一条线段的终点的向量 (v[i])两个儿子连接后，右儿子需要旋转的角度 (ang[i])记第i个结点的左右儿子结点为chl,chr，那么v[i] = v[chl] + M(ang[i]) * v[chr] P.S. WA了几发，原因是：当更新角度的线段s在当前区间mid之前时，我没有更新当前区间的ang值。后来发现，区间ang值的增量跟线段s角度增量一致。其实这个也很好理解（理解不了在图上画个三角形来旋转也能证明出来），因为旋转变换其实是对整个坐标系旋转，所以点旋转的是相同角度，向量旋转也是相同角度（注意平移变换不改变角度）。 P.S. 这题POJ有坑，输出格式是假的，样例中间不用加空行。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const double PI = acos(-1.0);const int maxn = 100010;double vx[2 * maxn], vy[2 * maxn], ang[2 * maxn], prv[maxn];int len[maxn];int n, q;void init(int v, int l, int r) &#123;// [l, r] if (l &gt;= r) return; ang[v] = 0; vx[v] = 0; if (l + 1 == r) &#123; vy[v] = len[l]; return; &#125; int chl = 2 * v + 1, chr = 2 * v + 2, mid = (l + r) / 2; init(chl, l, mid); init(chr, mid, r); vy[v] = vy[chl] + vy[chr];&#125;void update(int s, double a, int v, int l, int r) &#123; // angle changes a if (s &lt;= l ||s &gt;= r) return; int chl = 2 * v + 1, chr = 2 * v + 2, mid = (l + r) / 2; update(s, a, chl, l, mid); update(s, a, chr, mid, r); if (s &lt;= mid) ang[v] += a; double Co = cos(ang[v]), Si = sin(ang[v]); vx[v] = vx[chl] + Co * vx[chr] - Si * vy[chr]; vy[v] = vy[chl] + Si * vx[chr] + Co * vy[chr];&#125;int main() &#123; int testcnt = 0; while (scanf(\"%d%d\", &amp;n, &amp;q)!=EOF) &#123; testcnt++; for (int i = 0; i &lt; n; i++) scanf(\"%d\", len + i); init(0, 0, n); for (int i = 0; i &lt; n; i++) prv[i] = PI; while (q--) &#123; int s, angle_360; scanf(\"%d%d\", &amp;s, &amp;angle_360); double a = (double)angle_360 / 180 * PI; update(s, a - prv[s], 0, 0, n); prv[s] = a; printf(\"%.2lf %.2lf\\n\", vx[0], vy[0]); &#125; &#125;&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"geometry","slug":"geometry","permalink":"http://dafenghh.github.io/tags/geometry/"}]},{"title":"POJ 2785 [4 Values whose Sum is 0] 题解","date":"2017-11-30T14:45:20.000Z","path":"post/5396864a.html","text":"题目大意大小都为N的四个数组A[], B[], C[], D[], 从每个数组中分别选出一个数，a, b, c, d , 使得 a + b + c + d = 0，问有多少种选择方式。 题目分析《挑战程序设计竞赛》P160例题。《挑战》通过这道题介绍了重要的思想方法，即“折半枚举”的方法，将问题一拆为二进行枚举。 枚举出A[i]+B[j]的所有可能值和C[i]+D[j]的所有可能值, 之后用二分查找互为相反数的两个值的组数即可。 source code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 4200;typedef long long ll;int a[maxn], b[maxn], c[maxn], d[maxn];int ab[maxn * maxn], cd[maxn * maxn];ll ans = 0;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i] &gt;&gt; d[i]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) ab[i * n + j] = a[i] + b[j], cd[i * n + j] = c[i] + d[j]; sort(cd, cd + n * n); for (int i = 0; i &lt; n * n; i++) ans += upper_bound(cd, cd + n * n, -ab[i]) - lower_bound(cd, cd + n * n, -ab[i]); cout &lt;&lt; ans &lt;&lt; endl; &#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"}]},{"title":"POJ 3684 [Physics Experiment] 题解","date":"2017-11-30T07:30:55.000Z","path":"post/d839a1f6.html","text":"题目大意N个半径为R厘米的球竖直叠放在H米的高度上。实验开始时释放最下面的第一个球，1s后释放最下面的第二个球，1s后释放第三个球……一次类推。求T秒时每个球底端的高度。所有碰撞都是弹性碰撞， g取10 m/s^2 题目分析这题的转化非常巧妙。 首先观察到很重要的一点，所有球的顺序在碰撞过程中都是不变的。很明显最下面一个球永远会在最下面，最上面一个球永远在最上面……这个很显然的结论将会给我们下面的转化过程带来帮助。 考虑两个球碰撞时的情形，根据物理知识，我们知道碰撞时的两个球的速度一定大小相同，方向相反。碰撞后交换速度。 这时候我们可以将两个球互相弹回的过程视作两个球“穿过了对方”而继续运动。在穿过的这个瞬间，球的速度没有变化，但下面的球高度获得2R的增量，上面的球高度获得-2R的增量。 然后，最关键的一步转化来了。 如果我们修改每个球的高度的定义，将每个球的高度h[i]定义为实际高度-2*i*R （球的坐标分别为0..N-1, 从下往上），这样会发生什么？ 首先在初始时刻，所有的球的高度h[i]都是H。 然后我们再来看两个球碰撞的过程，碰撞时“穿过了对方”也就是“带着自己的速度到了对方的位置”。 这样想的话，我们就相当于交换了两个相邻的球的顺序，与一开始我们的结论“所有球的顺序一直不变有点矛盾”。 我们加多一层转化，就是将碰撞过程视作“带着自己的速度到了对方的位置，并变成了对方”。比如i和i+1碰撞，我们看作，i保持着自己的速度瞬间跳转i+1的位置，并变成了i+1；i+1同理。 i变成i+1的话，高度的定义也发生了改变，从实际高度-2*i*R 变成 实际高度-2*(i+1)*R]， 与实际高度的差值加多了一个2R, 另外这个过程里，i也会获得2R高度的增量，所以两部分抵消，h高度值完全没有变化。 这么一来，问题就变成，N个球相隔1s依次从高度H开始下落，求T秒后各球高度。另外我们要还原成实际高度，将高度排序后从下往上依次加上2*i*R即可. 就这样完美转化成一道简单物理题。 source code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const double g = 10;double solve(double h, double t) &#123; double t0 = sqrt(2 * h / g); t -= 2 * t0 * ((int)(t / (2 * t0))); if (t &gt; t0) t = 2 * t0 - t; return h - 0.5 * g * t * t;&#125;const int maxn = 200;double a[maxn];int main() &#123; int Test; scanf(\"%d\", &amp;Test); while (Test--)&#123; int N; double H, R, T; scanf(\"%d%lf%lf%lf\", &amp;N, &amp;H, &amp;R, &amp;T); R /= 100; for (int i = 0; i &lt; N; i++) &#123; a[i] = H; &#125; for (int i = 0; i &lt; min((int)T,N); i++) &#123; a[i] = solve(a[i], T - i); &#125; sort(a, a + N); for (int i = 0; i &lt; N; i++) &#123; printf(\"%.2lf%c\", a[i] + 2 * i * R, (i == N - 1 ? 10:32)); &#125; &#125;&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"},{"name":"巧妙的转化","slug":"巧妙的转化","permalink":"http://dafenghh.github.io/tags/巧妙的转化/"}]},{"title":"POJ 3279 [Fliptile] 题解","date":"2017-11-29T14:39:42.000Z","path":"post/bdca6a8a.html","text":"题目大意一个游戏，M*N的方格，每个格子可以翻转正反面，一面白色，一面黑色。当翻转一个格子时，它的相邻格子都会被翻转。用最小的翻转次数使所有格子变成白色。 题目分析考虑(1,1)这个格子，翻转(1,1) (1,2) (2,1)三个格子都能改变它的状态。但当我们确定第一行的操作后，就只有翻转(2,1)能够改变(1,1)的状态。 所以，如果我们指定第一行的操作，就能根据(1,1)的状态来确定(2,1)是否需要翻转。同样的，也能确定余下所有方格是否需要翻转。最后确定一下最下一行是否全部变成白色即可。 所以这道题，就枚举第一行的所有操作即可。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;int m,n;const int maxn = 20;int a[maxn][maxn], flip[maxn][maxn], ans_flip[maxn][maxn], stat[maxn][maxn];int ans = 1000;#define Forij \\ for (int i = 0; i &lt; m; i++)\\ for (int j = 0; j &lt; n; j++)void F(int x, int y) &#123; stat[x][y] = 1 - stat[x][y]; int d[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int di = 0; di &lt; 4; di++)&#123; int nx = x + d[di][0], ny = y + d[di][1]; if (nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n) stat[nx][ny] = 1 - stat[nx][ny]; &#125;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n; Forij cin &gt;&gt; a[i][j]; for (int x = 0; x &lt; (1 &lt;&lt; n); x++) &#123; bool flag = true, cnt = 0; Forij stat[i][j] = a[i][j], flip[i][j] = 0; for (int xi = 0; xi &lt; n; xi++)&#123; if (x &amp; (1 &lt;&lt; xi)) &#123; F(0, xi); flip[0][xi] = 1; cnt++; &#125; &#125; Forij &#123; if (i == m - 1)&#123; if (stat[i][j])&#123; flag = false; break; &#125; &#125; else &#123; if (stat[i][j])&#123; F(i + 1, j); flip[i + 1][j] = 1; cnt++; &#125; &#125; &#125; if (flag &amp;&amp; (cnt &lt; ans)) &#123; ans = cnt; Forij ans_flip[i][j] = flip[i][j]; &#125; &#125; if (ans == 1000) cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; endl; else&#123; Forij cout &lt;&lt; ans_flip[i][j] &lt;&lt; (j == n - 1 ? '\\n' : ' '); &#125;&#125;","tags":[{"name":"反转","slug":"反转","permalink":"http://dafenghh.github.io/tags/反转/"},{"name":"brute force","slug":"brute-force","permalink":"http://dafenghh.github.io/tags/brute-force/"},{"name":"位运算","slug":"位运算","permalink":"http://dafenghh.github.io/tags/位运算/"}]},{"title":"codeforces gym 101612 H [Hidden Supervisors] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:38:43.000Z","path":"post/2cb42504.html","text":"题目描述gym 101612 H题链接： gym 给定若干棵树，其中一棵的根结点为1，现在把这所有的树合并成一棵根结点为1的树，并且要使这棵树中能够组成的(a,b)(a是b的父结点)的组数最大。 题目分析先对每棵树做下DFS，用贪心的方式分好组。这棵树的根结点要么分好组，要么没分好。对所有不等于1的根结点，如果它已经分好组，就直接连到1上面；如果没分好组，就连到结点1的树未分组的一个结点上。对没分好组的根结点，用下贪心策略，对应的树的未分组结点越多的根结点越优先连接。 就这样简单的贪心策略，完成此题……想复杂了，并且细节上犯了弱智错误，debug很久。（根结点的分组居然写在了countUnmatchedNodesForAllTrees函数之前）。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//#define LOCAL#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n;int p[maxn], rt[maxn];vector&lt;int&gt; G[maxn];typedef pair&lt;int, int&gt; P;bool matched[maxn];int cnt = 0;vector&lt;int&gt; unmatched_nodes[maxn];set&lt;int&gt; S;void addUnmatchedNodes(int v)&#123; int u = rt[v]; unmatched_nodes[u].push_back(v);&#125;void addUnmatchedNodesToRoot(int v)&#123; for (auto i: unmatched_nodes[v])&#123; S.insert(i); &#125; //unmatched_nodes[v].clear();&#125;bool Match(int v, int root) &#123; rt[v] = root; bool res = false; for (auto i: G[v]) &#123; if (!Match(i, root))&#123; if (!res)&#123; matched[v] = true; matched[i] = true; res = true; cnt++; &#125; &#125; &#125; return res;&#125;void countUnmatchedNodesForAllTrees() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (!matched[i]) &#123; addUnmatchedNodes(i); &#125; &#125;&#125;int main() &#123; #ifndef LOCAL freopen(\"hidden.in\", \"r\", stdin); freopen(\"hidden.out\", \"w\", stdout); #endif scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; scanf(\"%d\", p + i); G[p[i]].push_back(i); &#125; Match(1, 1); queue&lt;int&gt; que0; priority_queue&lt;P&gt; que1;//que0: matched que1: unmatched for (auto i: G[0]) &#123; Match(i, i); &#125; countUnmatchedNodesForAllTrees(); for (auto i: G[0]) &#123; if (matched[i]) &#123; que0.push(i); &#125; else que1.push(P(unmatched_nodes[i].size(),i)); &#125; addUnmatchedNodesToRoot(1); while (!que0.empty()) &#123; int u = que0.front(); que0.pop(); p[u] = 1; addUnmatchedNodesToRoot(u); &#125; while (!que1.empty()) &#123; int u = que1.top().second; que1.pop(); if (!S.empty())&#123; int v = *S.begin(); p[u] = v; cnt++; addUnmatchedNodesToRoot(u); S.erase(u); S.erase(v); &#125; else &#123; p[u] = 1; addUnmatchedNodesToRoot(u); &#125; &#125; printf(\"%d\\n\", cnt); for (int i = 2; i &lt;= n; i++) printf(\"%d%c\", p[i], (i == n?10:32));&#125;","tags":[{"name":"greedy","slug":"greedy","permalink":"http://dafenghh.github.io/tags/greedy/"},{"name":"trees","slug":"trees","permalink":"http://dafenghh.github.io/tags/trees/"}]},{"title":"codeforces gym 101612 I [Intelligence in Perpendicularia] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:38:10.000Z","path":"post/7ec55acf.html","text":"题目描述gym 101612 I题链接： gym 给出一个多边形（只包含水平边和垂直边），求所有边中不能从外面看见的部分的长度。 题目分析注意到能被外面看到的边经过平移后刚好能组成一个矩形，所以这题就简单了。先统计出周长，然后减去外接矩形的周长就得到答案了。 source code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;fstream&gt;#include &lt;algorithm&gt;using namespace std;ifstream cin(\"intel.in\");ofstream cout(\"intel.out\");const int maxn = 2000;typedef long long ll;ll x[maxn], y[maxn];int n;ll abs_(ll x)&#123; return x &gt; 0 ? x : -x;&#125;ll getL(int i, int j) &#123; if (x[i] == x[j]) return abs_(y[i] - y[j]); else return abs_(x[i] - x[j]);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; ll len = 0; ll minX, maxX, minY, maxY; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; len += getL(i , (i + 1) % n); if (i == 0) minX = maxX = x[i], minY = maxY = y[i]; else minX = min(minX, x[i]), maxX = max(maxX, x[i]), minY = min(minY, y[i]), maxY = max(maxY, y[i]); &#125; // cout &lt;&lt; len &lt;&lt; endl; //cout &lt;&lt; maxX &lt;&lt; \" \" &lt;&lt; minX &lt;&lt; \" \" &lt;&lt; maxY &lt;&lt; \" \" &lt;&lt; minY &lt;&lt; endl; cout &lt;&lt; len - 2 * (maxX - minX + maxY - minY) &lt;&lt;endl;&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"codeforces gym 101612 K [Kotlin Island] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:36:06.000Z","path":"post/f48dff26.html","text":"题目描述gym 101612 K题链接： gym 一个岛可以看成一个h*w的网格，现在可以在任意的行或者任意的类挖水渠，目标是将网格剩下没被挖水渠的点划分成k个连通块。给出一种方案即可。 题目分析显然最后分成的连通块数目 = 行的分块数 * 列的分块数。比如有5行，那么我们最多可以分成3块。 枚举一遍就出答案了。 source code12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;const int maxn = 120;bool row[maxn], col[maxn];int h, w, n;int main() &#123; #ifndef LOCAL freopen(\"kotlin.in\", \"r\", stdin); freopen(\"kotlin.out\", \"w\", stdout); #endif scanf(\"%d%d%d\", &amp;h, &amp;w, &amp;n); for (int hi = 1; hi &lt;= (h + 1) / 2; hi++) for (int wi = 1; wi &lt;= (w + 1) / 2; wi++) &#123; if (hi * wi == n)&#123; for (int i = 0; i &lt; hi - 1; i++) row[1 + i * 2] = true; for (int i = 0; i &lt; wi - 1; i++) col[1 + i * 2] = true; for (int i = 0; i &lt; h; i++) &#123; for (int j = 0; j &lt; w; j++)&#123; if (row[i] || col[j]) printf(\"#\"); else printf(\".\"); &#125; printf(\"\\n\"); &#125; return 0; &#125; &#125; printf(\"Impossible\\n\");&#125;","tags":[{"name":"brute force","slug":"brute-force","permalink":"http://dafenghh.github.io/tags/brute-force/"}]},{"title":"codeforces gym 101612 C [Consonant Fencity] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:35:36.000Z","path":"post/9c682bc0.html","text":"题目描述gym 101612 C题链接： gym 定义辅音字母为除了{a,e,i,o,u,w,y}之外的19个字母。然后定义一个字符串的fencity为串中有多少对相邻的辅音字母，且它们一个大写一个小写。给出一个只包含小写字母的字符串，现在你要指定19个辅音字母中的若干个字母，将字符串中的这些字母全部转换为大写。求fencity最大的串。 题目分析一共有19个字母要考虑。将这19个字母想象成图中的点。我们先扫一遍字符串，当遇到辅音字母相邻时，就将这两个辅音字母的边权+1. 然后这题就是说，往19个点染两种颜色（大写或者非大写），当一条边的两个端点颜色不一样时，这条边的边权生效。求边权和最大值。 由于对称性，我们可以固定一个点的颜色，然后只有18个点需要考虑，那么就是2^18中情况需要枚举。每个情况扫一遍所有的边，那么就是2^18 * 19 * 18 / 2的复杂度，大概为4500万，所以暴力方式能够解决此题。 P.S.有个小插曲，(1 &lt;&lt; M[s[i]])) &gt; 0 忘了加前面的括号，debug了好长时间。下次打比赛时要先打印一份C/C++运算符优先级列表，然后将它压在台面上。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;int n = 19;int w[20][20];int fencity[(1 &lt;&lt; 18)];void solve() &#123; int xn = (1 &lt;&lt; (n - 1)); for (int x = 0; x &lt; xn; x++) &#123; fencity[x] = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++)&#123; int p = (x &amp; (1 &lt;&lt; i)); int q = (x &amp; (1 &lt;&lt; j)); if (p == 0 &amp;&amp; q &gt; 0 || p &gt; 0 &amp;&amp; q == 0)&#123; fencity[x] += w[i][j]; &#125; &#125; &#125;&#125;char s[1000010];char voewls[] = \"aeiouwy\";int main() &#123; #ifndef LOCAL freopen(\"consonant.in\", \"r\", stdin); freopen(\"consonant.out\", \"w\", stdout); #endif scanf(\"%s\", s); int len = strlen(s); set&lt;char&gt; S(voewls, voewls+ 7); map&lt;char, int&gt; M; int cnt = 0; for (char ch = 'b'; ch &lt;= 'z'; ch++) &#123; if (!S.count(ch)) M[ch] = cnt++; &#125; for (int i = 0; i &lt; len - 1; i++) &#123; if (M.count(s[i]) &amp;&amp; M.count(s[i + 1])) &#123; w[M[s[i]]][M[s[i + 1]]]++; w[M[s[i + 1]]][M[s[i]]]++; &#125; &#125; solve(); int ans = 0, xn = (1 &lt;&lt; (n - 1)); for (int x = 1; x &lt; xn; x++) if (fencity[ans] &lt; fencity[x]) ans = x; for (int i = 0; i &lt; len; i++) &#123; if (!S.count(s[i]) &amp;&amp; ((ans &amp; (1 &lt;&lt; M[s[i]])) &gt; 0)) printf(\"%c\", s[i] + 'A' - 'a'); else printf(\"%c\", s[i]); &#125; printf(\"\\n\");&#125;","tags":[{"name":"brute force","slug":"brute-force","permalink":"http://dafenghh.github.io/tags/brute-force/"},{"name":"位运算","slug":"位运算","permalink":"http://dafenghh.github.io/tags/位运算/"}]},{"title":"codeforces gym 101612 E [Equal Numbers] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:30:09.000Z","path":"post/79e97c8b.html","text":"题目描述gym 101612 E题链接： gym 给定一个大小为n的正整数的数组，每次操作可以选取数组中一个数，将它乘上若干倍。求经过k次操作后，数组中最少有多少个不同的数？输出所有0&lt;=k&lt;=n的k的结果。 题目分析样例输入是n = 4, a[] = {1, 1, 2, 2, 3, 4} 我们先将相同的数合并成一堆，比如这里a[]可以看作{1(2), 2(2), 3(1), 4(1)} 括号里的数表示这个数字的出现次数。 假定初始状态有vn堆数，这个样例里vn = 4 题目要求的就是经过若干次操作后，最少剩下多少堆。 不妨换个思路，我们来求把vn堆数合并成vn - k堆至少需要多少次操作。如果能求出这个结果，我们将数组逆一下，并且空白处的值用前面的值填充好就得到题目要求的答案。 下面思考把vn堆数合并成vn - k堆， 也就是减少k堆，至少需要多少次操作。 我们把原来的数分成两类，一类是它的倍数也存在于数组中，另一类是它没有一个倍数存在与数组中，分别记为A类，B类。 样例中A类为： 1(2), 2(2)样例中B类为： 3(1), 4(1) 为了减少k堆，我们有两种决策方法： 直接在A类中选取大小最小的k堆，将这些数全部提升为它们的倍数。 在B类中选取大小最小的两堆，将这两堆数提升为所有数的最小公倍数，这时候减少了原有的2堆，但新增了1堆（所有数的最小公倍数），并且因为出现了所有数的最小公倍数，所以原有的所有数都变成A类，再按方法1选取(k-1)堆即可。 两种方法分别求出来比较一下，取最优就得到答案了。 源代码中用x表示第一种决策方式需要的操作数，y表示第二种决策方式需要的操作数。 source_code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1000060;int a[maxn], cnt[maxn], ops[maxn], ans[maxn], bucket[maxn];vector&lt;int&gt; v0, v1, v2;void bucket_sort(vector&lt;int&gt; &amp;v)&#123; memset(bucket, 0, sizeof(bucket)); for (int i = 0; i &lt; v.size(); i++) bucket[v[i]]++; v.clear(); for (int i = 0; i &lt; maxn; i++) for (int j = 0; j &lt; bucket[i]; j++) v.push_back(i);&#125;int main() &#123; #ifndef LOCAL freopen(\"equal.in\", \"r\", stdin); freopen(\"equal.out\", \"w\", stdout); #endif int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", a + i); cnt[a[i]]++; &#125; for (int i = 1; i &lt; maxn; i++)&#123; if (cnt[i])&#123; bool flag = false; for (int j = 2; i * j &lt; maxn; j++) &#123; if (cnt[i * j]) &#123; flag = true; break; &#125; &#125; if (flag) v0.push_back(cnt[i]); else v1.push_back(cnt[i]); &#125; &#125; int vn = v0.size() + v1.size(); bucket_sort(v0); bucket_sort(v1); for (int i = 0; i &lt; v0.size(); i++) v2.push_back(v0[i]); for (int i = 2; i &lt; v1.size(); i++) v2.push_back(v1[i]); bucket_sort(v2); ops[vn] = 0; int x = 0, y = 0; if (v1.size() &gt;= 2) y+=v1[0] + v1[1]; else y = 2 * n; for (int k = 1; k &lt; vn; k++) &#123; if (k &lt;= v0.size()) x += v0[k - 1]; else x = 2 * n; if (k &gt; 1) y+=v2[k - 2]; // printf(\"x = %d, y = %d, k = %d\\n\", x, y, k); ops[vn - k] = min(x, y); &#125; for (int i = 1; i &lt;= vn; i++)&#123; ans[ops[i]] = i; &#125; for (int i = 1; i &lt;= n; i++)&#123; if (ans[i] == 0) ans[i] = ans[i-1]; &#125; for (int i = 0; i &lt;= n; i++) printf(\"%d%c\", ans[i], (i == n?10:32));&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"POJ 3484 [Showstopper] 题解","date":"2017-11-28T14:44:04.000Z","path":"post/b9568341.html","text":"题目大意给定若干等差数列，初项x，公差z，末项不大于y（均为正整数）。在所有数列有，有且仅有一个数的出现次数是奇数，求这个数以及它出现的次数。 题目分析初看此题，真的毫无思路。虽然知道实在《挑战程序设计竞赛》的二分专题中，肯定使用二分算法，但怎么联系到二分上去呢？ 有且只有一个奇数，这就是突破口。对解空间中的所有数，统计它们在数列中的出现次数，记为c[i]，然后对c[i]求个前缀和，那么在答案点x前，前缀和均为偶，答案点x及之后，前缀和均为奇。由此得到二分的单调性，得解。 有点小插曲，这道题的输入方式很麻烦……最讨厌按行输入了。WA几次后以为是输入有问题，其实是算法部分写错了细节。统计区间的数在数列的出现次数时，左端应该向上取整…… 代码比较累赘，特别是统计的时候，可以写精简些。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Tuple &#123; ll x, y, z; Tuple(ll x = 0, ll y = 0, ll z = 0):x(x), y(y), z(z)&#123;&#125;&#125;;vector&lt;Tuple&gt; vec;ll count_(ll L, ll R, Tuple t) &#123; //[L, R] ll x = t.x, y = t.y, z = t.z; if (R &lt; x || L &gt; y) return 0; if (L &lt; x) L = x; if (R &gt; y) R = y; ll res = (R - x ) / z - (L - x) / z + 1; if ((L - x) % z) res--; return res;&#125;void solve() &#123; /*printf(\"-------------\\n\"); for (ll i = 0; i &lt; vec.size(); i++) &#123; printf(\"%lld %lld %lld\\n\", vec[i].x, vec[i].y, vec[i].z); &#125; printf(\"-------------\\n\");*/ if (vec.empty()) return; ll L = vec[0].x, R = vec[0].y; for (ll i = 1; i &lt; vec.size(); i++) &#123; L = min(L, vec[i].x); R = max(R, vec[i].y); &#125; L--; ll sum = 0; for (ll i = 0; i &lt; vec.size(); i++) &#123; sum += count_(L, R, vec[i]); &#125; if (sum % 2 == 0) &#123; printf(\"no corruption\\n\"); return; &#125; while (L + 1 &lt; R) &#123; ll mid = (L + R) / 2; ll sum = 0; for (ll i = 0; i &lt; vec.size(); i++) &#123; sum += count_(L, mid, vec[i]); &#125; if (sum % 2 == 0) L = mid; else R = mid; &#125; sum = 0; for (ll i = 0; i &lt; vec.size(); i++) &#123; sum += count_(R, R, vec[i]); &#125; ll ans = (ll)R; printf(\"%I64d %I64d\\n\", ans, sum);&#125;char s[1000];void work() &#123; ll x = 0, y = 0, z = 0; sscanf(s, \"%I64d %I64d %I64d\", &amp;x, &amp;y, &amp;z); if (!x) return; vec.clear(); vec.push_back(Tuple(x, y, z)); memset(s, 0, sizeof(s)); while (gets(s), *s) &#123; sscanf(s, \"%I64d %I64d %I64d\", &amp;x, &amp;y, &amp;z); vec.push_back(Tuple(x, y, z)); memset(s , 0 , sizeof(s)); &#125; solve();&#125;int main() &#123; while (gets(s)) work();&#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"},{"name":"按行输入","slug":"按行输入","permalink":"http://dafenghh.github.io/tags/按行输入/"}]},{"title":"POJ 3276 [Face The Right Way] 题解","date":"2017-11-28T12:22:37.000Z","path":"post/49886522.html","text":"题目大意n头牛排成一行，有的牛面朝前，有的牛面朝后，每一次操作可以使连续的K头牛改变方向；求一个K，使得操作次数最少。输出K以及最少的操作次数。当有多个K满足条件时，输出最小的K。 题目分析对一个区间来说，多次进行反转操作是没有意义的；另外反转的顺序对结果是没有影响的。所以这道题只需要对所有的可操作区间（即长度为K的区间）考虑是否需要反转。 考虑最左边的牛，当它面朝前时无需反转，当它面朝后时，就反转[1, K]区间一次。然后继续考虑第二头牛即可。 反转的时候不必每头牛都操作一次，只需用一个turns来记录当前区间的反转次数，考虑的下一头牛的状态就由它本身状态+turns的值来决定。随着区间往右移动，我们用区间左右更改的地方来更新turns即可。复杂度为O(n ^ 2) source code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 5500;const int INF = 100243535;int a[maxn], f[maxn], cnt[maxn];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; char s[10]; scanf(\"%s\", s); a[i] = (s[0] == 'F' ? 0 : 1); &#125; for (int k = 1; k &lt;= n; k++) &#123; memset(f, 0, sizeof(f)); int turns = 0; for (int i = 0; i &lt; n; i++) &#123; if ((a[i] + turns) % 2 == 1) &#123; if (i + k &gt; n) &#123; cnt[k] = INF; break; &#125; f[i] = 1; cnt[k]++; turns++; &#125; if (i - k + 1 &gt;= 0) turns -= f[i - k + 1]; &#125; &#125; int ansK = 1; for (int k = 2; k &lt;= n; k++) if (cnt[k] &lt; cnt[ansK]) ansK = k; printf(\"%d %d\\n\", ansK, cnt[ansK]);&#125;","tags":[{"name":"区间处理","slug":"区间处理","permalink":"http://dafenghh.github.io/tags/区间处理/"},{"name":"反转","slug":"反转","permalink":"http://dafenghh.github.io/tags/反转/"}]},{"title":"POJ 3320 [Jessica's Reading Problem] 题解","date":"2017-11-28T04:51:03.000Z","path":"post/6f199fb1.html","text":"题目大意给定一个大小为P的数组，取出一个子区间，要求这个子区间上的数能覆盖整个数组的数，求满足条件的子区间的最小长度。 题目分析《挑战程序设计竞赛》P149例题，采用“尺取法”可以很快地做出这道题。 挑战程序设计竞赛 使用map来记录的时间复杂度为O(P log P)。 由于P最大为10e6，所以我提交的时候很担心超时。结果真的超时了，但并不是复杂度的锅，而是我用了cin cout，改成scanf printf就过了。 后来查了下，在windows下不开ios::sync_with_stdio(false)的优化时，cin比scanf慢差不多十倍;开了后，慢三倍。只有在linux下g++编译，并且写上这一句优化的情况下，cin才达到和scanf差不多的效率。 之后，将map改成hash，将时间复杂度降到线性，并且采用快速读入，这样才能47ms通过。 source codesolution 1 (454ms)12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1000100;int a[maxn];int main() &#123; int n; scanf(\"%d\", &amp;n); set&lt;int&gt; S; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", a + i); S.insert(a[i]); &#125; int sn = S.size(); S.clear(); map&lt;int, int&gt; M; int s = 0, t = 0, cnt = 0, ans = n; for (;;) &#123; while (t &lt; n &amp;&amp; cnt &lt; sn) &#123; if (M[a[t]] == 0) cnt++; M[a[t]]++; t++; &#125; if (cnt &lt; sn) break; ans = min(ans, t - s); if (M[a[s]] == 1) cnt--; M[a[s]]--; s++; &#125; printf(\"%d\\n\", ans);&#125; solution 2 (47ms)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1000100;int a[maxn];const int hash_n = 535442;int M0[hash_n], M[hash_n];inline int get()&#123; int k=0; char f=1; char c=getchar(); for(;!isdigit(c);c=getchar() ) if(c=='-') f=-1; for(;isdigit(c);c=getchar() ) k=k*10+c-'0'; return k*f;&#125;int main() &#123; int n; n = get(); for (int i = 0; i &lt; n; i++) &#123; a[i] = get(); a[i] %= hash_n; M0[a[i]]++; &#125; int sn = 0; for (int i = 0; i &lt; hash_n; i++) if (M0[i]) sn++; int s = 0, t = 0, cnt = 0, ans = n; for (;;) &#123; while (t &lt; n &amp;&amp; cnt &lt; sn) &#123; if (M[a[t]] == 0) cnt++; M[a[t]]++; t++; &#125; if (cnt &lt; sn) break; ans = min(ans, t - s); if (M[a[s]] == 1) cnt--; M[a[s]]--; s++; &#125; printf(\"%d\\n\", ans);&#125;","tags":[{"name":"尺取法","slug":"尺取法","permalink":"http://dafenghh.github.io/tags/尺取法/"},{"name":"hash","slug":"hash","permalink":"http://dafenghh.github.io/tags/hash/"}]},{"title":"POJ 1759 [Garland] 题解","date":"2017-11-28T02:08:39.000Z","path":"post/68c8caf8.html","text":"题目大意给定一个数列H[]，满足下面的关系：1234H[1] = AH[i] = (H[i-1] + H[i+1])/2 - 1, for all 1 &lt; i &lt; N H[N] = B H[i] &gt;= 0, for all 1 &lt;= i &lt;= N 已知A，求B的最小值。 题目分析化成递推式， 有H[i+1] = 2 * H[i] - H[i-1] + 2 作下变形，有H[i+1] - H[i] = H[i] - H[i-1] + 2 所以H[i+1] - H[i]是一个等差数列，公差为2，那么：H[i+1] - H[i] = H[2] - H[1] + 2 * (i - 1) 做累加求和即得H[i]通项公式： H[i] = (i - 1) * H[2] + (2 - i) * H[1] + (i - 1) * (i - 2) 题目要求B，即H[N] = (N - 1) * H[2] + (2 - N) * H[1] + (N - 1) * (N - 2) 这个式子中，仅有H[2]为未知项，其他均已知。而且H[2]项前的系数N-1为正，H[N]与H[2]线性正相关，所以H[N]取最小值当且仅当H[2]取最小值。 于是我们将问题转化为求H[2]最小值即可。对H[2]进行二分，每次验证数列里的所有项是否全部大于零即可。 P.S. 交了几发WA，因为一不小心交了G++编译器，POJ的G++编译器有点老，浮点支持得不好。 source_code1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cmath&gt;int n;double A,B;bool judge(double mid) &#123; double a = A, b = mid,x; for (int i = 3; i &lt;= n; i++) &#123; x = 2 * b - a + 2; if (x &lt; 0) return false; a = b; b = x; &#125; B = x; return true;&#125;int main() &#123; scanf(\"%d%lf\", &amp;n, &amp;A); double L = -1, R = 1060; for (int i = 0; i &lt; 100; i++) &#123; double mid = (L + R) / 2; if (judge(mid)) R = mid; else L = mid; &#125; printf(\"%.2lf\\n\", B);&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"},{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"}]},{"title":"codeforces 894E [Ralph and Mushrooms] #round 447 div2E 题解","date":"2017-11-27T11:39:47.000Z","path":"post/2fde12e8.html","text":"题目大意一个有向图，n个点，m条边，每条边初始有w[i]个蘑菇。有可能存在自环或重边。从点s出发，任意移动，当第一次经过一条边时，能采集w[i]个蘑菇；第二次经过这条边时，能采集w[i] - 1个蘑菇；第三次经过时，能采集w[i] - 1 - 2个；第四次则为w[i] - 1 - 2 - 3个，依次类推。当可采集蘑菇数变成0或负数后，仍能从这条边经过，但不会获得蘑菇。求能采集到的蘑菇的最大数量。 题目分析经过强连通分量(scc)分解后，并缩成一个DAG。显然每个scc上，可以任意次数遍历这个scc包含的边，直至无蘑菇可采。然后scc之间的边，最多只能经过一次。对那些可以无限遍历的边，我们先用二分求出总蘑菇数，然后汇总到所在的scc中。最后应用DAG上的动态规划，算出从点s出发, 能采集到的最大蘑菇数。 source_code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;utility&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;int V;const int maxv= 1000010;vector&lt;int&gt; G[maxv], rG[maxv], vs;bool used[maxv];int cmp[maxv];void add_edge(int from, int to)&#123; G[from].push_back(to); rG[to].push_back(from); &#125;void dfs(int v)&#123; used[v] = true; for(int i = 0; i &lt; G[v].size(); i++)&#123; if (!used[G[v][i]]) dfs(G[v][i]); &#125; vs.push_back(v);&#125;void rdfs(int v, int k)&#123; used[v] = true; cmp[v] = k; for (int i = 0; i &lt; rG[v].size(); i++)&#123; if (!used[rG[v][i]]) rdfs(rG[v][i], k); &#125;&#125;int scc() &#123; memset(used, 0, sizeof(used)); vs.clear(); for (int v = 1; v &lt;= V; v++)&#123; if (!used[v]) dfs(v); &#125; memset(used, 0 , sizeof(used)); int k = 0; for (int i = vs.size() - 1; i &gt;= 0; i--)&#123; if(!used[vs[i]]) rdfs(vs[i], k++); &#125; return k;&#125;const int sn = 22000;ll sum[sn], accSum[sn];void init_sum() &#123; sum[0] = accSum[sn] = 0; for (int i = 1; i &lt; sn; i++) sum[i] = sum[i - 1] + i; for (int i = 1; i &lt; sn; i++) accSum[i] = accSum[i - 1] + sum[i];&#125;ll calWeight(int x) &#123; int k = upper_bound(sum, sum + sn, x) - sum - 1; return (ll)(k+1) * x - accSum[k]; &#125; ll shrink_vertex_weight[maxv], dp[maxv];int sV;vector&lt;int&gt; shrink_graph[maxv];map&lt;P, ll&gt; shrink_edge_weight;struct edge&#123;int from, to, weight;&#125;;edge edges[maxv];void update(ll &amp;a, ll b) &#123; if (b &gt; a) a = b;&#125;ll f(int v) &#123; if (dp[v] &gt; -1) return dp[v]; ll reward = 0; for (auto i: shrink_graph[v]) &#123; update(reward, shrink_edge_weight[P(v, i)] + f(i)); &#125; return dp[v] = shrink_vertex_weight[v] + reward;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); init_sum(); int n, m; cin &gt;&gt; n &gt;&gt; m; V = n; for (int i = 0; i &lt; m; i++) &#123; int from, to, weight; cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight; add_edge(from, to); edges[i] = edge&#123;from, to, weight&#125;; &#125; int start; cin &gt;&gt; start; sV = scc(); for (int i = 0; i &lt; m; i++) &#123; int v1 = edges[i].from, v2 = edges[i].to; if (cmp[v1] == cmp[v2]) &#123; shrink_vertex_weight[cmp[v1]] += calWeight(edges[i].weight); &#125; else &#123; update(shrink_edge_weight[P(cmp[v1], cmp[v2])], edges[i].weight); shrink_graph[cmp[v1]].push_back(cmp[v2]); &#125; &#125; memset(dp, -1, sizeof(dp)); cout &lt;&lt; f(cmp[start]) &lt;&lt; endl;&#125;","tags":[{"name":"graphs","slug":"graphs","permalink":"http://dafenghh.github.io/tags/graphs/"},{"name":"dp","slug":"dp","permalink":"http://dafenghh.github.io/tags/dp/"},{"name":"scc","slug":"scc","permalink":"http://dafenghh.github.io/tags/scc/"}]},{"title":"POJ 3061 [Subsequence] 题解","date":"2017-11-27T07:43:53.000Z","path":"post/acca6816.html","text":"题目大意给定一个长度为N的数列，以及整数S。求出和不小于S的连续子序列的长度的最小值。如果解不存在，则输出0. 题目分析先求前缀和，然后就能用O(1)的时间, 求出一个区间的和。 之后用二分就能解决这道题。 但《挑战程序设计竞赛》(P146)中提供了一种更高效和简单的解法，叫“尺取法”。 source codesolution 11234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int maxn = 100010;typedef long long ll;ll a[maxn], sum[maxn];int N;ll S;bool judge(int len) &#123; for (int i = 0; i + len &lt;= N; i++) &#123; if (sum[i + len] - sum[i] &gt;= S) return true; &#125; return false;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N &gt;&gt; S; for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; sum[0] = 0; for (int i = 0; i &lt; N; i++) sum[i + 1] = sum[i] + a[i]; if (sum[N] &lt; S) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int L = 0, R = N; while (L + 1 &lt; R) &#123; int mid = (L + R) / 2; if (judge(mid)) R = mid; else L = mid; &#125; cout &lt;&lt; R &lt;&lt; endl; &#125;&#125; solution 212345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;typedef long long ll;ll a[maxn];int N;ll S;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N &gt;&gt; S; for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; int s = 0, t = 0; ll sum = 0; int ans = N + 1; for (;;) &#123; while (t &lt; N &amp;&amp; sum &lt; S) sum += a[t++]; if (sum &lt; S) break; ans = min(ans, t - s); sum -= a[s++]; &#125; if (ans &gt; N) ans = 0; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"},{"name":"尺取法","slug":"尺取法","permalink":"http://dafenghh.github.io/tags/尺取法/"}]},{"title":"POJ 1064 [Cable master] 题解","date":"2017-11-27T07:13:40.000Z","path":"post/52b6f961.html","text":"题目大意N条绳子，长度分别为Li，从它们之中切割出K条长度相同的绳子，求这K条绳子每条最长的长度，答案保留至小数点后二位。 题目分析二分搜索的经典应用，“假定一个解并判断是否可行”。现在我们假定要切割出长度为x的绳子，然后判断能否切割成K条即可。 这道题卡在最后输出答案上了，不能四舍五入，一定要向下取。 source code12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cmath&gt;int N, K;double a[12000];bool judge(double k) &#123; int cnt = 0; for (int i = 0; i &lt; N; i++) &#123; cnt += a[i] / k; &#125; return cnt &gt;= K;&#125;int main() &#123; scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 0; i &lt; N; i++) &#123; scanf(\"%lf\", a + i); &#125; double L = 0.0001, R = 110000; for (int i = 0; i &lt; 100; i++)&#123; double mid = (L + R) / 2; if (judge(mid)) L = mid; else R = mid; &#125; printf(\"%.2lf\\n\", floor(L * 100) / 100);&#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"}]},{"title":"POJ 3662 [Telephone Lines] 题解","date":"2017-11-27T06:21:30.000Z","path":"post/e84ff597.html","text":"题目大意一个无向图，N的点，P条边，给出每条边的长度，定义一条路径的代价为省略路径上的K条边后剩余边的边长最大值。求点1到点N代价最小的路径的代价。 题目分析“最小化最大值”的题目，考虑二分。二分时，设当前设定代价为k，然后考虑在代价为k的约束下能否找到一条可行路径。在寻找路径时，碰到一条边长大于k的边，那么连上这条边需要省略它。显然，一条可行路径就是指路径上所有被省略的边数量不超过K。 那么就可以转化一下，边长大于k的边权值为1，边长小于等于k的边权值为0.然后用dijkstra计算1到n的最短路，如果答案不大于K，说明被省略的边数量不超过K. source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;functional&gt;using namespace std;const int INF = 20344;const int MAX_V = 1500;struct edge &#123; int to, cost; edge(int to, int cost):to(to),cost(cost)&#123;&#125;&#125;;typedef pair&lt;int, int&gt; P;int V;vector&lt;edge&gt; G[MAX_V];int d[MAX_V];int dijkstra(int s, int t, int k) &#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; fill(d + 1, d + V + 1, INF); d[s] = 0; que.push(P(0, s)); while (!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second; if (d[v] &lt; p.first) continue; for (int i = 0; i &lt; G[v].size(); i++) &#123; edge e = G[v][i]; if (d[e.to] &gt; d[v] + (e.cost &gt; k ? 1 : 0)) &#123; d[e.to] = d[v] + (e.cost &gt; k ? 1 : 0); que.push(P(d[e.to], e.to)); &#125; &#125; &#125; return d[t];&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int N, P, K; cin &gt;&gt; N &gt;&gt; P &gt;&gt; K; V = N; for (int i = 0; i &lt; P; i++)&#123; int from, to, cost; cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost; G[from].push_back(edge(to, cost)); G[to].push_back(edge(from, cost)); &#125; int L = -1, R = 1000010; if (dijkstra(1, N, R) == INF) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return 0; &#125; while (L + 1 &lt; R) &#123; int mid = (L + R) &gt;&gt; 1; if (dijkstra(1, N, mid) &lt;= K) R = mid; else L = mid; &#125; cout &lt;&lt; R &lt;&lt; endl;&#125;","tags":[{"name":"graphs","slug":"graphs","permalink":"http://dafenghh.github.io/tags/graphs/"},{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"}]},{"title":"codeforces 894D [Ralph And His Tour in Binary Country] round 447 div2D 题解","date":"2017-11-26T01:56:29.000Z","path":"post/2d71363f.html","text":"题目大意给出一棵结点数为n的完全二叉树以及所有边的长度，m次查询，每次查询输入两个正整数A和H，A为起始点，任选树上一个结点（可以选择A本身）作为终点来构成一段旅程，定义这段旅程的快乐值为H-起点到终点的路径长度。求所有快乐值为正的旅程的快乐值的和。 题目分析完全二叉树的性质在这道题要好好利用一下。因为是完全二叉树，所以树的高度为O(log n)级别。这样，我们对每一个结点，建一个数组（vector），记录从这个结点出发往它的子树上所有结点的路径长度，并且排好序。 因为一个结点最多在O(log n)个数组中出现，所以这些数组的总空间为O(n log n).另外每一个结点的数组显然可以由0（到自己的长度）+左儿子数组+右儿子数组 merge而来，那么每次合并使用归并排序，时间复杂度也是O(n log n) 做好这一步预处理后，我们怎么回答每一次询问呢？其实已经很简单了。对结点A，先统计A的子树上的路径，然后A的父节点上移动，统计A的兄弟子树上的路径；接着不断往上移动，直到根节点即可。因为树高为O(log n), 然后每一次统计时采用二分，所以每次查询的复杂度为O(log^2 n) 总复杂度为O(nlog n + mlog^2 n)实现起来还是比较容易的。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;typedef long long ll;int L[maxn];vector&lt;ll&gt; dist[maxn], accDist[maxn];int n, m;void calDist(int i) &#123; if (i &lt;= 0 || i &gt; n) return; if (2 * i &lt;= n &amp;&amp; 2 * i + 1 &lt;= n) &#123; calDist(2 * i); calDist(2 * i + 1); dist[i].push_back(0); for (int di = 0; di &lt; dist[2 * i].size(); di++) &#123; dist[i].push_back(dist[2 * i][di] + L[2 * i - 1]); &#125; for (int di = 0; di &lt; dist[2 * i + 1].size(); di++) &#123; dist[i].push_back(dist[2 * i + 1][di] + L[2 * i]); &#125; inplace_merge(dist[i].begin() + 1, dist[i].begin() + 1 + dist[2 * i].size(), dist[i].end()); &#125; else if (2 * i &lt;= n &amp;&amp; 2 * i + 1 &gt; n) &#123; calDist(2 * i); dist[i].push_back(0); for (int di = 0; di &lt; dist[2 * i].size(); di++) &#123; dist[i].push_back(dist[2 * i][di] + L[2 * i - 1]); &#125; &#125; else &#123; dist[i].push_back(0); &#125; ll acc_ = 0; for (int di = 0; di &lt; dist[i].size(); di++)&#123; accDist[i].push_back((acc_ += dist[i][di])); &#125;&#125;ll forSubtree(int v, ll H) &#123; if (H &lt; 0 || v &gt; n) return 0; int pos = upper_bound(dist[v].begin(), dist[v].end(), H) - dist[v].begin(); return H * pos - accDist[v][pos - 1];&#125;ll forPar(int v, int p, ll H) &#123; // calculate happiness int v_ = (v == 2 * p ? 2 * p + 1 : 2 * p); return forSubtree(v_, H - L[v_ - 1]);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt; n; i++) cin &gt;&gt; L[i]; calDist(1); for (int mi = 0; mi &lt; m; mi++) &#123; int A, H; cin &gt;&gt; A &gt;&gt; H; ll ans = forSubtree(A, H); while (A &gt; 1) &#123; H -= L[A - 1]; if (H &lt;= 0) break; ans += H; ans += forPar(A, A / 2, H); A /= 2; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"trees","slug":"trees","permalink":"http://dafenghh.github.io/tags/trees/"}]},{"title":"codeforces 894C [Marco and GCD Sequence] #round 447 div2C 题解","date":"2017-11-25T14:04:20.000Z","path":"post/d93115b9.html","text":"题目分析将输入的数组求一次gcd, 设求出来的值为s，然后判断s是否在原来的数组中。如果不在，那么无解；否则可以构造出一组解，往输入数组的每两个相邻的数中插入一个s，然后就得到一组解。 简单证明这组解是正确的： 设输入数组为a[]，依照上面的方式构造出来的数组为b[]，下面证明：b数组中任意一个区间的gcd值恰好构成集合a。 若i==j，即区间长度为1，那么gcd(b[i]) = b[i]， 而b[i]构成的集合与集合a等价，即表明a[]中的值都是b数组一个区间的gcd值；若i!=j，那么gcd(b[i..j]) = s, s属于集合a。以上两点说明b[]就是答案。 source code1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int gcd(int a, int b)&#123; return b == 0?a:gcd(b, a%b);&#125;int main()&#123; int m; int a[2000]; scanf(\"%d\", &amp;m); set&lt;int&gt; S; for (int i = 0; i &lt; m; i++)&#123; scanf(\"%d\", a + i); S.insert(a[i]); &#125; int g = a[0]; for (int i = 1; i &lt; m; i++) g = gcd(g, a[i]); if (S.count(g))&#123; printf(\"%d\\n%d\", 2 * m - 1, a[0]); for (int i= 1; i &lt; m; i++) printf(\" %d %d\", g, a[i]); printf(\"\\n\"); &#125; else printf(\"-1\\n\");&#125;","tags":[{"name":"constructive algorithms","slug":"constructive-algorithms","permalink":"http://dafenghh.github.io/tags/constructive-algorithms/"},{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"ACM训练计划","date":"2017-11-24T12:49:10.000Z","path":"post/3c0e0710.html","text":"从2017年11月25日开始，每天3题的日常任务。","tags":[]}]