[{"title":"Computer Networking, Chapter 1, Computer Networks and the Internet, Notes","date":"2018-09-04T02:13:08.000Z","path":"post/527c28.html","text":"1.1.3 What’s Protocol?A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event. 1.2 Network Edgeend systems = hosts (Two categories: clients and servers) Today, most of the servers from which we receive search results, e-mail, Web pages, and videos reside in large data centers. 1.2.1 Access NetworksThe access network: the network that physically connects an end system to the first router (also known as the “edge router”) on a path from the end system to any other distant end system. Home AccessToday, the two most prevalent types of broadband residential access are digital subscriber line (DSL) and cable. DSL: 数字用户线路，是以电话线为传输介质的传输技术组合。 DSL Internet access Fiber optics connect the cable head end to neighborhood-level junctions, from which traditional coaxial cable is then used to reach individual houses and apartments. A hybrid fiber-coaxial access network Because both fiber and coaxial cable are employed in this system, it is often referred to as hybrid fiber coax (HFC). Coaxial cable: 同轴电缆cable modem termination system (CMTS) Ethernet and Wi-FiLAN: local area networkAlthough there are many types of LAN technologies, Ethernet is by far the most prevalent access technology. Wide-Area Wireless Access: 3G and LTELTE: Long-Term Evolution 长期演进技术 1.2.2 Physical MediaPhysical media fall into two categories: guided media and unguided media. With guided media, the waves are guided along a solid medium, such as a fiber-optic cable, a twisted-pair copper wire, or a coaxial cable. With unguided media, the waves propagate in the atmosphere and in outer space, such as in a wireless LAN or a digital satellite channel. Twisted-Pair Copper Wire Coaxial Cable Fiber Optics Terrestrial Radio Channels Satellite Radio Channelsgeostationary satellites, low-earth orbiting (LEO) satellites 1.3 Network Core1.3.1 Packet Switchingpacket switches (for which there are two predominant types, routers and link layer switches) Store-and-Forward Transmission The packet switch must receive the entire packet before it can begin to transmit the first bit of the packet onto the outbound link. Queuing Delays and Packet Lossoutput bufferIn addition to the store-and-forward delays, packets suffer output buffer queuing delays. Packet loss may occur when buffer is completely full. Forwarding Tables and Routing ProtocolsEach router has a forwarding table that maps destination addresses (or portions of the destination addresses) to that router’s outbound links. The Internet has a number of special routing protocols that are used to automatically set the forwarding tables. 1.3.2 Circuit SwitchingIn circuit-switched networks, the resources needed along a path (buffers, link transmission rate) to provide for communication between the end systems are reserved for the duration of the communication session between the end systems. e.g. traditional telephone networks guaranteed constant rate Multiplexing in Circuit-Switched NetworksA circuit in a link is implemented with either frequency-division multiplexing (FDM) or time-division multiplexing (TDM). 频分/时分多路复用 1.3.3 A Network of Networksregional ISPs tier-1 ISPs 阅读至P60.","tags":[{"name":"Computer Networking","slug":"Computer-Networking","permalink":"http://dafenghh.github.io/tags/Computer-Networking/"}]},{"title":"Codeforces Round #493 Summary","date":"2018-07-21T14:07:54.000Z","path":"post/96fa61b.html","text":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://dafenghh.github.io/tags/codeforces/"}]},{"title":"CodeChef - SCIENCEF Science Fair 题解","date":"2018-05-09T13:43:01.000Z","path":"post/a5930d20.html","text":"题目大意有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。 大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下： cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）) 司机会选择一条使cost最小的路线行驶。问cost的期望。 solution扩展版旅行商问题。关键是先重构图。压缩至只有S，F跟学生所在点。而这些点间的边权应该定义为原图中不经过别的学生的最短路长度。用$n^2$次dijkstra重构图完成后，就是一个旅行商问题了。之后状态压缩DP解决。 dp1[x][i]表示当前走到第i个点，访问过的点集为x的最小cost。dp2[x]表示访问学生集合为x以及x的超集的最小cost。这就是最终答案了。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll Mod = 1e9+7;ll sum(ll a, ll b) &#123; return (a + b) % Mod;&#125;ll&amp; Add(ll &amp;a, ll b) &#123; return a = sum(a, b);&#125;ll product(ll a, ll b) &#123; return a * b % Mod;&#125;ll&amp; Mul(ll &amp;a, ll b) &#123; return a = product(a, b);&#125;const ll iv = 570000004LL;ll talkative[1 &lt;&lt; 17], ti[17], pi[20], mi[17];int V, E, S, F, n;const int N = 1020;const ll INF = 253432145421354LL;ll sp[20][20], d[N];struct edge&#123; int to; ll cost; edge(int to = 0, ll cost = 0):to(to), cost(cost)&#123;&#125;&#125;;vector&lt;edge&gt; G[N];int studentOnVertex[N];void Mini(ll &amp;a, ll b) &#123; if (b &lt; a) a = b;&#125;typedef pair&lt;ll, int&gt; P;typedef pair&lt;ll, P&gt; Tuple;ll dp[1&lt;&lt;17][20], dp2[1&lt;&lt;17];int main() &#123; scanf(\"%d%d%d%d%d\", &amp;V, &amp;E, &amp;S, &amp;F, &amp;n); S--, F--; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%lld%lld%lld\", pi + i, ti + i, mi + i); pi[i]--; &#125; for (int i = 0; i &lt; E; i++) &#123; int x,y,w; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); --x,--y; G[x].push_back(edge(y, w)); G[y].push_back(edge(x, w)); &#125; talkative[0] = 1; for (int x = 0; x &lt; (1 &lt;&lt; n); x++) &#123; for (int i = 0; i &lt; n; i++) &#123; if ((x &amp; (1 &lt;&lt; i)) == 0) &#123; talkative[x|(1&lt;&lt;i)] = product(talkative[x], ti[i]); &#125; &#125; &#125; memset(studentOnVertex, -1, sizeof studentOnVertex); for (int i = 0; i &lt; n; i++) &#123; studentOnVertex[pi[i]] = i; &#125; pi[n] = S; pi[n + 1] = F; for (int s = 0; s &lt;= n + 1; s++) for (int t = s + 1; t &lt;= n + 1; t++) &#123; fill(d, d + V, INF); d[pi[s]] = 0; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; que.push(P(0, pi[s])); while (!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second; if (p.first &gt; d[v]) continue; for (auto e: G[v]) &#123; int u = e.to; ll cost = e.cost; int stui = studentOnVertex[u]; if (stui != -1 &amp;&amp; stui != s &amp;&amp; stui != t) continue; if (d[u] &gt; d[v] + cost) &#123; d[u] = d[v] + cost; que.push(P(d[u], u)); &#125; &#125; &#125; sp[s][t] = sp[t][s] = d[pi[t]]; &#125; for (int x = 0; x &lt; (1 &lt;&lt; n); x++) for (int i = 0; i &lt;= n; i++) dp[x][i] = INF; dp[0][n] = 0; priority_queue&lt;Tuple, vector&lt;Tuple&gt;, greater&lt;Tuple&gt; &gt; que; que.push(Tuple(0, P(0,n))); while (!que.empty()) &#123; Tuple tup = que.top(); que.pop(); int x = tup.second.first, i = tup.second.second; if (tup.first &gt; dp[x][i]) continue; for (int j = 0; j &lt; n; j++) &#123; if (j == i) continue; int nx = x | (1 &lt;&lt; j); if (dp[nx][j] &gt; dp[x][i] + sp[i][j]) &#123; dp[nx][j] = dp[x][i] + sp[i][j]; que.push(Tuple(dp[nx][j], P(nx,j))); &#125; &#125; &#125; for (int x = 1; x &lt; (1 &lt;&lt; n); x++) &#123; dp2[x] = INF; for (int i = 0; i &lt; n; i++) &#123; if (x &amp; (1 &lt;&lt; i)) Mini(dp2[x], dp[x][i] + sp[i][n+1]); &#125; dp2[x] += talkative[x]; &#125; for (int x = (1 &lt;&lt; n) - 1; x &gt; 0; x--) &#123; for (int i = 0; i &lt; n; i++) Mini(dp2[x], dp2[x|(1&lt;&lt;i)]); &#125; ll ans = 0; for (int x = 1; x &lt; (1 &lt;&lt; n); x++) &#123; ll temp = 1; for (int i = 0; i &lt; n; i++) &#123; if (x &amp; (1 &lt;&lt; i)) &#123; Mul(temp, mi[i]); &#125; else &#123; Mul(temp, 100 - mi[i]); &#125; Mul(temp, iv); &#125; Mul(temp, dp2[x]); Add(ans, temp); &#125; printf(\"%lld\\n\", ans);&#125;","tags":[{"name":"DP","slug":"DP","permalink":"http://dafenghh.github.io/tags/DP/"},{"name":"shortest path","slug":"shortest-path","permalink":"http://dafenghh.github.io/tags/shortest-path/"},{"name":"graph","slug":"graph","permalink":"http://dafenghh.github.io/tags/graph/"}]},{"title":"CodeChef - GENPERM Generating A Permutation 题解","date":"2018-05-09T13:15:57.000Z","path":"post/75299267.html","text":"题目大意对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, p3) + … + max(pN-1, pN) 给出N，K。构造排列P， 使f(P) = K. 如果不存在，就输出-1. solutionf(P)的值是N-1个数的和。而原排列中的数，最多贡献两次答案。 考虑排列是正序时，f(P)取到最小值，为2+3+…+N。也即2到N的数，每个数贡献1次。最大值应该是在最大的那些数都贡献2次时取到。 怎么让最大那个数贡献2次？只需要不把它放两端就可以了。 另外注意到，一个大的数a多贡献一次的同时，就会剥夺另外一个较小的数b的贡献机会，这时候就会使答案增加a-b. 所以这道题的构造方法就是，设a为下一个贡献多一次的数，b为下一个被剥夺贡献机会的数。考虑当前的和，如果加上b-a比答案大，我们就让b大一些，直到满足条件。然后把刚刚考虑过的b依次append到答案数组，再append a就行。 source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10;typedef long long ll;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; ll k; int n; scanf(\"%d%lld\", &amp;n, &amp;k); if (n == 1) &#123; if (k == 0) &#123; printf(\"1\\n\"); &#125; else &#123; printf(\"-1\\n\"); &#125; continue; &#125; ll x = 0; for (int i = 2; i &lt;= n; i++) x += i; if (k &lt; x) &#123; printf(\"-1\\n\"); continue; &#125; int l = 1, r = n; vector&lt;int&gt; vec; while (l + 1 &lt; r) &#123; if (x + r - l - 1 &lt;= k) &#123; x += r - l - 1; vec.push_back(l++); vec.push_back(r--); &#125; else &#123; vec.push_back(l++); &#125; &#125; for (int i = l; i &lt;= r; i++) vec.push_back(i); if (x != k || vec.size() != n) &#123; printf(\"-1\\n\"); continue; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(\"%d%c\", vec[i], \" \\n\"[i==n-1]); &#125; &#125;&#125;","tags":[{"name":"constructive algorithms","slug":"constructive-algorithms","permalink":"http://dafenghh.github.io/tags/constructive-algorithms/"}]},{"title":"Hello World","date":"2018-05-02T06:38:13.860Z","path":"post/4a17b156.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Codeforces Educational Codeforces Round 43 Summary","date":"2018-05-01T01:57:28.000Z","path":"post/af1c4a82.html","text":"Summary比赛中仅仅做出3道水题。 卡E。E一直想不出。曾有猜测“所有1st type spells全部用于一个creature”，但无法证明，也不敢下定论。没想到这就是正解。 题解E. Well played!题目大意有n个物品，每个物品有两个值hp和dmg. 现有a个第一类道具和b个第二类道具。第一类道具可以使某个物品的hp翻倍，第二类道具可以将某个物品的hp赋值给dmg. 问使用了这些道具后，所有物品dmg和的最大值。 数据范围: $1\\leq n\\leq2\\cdot10^5,0\\leq b\\leq2\\cdot10^5,0\\leq a\\leq 20$ solution下面先证明，最优解一定是全部第一类道具用于同一个物品。分别用x和y表示物品的hp和dmg. 那么如果两个物品同时用了第一类道具，分别用了$a_1$和$a_2$个，它们的总dmg就是$d_1 = {x_1}2^{a_1}+{x_2}2^{a_2}$. 如果将第一类道具全部用于第1个物品，总dmg为$d_2={x_1}2^{a_1+a_2}+\\max(x_2, y_2)$ 假设d1更优，则有$${x_1}2^{a_1}+{x_2}2^{a_2} &gt; {x_1}2^{a_1+a_2}+\\max(x_2, y_2)$$ 移项，有$${x_1}2^{a_1}(2^{a_2}-1) &lt; {x_2}2^{a_2} - \\max(x_2, y_2)$$ 考虑到$\\max(x_2, y_2) \\geq x_2$,则有$${x_1}2^{a_1}(2^{a_2}-1) &lt; {x_2}(2^{a_2}-1)$$ 即$${x_1}2^{a_1}&lt; {x_2}$$ 同理，为了让$d_1$比第一类道具全部用于第2个物品的情况更优，有$${x_2}2^{a_2}&lt; {x_1}$$ 两个不等式矛盾，证毕。 这样一来，就可以O(n)枚举每个物品使用第一类道具的情况。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5+10;struct P &#123; ll h, d; bool used; P(ll h = 0, ll d = 0): h(h), d(d), used(false)&#123;&#125; bool operator &lt; (const P &amp;b) &#123; return h - d &gt; b.h - b.d; &#125;&#125;a[N];void Maxi(ll &amp;a, ll b) &#123; if (b &gt; a) a = b;&#125;int main() &#123; int n, A, b; scanf(\"%d%d%d\", &amp;n, &amp;A, &amp;b); ll k = 1; for (int i = 0; i &lt; A; i++) k &lt;&lt;= 1; for (int i = 0; i &lt; n; i++) &#123; int h,d; scanf(\"%d%d\", &amp;h, &amp;d); a[i] = P(h, d); &#125; sort(a, a + n); ll tot = 0, cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (a[i].h &gt; a[i].d &amp;&amp; cnt &lt; b) &#123; ++cnt; tot += a[i].h; a[i].used = true; &#125; else &#123; tot += a[i].d; &#125; &#125; ll ans = tot; for (int i = 0; i &lt; n; i++) &#123; ll h = a[i].h * k; if (h &lt;= a[i].d) continue; if (a[i].used) &#123; Maxi(ans, tot - a[i].h + h); &#125; else &#123; ll temp = tot - a[i].d + h; if (cnt == b) &#123; temp = temp - a[b - 1].h + a[b - 1].d; &#125; Maxi(ans, temp); &#125; &#125; printf(\"%lld\\n\", ans);&#125;","tags":[{"name":"summary","slug":"summary","permalink":"http://dafenghh.github.io/tags/summary/"},{"name":"codeforces","slug":"codeforces","permalink":"http://dafenghh.github.io/tags/codeforces/"},{"name":"greedy","slug":"greedy","permalink":"http://dafenghh.github.io/tags/greedy/"}]},{"title":"2018.04.22 Kharagpur Regional 2017 集训总结","date":"2018-04-29T12:13:01.000Z","path":"post/9ffddd26.html","text":"Summary赛中通过3题，FDK. F是暴力水题，D和K一共7记罚时，做得不好。D的错误是考虑错了复杂度，所以超时，加上输出%lld写成%d（经典错误）。K的错误是思考不谨慎，连边时加了一个多余的判断条件。 赛后没把H想出来。已经想得差不多，不过看错数据范围。一直以为要O(n^2)算法，其实是O(n^3). 要是看仔细点说不定就能想出来。（经典DP套路，请把训练指南的DP章节刷一遍，锻炼思维！） 赛后补了AHJ。还差EIB。加油，补完！ A J B E I A Science Fair题目大意有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。 大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下： cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）) 司机会选择一条使cost最小的路线行驶。问cost的期望。 solution扩展版旅行商问题。关键是先重构图。压缩至只有S，F跟学生所在点。而这些点间的边权应该定义为原图中不经过别的学生的最短路长度。用$n^2$次dijkstra重构图完成后，就是一个旅行商问题了。之后状态压缩DP解决。 dp1[x][i]表示当前走到第i个点，访问过的点集为x的最小cost。dp2[x]表示访问学生集合为x以及x的超集的最小cost。这就是最终答案了。 见Science Fair题解 B Black DiscsC Uniform StringsD SAD QueriesE Chef and XOR QueriesF Taxi Making Sharp TurnsG Spam Classification Using Neural NetH Non Overlapping SegmentsI Spanning TreeJ Generating A Permutation题目大意对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, p3) + … + max(pN-1, pN) 给出N，K。构造排列P， 使f(P) = K. 如果不存在，就输出-1. solutionf(P)的值是N-1个数的和。而原排列中的数，最多贡献两次答案。 考虑排列是正序时，f(P)取到最小值，为2+3+…+N。也即2到N的数，每个数贡献1次。最大值应该是在最大的那些数都贡献2次时取到。 怎么让最大那个数贡献2次？只需要不把它放两端就可以了。 另外注意到，一个大的数a多贡献一次的同时，就会剥夺另外一个较小的数b的贡献机会，这时候就会使答案增加a-b. 所以这道题的构造方法就是，设a为下一个贡献多一次的数，b为下一个被剥夺贡献机会的数。考虑当前的和，如果加上b-a比答案大，我们就让b大一些，直到满足条件。然后把刚刚考虑过的b依次append到答案数组，再append a就行。 见Generating A Permutation题解 K Number Game","tags":[{"name":"summary","slug":"summary","permalink":"http://dafenghh.github.io/tags/summary/"}]},{"title":"codeforces gym 101635C [Macarons] 2017-2018 ACM-ICPC, Southwestern European Regional Programming Contest (SWERC 2017) 题解","date":"2018-01-26T07:22:09.000Z","path":"post/9049154c.html","text":"题目大意用1*1或者1*2的小长方形完整覆盖N*M的长方形（不可重叠），问有多少种覆盖方式？ 题目分析行数很少，N &lt;= 8, 列数很多，M &lt;= 10^18 对于每一列，用一个长度为N的二进制串表示它的状态，0表示这一个位置放置着1*1的方块，1表示这一个位置放置着1*2的方块。 构造这样一个转移矩阵，T[i][j]表示状态i的列右边连着状态j的列的时候，有多少种状态j的列是可行的。 然后对矩阵求快速幂即可。 source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9;int get()&#123; char ch; int v,f=0; while (!isdigit(ch=getchar())) if (ch=='-') break; if (ch=='-') f=1;else v=ch-48; while (isdigit(ch=getchar())) v=v*10+ch-48; return f?-v:v;&#125; int n;typedef long long ll;const int maxn =300;ll mat[maxn][maxn], M,sz;int trans(int X, int Y)&#123; int dp[10][2]; dp[0][0]=1, dp[0][1]=0; for (int i = 1, bin = 1; i &lt;= n; i++, bin &lt;&lt;= 1) &#123; int x = ((X &amp; bin) &gt; 0), y = ((Y &amp; bin) &gt; 0); if (y == 1) &#123; dp[i][0] = dp[i-1][1] + (x==0?dp[i-1][0]:0); dp[i][1] = dp[i-1][0]; &#125; else &#123; dp[i][0] = dp[i-1][0]; dp[i][1] = 0; &#125; &#125; return dp[n][0];&#125;long long tmp[maxn][maxn],Map[maxn][maxn];int ksm(ll m[maxn][maxn],ll t,int N)&#123; memcpy(Map,m,sizeof(Map)); t--; while (t)&#123; if (t%2==1)&#123; for (int i=1;i&lt;=N;i++) for (int j=1;j&lt;=N;j++) tmp[i][j]=0;//清空临时数组 for (int i=1;i&lt;=N;i++) for (int k=1;k&lt;=N;k++) if (m[i][k]) for (int j=1;j&lt;=N;j++) tmp[i][j]+=m[i][k]*Map[k][j]%mod,tmp[i][j]%=mod; //矩阵乘法 for (int i=1;i&lt;=N;i++) for (int j=1;j&lt;=N;j++) Map[i][j]=tmp[i][j]; //赋值到原数组 &#125; for (int i=1;i&lt;=N;i++) for (int j=1;j&lt;=N;j++) tmp[i][j]=0;//清空临时数组 for (int i=1;i&lt;=N;i++) for (int k=1;k&lt;=N;k++) if (m[i][k]) for (int j=1;j&lt;=N;j++) tmp[i][j]+=m[i][k]*m[k][j]%mod,tmp[i][j]%=mod; for (int i=1;i&lt;=N;i++) for (int j=1;j&lt;=N;j++) m[i][j]=tmp[i][j]; t&gt;&gt;=1; &#125; ll ans=0; for (int i=1;i&lt;=N;++i) ans=(ans+Map[N][i])%mod; return ans;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; M; sz = (1 &lt;&lt; n); for (int i = 1; i &lt;= sz; i++) for (int j = 1; j &lt;= sz; j++) &#123; mat[i][j] = trans(i-1, j-1); &#125; cout &lt;&lt; ksm(mat,M,sz)&lt;&lt;endl; return 0;&#125;","tags":[]},{"title":"codeforces gym 101635J [Frosting on the Cake] 2017-2018 ACM-ICPC, Southwestern European Regional Programming Contest (SWERC 2017) 题解","date":"2018-01-26T06:32:45.000Z","path":"post/8e378f9.html","text":"题目大意 将一块蛋糕，横切n-1刀，竖切n-1刀。使水平方向上，各块宽度分别为B1, B2…Bn；垂直方向上，各块宽度分别为A1, A2…An. 现在，按从左到右，从上到下的顺序，给每一小块依次循环染色“白 黄 粉”三种颜色。 求出每一种颜色的方块的总面积。 题目分析其实就是一个简单的取余问题。 source code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int get()&#123; char ch; int v,f=0; while (!isdigit(ch=getchar())) if (ch=='-') break; if (ch=='-') f=1;else v=ch-48; while (isdigit(ch=getchar())) v=v*10+ch-48; return f?-v:v;&#125; const int maxn = 100020;typedef long long ll;ll a[maxn], b[maxn];ll am[3],ans[3];int n;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i], am[i%3] += a[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 3; j++) ans[j] += b[i] * (am[((ll)j-(ll)i*n-2+3*(ll)maxn*maxn)%3]); &#125; cout &lt;&lt; ans[0] &lt;&lt;\" \" &lt;&lt; ans[1] &lt;&lt; \" \" &lt;&lt; ans[2] &lt;&lt; endl; return 0;&#125;","tags":[{"name":"implementation","slug":"implementation","permalink":"http://dafenghh.github.io/tags/implementation/"}]},{"title":"codeforces gym 101620L [Lunar Landscape] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解","date":"2018-01-26T05:40:19.000Z","path":"post/96671495.html","text":"题目大意卫星拍下了地面的很多照片。每张照片覆盖了平面的一个正方形区域，这个正方形要么边与坐标轴平行，要么对角线与坐标轴平行，保证中心点和顶点都在坐标整点的位置。 求被覆盖的区域面积。 题目分析如果题目只给出边与坐标轴平行的正方形的话，那这道题很简单，直接二维前缀和就OK。 但这道题有侧着放的正方形（对角线与坐标轴平行），又该怎么处理呢？ 首先发现，一个正方形小格可以按对角线分成4块小三角形，有多少块小三角形被覆盖，则要看侧正方形的分布情况。 如果用一下坐标变换，将坐标系向由旋转45度，再将单位长度设置为小三角形的直角边长。可以求出，这个坐标变换的表达式为：$x’=x-y,y’=x+y$ 旋转坐标系后，将每一个小三角形视为一个元素，然后对这些小三角形用二维前缀和即可。 找出变换后的坐标跟原来坐标的对应关系，本题解答完成。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 1600;int f[2 * N][2 * N], g[8 * N][4 * N];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++)&#123; char s[10]; int x,y,d; scanf(\"%s%d%d%d\",s, &amp;x,&amp;y,&amp;d); d /= 2; if (s[0] == 'A') &#123; f[x-d+N][y-d+N]++; f[x+d+N][y-d+N]--; f[x-d+N][y+d+N]--; f[x+d+N][y+d+N]++; &#125; else &#123; int x0 = x - y, y0 = x + y; x = x0, y = y0; g[2*x-2*d+4*N][y-d+2*N]++; g[2*x+2*d+4*N][y-d+2*N]--; g[2*x-2*d+4*N][y+d+2*N]--; g[2*x+2*d+4*N][y+d+2*N]++; &#125; &#125; for (int i = 0; i &lt; 2 * N; i++) for (int j = 0; j &lt; 2 * N; j++) &#123; if (i &gt; 0) f[i][j] += f[i-1][j]; if (j &gt; 0) f[i][j] += f[i][j-1]; if (i &gt; 0 &amp;&amp; j &gt; 0) f[i][j] -= f[i-1][j-1]; &#125; for (int i = 0; i &lt; 8 * N; i++) for (int j = 0; j &lt; 4 * N; j++) &#123; if (i &gt; 0) g[i][j] += g[i-1][j]; if (j &gt; 0) g[i][j] += g[i][j-1]; if (i &gt; 0 &amp;&amp; j &gt; 0) g[i][j] -= g[i-1][j-1]; &#125; double ans = 0; for (int x = -1510; x &lt; 1510; x++) for (int y = -1510; y &lt; 1510; y++) &#123; if (f[x+N][y+N]) ans++; else &#123; int x0 = x - y, y0 = x + y; if (g[2*x0-1+4*N][y0+1+2*N]) ans += 0.25; if (g[2*x0-1+4*N][y0+2*N]) ans += 0.25; if (g[2*x0+4*N][y0+1+2*N]) ans += 0.25; if (g[2*x0+4*N][y0+2*N]) ans += 0.25; &#125; &#125; printf(\"%.2lf\\n\", ans); &#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"codeforces gym 101620H [Hidden Hierarchy] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解","date":"2018-01-26T05:39:40.000Z","path":"post/1dd196f0.html","text":"题目大意给出n个文件的路径和大小，然后要像Windows资源管理器的侧边栏那样输出文件夹的分层结构。当一个文件夹里的所有子文件夹大小都不超过t时，它会折叠起来。 题目分析模拟题，集训的时候打崩了。关键是建树的过程，将路径拆分成文件夹名的vector，然后利用这个vector创建这个路径上的所有文件夹的结点。 所有结点按创建次序保存在数组中，每一个结点包含一个map, 存放它的子节点，“文件夹名”到结点位置的映射。 这样一来，这道题就很好写了。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct dir&#123; string name; int sz; map&lt;string, int&gt; subdir;&#125;a[60000];int tot = 0, t;void addFile(vector&lt;string&gt; &amp;path, int pi, int sz, int ai) &#123; a[ai].sz += sz; if (pi &gt;= path.size()) return; if (!a[ai].subdir.count(path[pi])) &#123; a[++tot].name = path[pi]; a[ai].subdir[path[pi]] = tot; &#125; addFile(path, pi + 1, sz, a[ai].subdir[path[pi]]);&#125;bool canFold(int ai) &#123; for (auto i:a[ai].subdir) if (a[i.second].sz &gt;= t) return false; return true;&#125;void printDir(int ai = 0, string ps = \"\") &#123; ps += a[ai].name + \"/\"; if (a[ai].subdir.empty()) &#123; printf(\" %s %d\\n\", ps.c_str(), a[ai].sz); &#125; else if (canFold(ai)) &#123; printf(\"+ %s %d\\n\", ps.c_str(), a[ai].sz); &#125; else &#123; printf(\"- %s %d\\n\", ps.c_str(), a[ai].sz); for (auto i:a[ai].subdir) printDir(i.second,ps); &#125;&#125;char str[1024];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; int sz; scanf(\"%s%d\", str, &amp;sz); vector&lt;string&gt; path; string buf; int len = strlen(str); for (int i = 1; i &lt; len; i++) &#123; if (str[i] == '/') path.push_back(buf),buf.clear(); else buf += string(1, str[i]); &#125; addFile(path, 0, sz, 0); &#125; scanf(\"%d\", &amp;t); printDir();&#125;","tags":[{"name":"dfs and similar","slug":"dfs-and-similar","permalink":"http://dafenghh.github.io/tags/dfs-and-similar/"},{"name":"tree","slug":"tree","permalink":"http://dafenghh.github.io/tags/tree/"}]},{"title":"NWERC 2017 H [High Score] (The 2017 Northwestern Europe Regional Contest) 题解","date":"2018-01-24T02:34:18.000Z","path":"post/54cee541.html","text":"题目大意题目链接 （可能需要翻墙） 给定a,b,c, 定义 $score = a^2 + b^2 + c^2+7\\cdot \\min(a,b,c)$ 现在给出一个d，要将d拆成三份作为a，b，c的增量，即赋值a += d1, b += d2, c += d3, 满足d1, d2, d3 &gt;= 0, d1 + d2 + d3 = d 求score的最大值。 题目分析注意到加上d后，前面平方项的增量是O(d^2)级别，后面min(a,b,c)这项是O(d)级别，所以当d比较大时，把d全部加给a b c中的最大值即可；d比较小时，暴力一一验证即可。 source code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123;trueint n;truecin&gt;&gt;n;truefor (int i=1;i&lt;=n;++i)&#123;truetruell a,b,c,d;truetruecin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;truetruell sz0 = 4, sz1 = 10;truetrueif (a &lt; sz0 &amp;&amp; b &lt; sz0 &amp;&amp; c &lt; sz0 &amp;&amp; d &lt; sz1) &#123;truetruetruell ans = a*a+b*b+c*c+7*min(a,min(b,c));truetruetruefor (ll d1 = 0; d1 &lt;= d; d1++)truetruetruefor (ll d2 = 0, d3 = d - d1 - d2; d2 &lt;= d &amp;&amp; d3 &gt;= 0; d2++, d3 = d - d1 - d2) &#123;truetruetruetrueans = max(ans, (a+d1)*(a+d1)+(b+d2)*(b+d2)+(c+d3)*(c+d3)+7*min(a+d1, min(b+d2,c+d3)));truetruetrue&#125;truetruetruecout &lt;&lt; ans &lt;&lt; endl;truetruetruecontinue;truetrue&#125;truetruell mat=max(max(a,b),c);truetruell t1=ll(a+d)*(a+d)+(ll)b*b+(ll)c*c+ll(7)*min(min(a+d,b),c);truetruell t2=ll(a)*a+ll(b+d)*(b+d)+(ll)c*c+ll(7)*min(min(a,b+d),c);truetruell t3=ll(a)*a+ll(b)*b+ll(c+d)*(c+d)+ll(7)*min(min(a,b),c+d);truetruecout&lt;&lt;max(t1,max(t2,t3))&lt;&lt;endl;true&#125;truereturn 0;&#125;","tags":[]},{"title":"codeforces gym 101630B [Box] 2017-2018 ACM-ICPC, Northern Eurasia (Northeastern European Regional) Contest (NEERC 17) 题解","date":"2018-01-23T12:47:49.000Z","path":"post/5f7aa68.html","text":"题目大意给定一张w*h大小的纸片，要求裁剪出一个a*b*c的长方体的展开图，问是否可行。 题目分析长方体展开图共有11种情况，分别算出每种情况所需要的长宽，然后枚举验证即可。 P.S. 小学奥数题的升级版。一开始用蛮力想象展开图平起来后的边的情况。但毕竟自己的空间想象能力并不是很强，而且这样很费时，所以并不是好的做法。其实只要在展开图中根据相邻关系标上边的长度即可。 P.S. opentrain的测试数据很弱，集训时1A。回来交CF，WA了第40个点。改了一个小时后，WA第55个点。原来自己的next_permutation用在了原边长数组上，犯了一个低级错误。 source code12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int A[3],inx[3]=&#123;0,1,2&#125;;trueint w, h;bool comp(int a, int b) &#123;trueif (a &lt;= w &amp;&amp; b &lt;= h) return true;trueif (b &lt;= w &amp;&amp; a &lt;= h) return true;truereturn false;&#125;int main() &#123;truefor (int i = 0; i &lt; 3; i++) scanf(\"%d\", A + i);truetruescanf(\"%d%d\", &amp;w, &amp;h);truebool find = false;truedo &#123;truetrueint a = A[inx[0]], b= A[inx[1]], c = A[inx[2]];truetrueif (comp(2*(a+c), b + 2 * c)||truetruetruecomp(3*b+a+c,a+c)|| truetruetruecomp(a+b+c,a+b+2*c)|| truetruetruecomp(a+b+c,2*b+2*c)||truetruetruecomp(a+2*b+c,a+2*c)) find = true;true&#125;while (!find &amp;&amp; next_permutation(inx, inx + 3));trueputs(find?\"Yes\":\"No\");&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"codeforces gym 101630C [Connections] 2017-2018 ACM-ICPC, Northern Eurasia (Northeastern European Regional) Contest (NEERC 17) 题解","date":"2018-01-23T11:01:49.000Z","path":"post/a35a5595.html","text":"题目大意给定一个强连通的有向图，n个点，m条边；要求，去掉m-2n条边，使剩下的图仍然强连通。 题目分析采用DFS，将需要保留下的边打上记号。然后任意输出m-2n条不需要保留的边即可。 哪些边需要保留呢？ DFS前进的那些边（即搜索树中的边，“实边”）一定要保留，至于虚边，则保留得越少越好。 所以优先从搜索树的靠叶子端取虚边。比如DFS依次经过1-&gt;2-&gt;3-&gt;4, 我们就先从4开始取回去的边，回去得越前越好，即如果同时存在(4,3)和(4,2）就取（4，2）,然后回到结点2，再取一条(2,1)就能构成一个环，也即强连通的子图。 具体实现的话，dfs返回当前访问子树能够回去的最前结点（有点类似tarjan的lowlink）。对一个结点来说，所有虚边只需考虑最优那条（即返回的点index越小越好）。然后拿它跟子树返回结果的最小值（代表子树能够回去的最前结点）比较，如果这条虚边更有，就连上。 P.S. 1A这题，很开心！ source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;using namespace std;int n,m;const int maxn = 100020;vector&lt;int&gt; G[maxn];typedef pair&lt;int, int&gt; P;map&lt;P, int&gt; M;bool used[maxn];int index[maxn], cnt;int dfs(int v) &#123; index[v] = cnt++; used[v] = true; int bv = v, nbi = index[v]; for (auto i: G[v]) &#123; if (!used[i]) &#123; M[P(v,i)] = 1; nbi = min(nbi, dfs(i)); &#125; else if (index[i] &lt; index[bv]) bv = i; &#125; if (index[bv] &lt; nbi) &#123; M[P(v, bv)] = 1; &#125; return min(nbi, index[bv]);&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); M.clear(); cnt = 0; memset(used, 0, sizeof(used)); memset(index, 0, sizeof(index)); for (int i = 1; i &lt;= n; i++) G[i].clear(); for (int i = 0; i &lt; m; i++) &#123; int x,y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); M[P(x,y)] = 0; &#125; dfs(1); int tot = 0; for (auto i: M) &#123; if (!i.second) &#123; tot++; printf(\"%d %d\\n\", i.first.first, i.first.second); if (tot == m - 2 * n) break; &#125; &#125; &#125;&#125;","tags":[{"name":"graphs","slug":"graphs","permalink":"http://dafenghh.github.io/tags/graphs/"},{"name":"dfs and similar","slug":"dfs-and-similar","permalink":"http://dafenghh.github.io/tags/dfs-and-similar/"}]},{"title":"POJ 3470 [Walls] 题解","date":"2018-01-22T15:11:51.000Z","path":"post/7d2ff651.html","text":"题目大意平面上有n条与坐标轴平行的互不相交的线段，代表墙；还有m个不在线段上的点，代表鸟。鸟会沿着坐标轴方向，飞向离它最近的墙，并撞上去。求每一面墙会有多少只鸟撞上来。 题目分析先离散化坐标。 按其中一个坐标（比如y）排好序后，使用扫描线算法，对于另一个坐标（比如x）建一棵支持区间更新和单点查询的线段树，表示每一个点当前会撞向的墙的序号。 自己写的扫描线啰嗦地惨不忍睹，WA很多次都没过。 参考了下forever97 的代码，非常简洁优雅，落落大方。真是感激不尽！ source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int maxn = 200020;int tr[maxn * 2];int query(int x, int v = 0, int l = 0, int r = maxn - 20) &#123; if(tr[v] != -2) return tr[v]; if (l + 1 == r) return tr[v]; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; if (x &lt; mid) return query(x, chl, l, mid); return query(x,chr,mid, r);&#125;void update(int L, int R, int val, int v = 0, int l = 0, int r = maxn - 20) &#123; if (r &lt;= L || R &lt;= l) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; tr[v] = val; return; &#125; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; if (tr[v] != -2) &#123; tr[chl] = tr[chr] = tr[v]; tr[v] = -2; &#125; update(L, R, val, chl, l, mid); update(L, R, val, chr, mid, r); &#125;int X[maxn], Y[maxn], X_inx[maxn], Y_inx[maxn],X_comp[maxn], Y_comp[maxn], wall_to_fly[maxn], total_for_wall[maxn],dis[maxn];int *arr;int wn,pn; // wall pointbool cmp(int a, int b) &#123; return arr[a] &lt; arr[b];&#125;void compress(int *X, int *Comp,int *Inx, int n=pn) &#123; arr = X; for (int i = 0; i &lt; n; i++) Inx[i] = i; sort(Inx, Inx + n, cmp); int cnt = 0;Comp[Inx[0]] = 0; for (int i = 1; i &lt; n; i++) &#123; if (X[Inx[i]] != X[Inx[i-1]]) cnt++; Comp[Inx[i]] = cnt; &#125;&#125;void scan(int *X, int *Y, int *X_comp, int i) &#123; if (i &lt; wn) &#123; int i_ = i^1; if (X_comp[i_] &gt;= X_comp[i]) &#123; update(X_comp[i], X_comp[i_]+1,i/2); &#125; &#125;else &#123; int q = query(X_comp[i]); if (q != -1) &#123; int d = min(abs(Y[i] - Y[2*q]), abs(Y[i] - Y[2*q+1])); i-=wn; if (dis[i] == -1 || d &lt; dis[i]) &#123; dis[i] = d; wall_to_fly[i] = q; &#125; &#125; &#125;&#125;void fly(int *X, int *Y, int *X_comp, int *Inx) &#123; tr[0] = -1; for (int i = 0; i &lt; pn; i++) scan(X, Y, X_comp, Inx[i]); tr[0] = -1; for (int i = pn; i &gt;= 0; i--) scan(X, Y, X_comp, Inx[i]);&#125;int main() &#123; memset(dis, -1, sizeof(dis)); int n_, m_; scanf(\"%d%d\", &amp;n_, &amp;m_); wn = 2 * n_; pn = wn + m_; for (int i = 0; i &lt; pn; i++) scanf(\"%d%d\", X + i, Y + i); compress(X, X_comp, X_inx); compress(Y, Y_comp, Y_inx); fly(X, Y, X_comp, Y_inx); fly(Y, X, Y_comp, X_inx); for (int i = 0; i &lt; m_; i++) total_for_wall[wall_to_fly[i]]++; for (int i = 0; i &lt; n_; i++) printf(\"%d\\n\", total_for_wall[i]);&#125;","tags":[{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"scanline","slug":"scanline","permalink":"http://dafenghh.github.io/tags/scanline/"}]},{"title":"NWERC 2017 A [Ascending Photo] (The 2017 Northwestern Europe Regional Contest) 题解","date":"2018-01-22T15:08:38.000Z","path":"post/7c1f2f41.html","text":"题目大意题目链接 给定一个序列，将它切割成若干段，使得对每一段进行移动之后可以重排成非严格升序。求最少的切割数。 题目分析（集训的时候就差DP这步没想出来。） 首先先将相邻的相同元素合并，并进行离散化（不影响答案）。 然后现在将数组的每一个元素都切开（即切n-1下），比如1|2|3|0|4 于是问题可以转化为，这n-1块“挡板”最多有多少块可以去掉，如果为s，那么最终答案就是n-1-s. 在上面的例子中，唯一能够去掉的挡板是(2,3), 即变成1|2 3|0|4 很显然，挡板能够去掉首先要满足，左右两个元素相差1. 另外，假如有多块(2,3)挡板，比如对于1|2|3|4|2|3 (2,3)的挡板只能去掉其中一块（不然装不回来）。所以，我们可以先将所有值出现的位置保存到vector中，然后从小到大考虑值，每两个相邻的值应该去掉哪一块挡板（有可能去不掉）。 另外，如果去掉前面的(2,3)挡板，这时候会发现，紧接着后面的(3,4)挡板就去不了了。 否则会变成：1|2 3 4|2|3 可以看到最右边的3落下了。 所以可以看到，去掉一个挡板有可能会产生一个冲突位置。具体地说，如果存在连续序列(a,a+1,a+2), 并且a+1在数组中不唯一，那么去掉(a,a+1)挡板将会导致(a+1,a+2）的挡板无法去除。 用dp[i]表示去除值(0,1)到值(i,i+1)的所有可去除的挡板数量。 注意到，dp[i]的值与每一步去除哪一块可选挡板有关，所以要加多一维。dp[i][j]的j表示，去除值(i,i+1)的挡板时，考虑的是位置(j,j+1) 即首先i和j有条件，h[j] = i, h[j+1] = i+1 dp[i][j] = max(dp[i-1][j&#39;] + （j是不是j&#39;产生的冲突位置?0:1）) “j是不是j’产生的冲突位置” 等价于j = j&#39; + 1 &amp;&amp; h[j]不唯一 从这个条件可以看出，对于一个j’，最多产生一个冲突位置，j’+1(当h[j’+1]唯一就不是冲突位置）。 对于一个j，只可能是一个位置j’ = j - 1的冲突位置。（条件*） 如果我们把dp[i]看成一张表，那么最后我们求的就是dp[n]的最大值。 观察转移方程，从dp[i]向dp[i+1]转移的时候，求max的是dp[i]这张表的所有元素，但其中有些元素加了1（条件j不是j’的冲突位置）。 所以，我们只需保存这张表最大的那些值就行了。比如某个dp[i]={1,2,3,4,5,5,5}, 我们只需要保存{5,5,5}就行，因为前面的数，比如4，加上1也才是5，并不会更优。 dp[i+1]的值有可能是5，也有可能是6，要看三个5之中，有没有一个5对应的冲突位置不是j，这个5就能加上1，变成6. 回顾条件*，当我们保存了两个dp值最大的j’对应的冲突位置时，那么求 dp[i][j] 就能一定找到一个不冲突的位置，然后累计加上1. 所以，每一步dp求出的表中，只需要保存最大两个值以及它们对应的冲突位置即可，下面代码，用best[0]和best[1]保存最大两个值以及对应的冲突位置。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int get()&#123;truechar ch; int v=0,f=0;truewhile (!isdigit(ch=getchar())) if (ch=='-') break;trueif (ch=='-') f=1;else v=ch-48;truewhile (isdigit(ch=getchar())) v=v*10+ch-48;truereturn f?-v:v;&#125; typedef pair&lt;int, int&gt; P;const int maxn = 1000020;int b[maxn];int main() &#123; vector&lt;int&gt; H; int n = get(); for (int i = 0; i &lt; n; i++) &#123; int x = get(); if (H.empty() || H.back() != x) H.push_back(x); &#125; n = (int)H.size(); for (int i = 0; i &lt; n; i++) b[i] = H[i]; sort(b, b + n); int sz = unique(b, b + n) - b; vector&lt;vector&lt;int&gt; &gt; posi(sz); for (int i = 0; i &lt; n; i++) H[i] = lower_bound(b, b + sz, H[i]) - b, posi[H[i]].push_back(i); P best[2] = &#123;P(0, n), P(0, n)&#125;; for (int h = 0; h &lt; sz - 1; h++) &#123; P nbest[2] = &#123;best[0], best[1]&#125;; for (int i = 0; i &lt; posi[h].size(); i++) &#123; int p = posi[h][i]; if (p == n - 1 || H[p] + 1 != H[p + 1]) continue; P s(0, n); if (p != best[0].second) s = best[0]; else s = best[1]; s.first++, s.second = p + 1; if (posi[h + 1].size() == 1) s.second = n; if (s &gt; nbest[0]) nbest[1] = nbest[0], nbest[0] = s; else if (s &gt; nbest[1]) nbest[1] = s; &#125; best[0] = nbest[0], best[1] = nbest[1]; &#125; printf(\"%d\\n\", n - 1 - best[0].first); &#125;","tags":[{"name":"dp","slug":"dp","permalink":"http://dafenghh.github.io/tags/dp/"}]},{"title":"codeforces gym 101620D [Donut Drone] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解","date":"2018-01-21T12:41:28.000Z","path":"post/a74fadaa.html","text":"题目大意一个矩形方块，有r*c个格子，水平和垂直方向上都可以将它视为首尾相连的（也即从最右边向右移会回到最左边，从最下边向下移会回来最上边，以此类推）。每个格子上有一个数。每一次移动会往相邻的右边、右上、右下的三个格子中选最大数的格子移动。初始位置在左上角。两种操作：1. 移动k步，输出新位置；2.修改某个格子的数。 数据范围：r，c $\\leq$ 2000, 询问数5000以内。 题目分析移动k步时，列数的增量是确定的（k），行数未知，由二维数组确定。 可以很自然地想到用线段树解决这个问题。线段树的每一个结点，维护的是一张从第l列到第r列, 即[L,r)，行数y的转移表（本来行数应该用x来表示，但是一开始敲时就弄混了，所以后面只好交换了x和y的定义）。 这样，当我们从第y行第x列出发时，若k比较小直接模拟。k比较大时，先查询线段树，拿到y在[x, c)的转移值y’。这样就回到了(y’,0) 即第一列。 然后一次走c步，即采用[0,c)的转移表，意思就是从第一列一直往右走，知道走回第一列。不断重复这个过程，每一次可以使步数+c。 理论上这么模拟可以使单次询问的复杂度达到O(k/c*log c); 但考虑到行数只有r个，所以只会产生长度不超过r的环。所以把经过的点记录一下，产生环即跳出。这样复杂度可以优化至O(r*log c). source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 2010;const int INF = 1234567890;int dat[4 * maxn][maxn], row, col , a[maxn][maxn], NY[maxn][maxn],circle[maxn],posi[maxn];int query(int y, int x1, int x2, int v = 0, int l = 0, int r = col) &#123; // [l, r) if (x2 &lt;= l || r &lt;= x1) return y; if (x1 &lt;= l &amp;&amp; r &lt;= x2) return dat[v][y]; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; int LAns = query(y, x1, x2, chl, l, mid); return query(LAns, x1, x2, chr, mid, r);&#125;void update(int x, int y, int val, int v = 0, int l = 0, int r = col) &#123; if (x &lt; l || x &gt;= r) return; if (l + 1 == r) &#123; dat[v][y] = val; return; &#125; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; update(x, y, val, chl, l, mid); update(x, y, val, chr, mid, r); for (int i = 0; i &lt; row; i++) dat[v][i] = dat[chr][dat[chl][i]];&#125;void build(int v = 0, int l = 0, int r = col) &#123; if (l + 1 == r) &#123; for (int i = 0; i &lt; row; i++) dat[v][i] = NY[l][i]; return; &#125; int mid = (l + r) &gt;&gt; 1, chl = v * 2 + 1, chr = v * 2 + 2; build(chl, l, mid); build(chr, mid, r); for (int i = 0; i &lt; row; i++) dat[v][i] = dat[chr][dat[chl][i]];&#125;int read()&#123; int v; char ch; while (!isdigit(ch=getchar())); v=ch-48; while (isdigit(ch=getchar())) v=v*10+ch-48; return v;&#125;int getNY(int x, int y) &#123; int nx = (x + 1) % col, Max = -INF, res; for (int dy = -1; dy &lt;= 1; dy++)&#123; int ny = (y + dy + row) % row; if (a[nx][ny] &gt; Max) &#123; Max = a[nx][ny]; res = ny; &#125; &#125; return res;&#125;int main() &#123; row = read(), col = read(); for (int i = 0; i &lt; row; i++) for (int j = 0; j &lt; col; j++) a[j][i] = read(); for (int i = 0; i &lt; row; i++) for (int j = 0; j &lt; col; j++) NY[j][i] = getNY(j, i); build(); int m = read(); int y = 0, x = 0; while (m--) &#123; char s[10]; scanf(\"%s\",s); if (s[0] == 'm') &#123; int k = read(); if (k &gt; col) &#123; if (x != 0) k-= col-x, y = query(y,x,col),x=0; memset(posi, -1, sizeof(posi)); circle[0] = y; posi[y] = 0; int ci = k / col; k -= ci * col; for (int i = 1; i &lt;= ci; i++) &#123; circle[i] = y = query(y, 0, col); if (posi[y] != -1) &#123; int len = i - posi[y]; y = circle[posi[y] + (ci - posi[y]) % len]; break; &#125; posi[y] = i; &#125; if (k &gt; 0) y = query(y, 0, k); x = k; &#125; else &#123; for (int i = 0; i &lt; k; i++)&#123; y = NY[x][y];x = (x + 1) % col; &#125; &#125; printf(\"%d %d\\n\", y + 1, x + 1); &#125; else &#123; int cy = read() - 1, cx = read() - 1, val = read(); a[cx][cy] = val; int px = (cx + col - 1) % col; for (int dy = -1; dy &lt;= 1; dy++) &#123; int py = (cy + dy + row) % row; int temp = getNY(px, py); if (NY[px][py] != temp) &#123; NY[px][py] = temp; update(px, py, temp); &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"}]},{"title":"HDU 5249 [KPI] 题解","date":"2018-01-17T07:59:57.000Z","path":"post/a54ea176.html","text":"题目大意n次操作，有3种操作的类型：入队、出队、查询队列中的中位数。 题目分析区间第K大的简单版本。用权值线段树可以轻松解决。这里尝试使用一下树状数组。这里搞明白树状数组的原理后，findK函数可以写得很清晰。 稍微解释一下findK函数，从x=1&lt;&lt;16（值的上界）开始定位答案，判定bit[]数组的值来定位答案位于权区间的左半部分还是右半部分。反复执行这个过程，逐步缩小区间得到答案。 source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10020;int tot, bit[maxn];void update(int i, int x) &#123; for (; i &lt;= tot; i += i &amp; -i) bit[i] += x;&#125;int findK(int k) &#123; int ans = 0; for (int x = (1 &lt;&lt; 16); x; x &gt;&gt;= 1) &#123; if (ans + x &lt; tot &amp;&amp; bit[ans + x] &lt; k) &#123; k -= bit[ans += x]; &#125; &#125; return ans;&#125;char Q[maxn];int a[maxn], b[maxn], n;void init() &#123; n = 0; memset(bit, 0, sizeof(bit));&#125;int main() &#123; int qn, ti = 0; while (scanf(\"%d\", &amp;qn) != EOF) &#123; init(); ++ti; printf(\"Case #%d:\\n\", ti); for (int i = 0; i &lt; qn; i++) &#123; char s[10]; scanf(\"%s\", s); Q[i] = s[0]; if (Q[i] == 'i') &#123; scanf(\"%d\", &amp;a[n]); b[n] = a[n]; n++; &#125; &#125; sort(b, b + n); tot = n; for (int i = 0; i &lt; n; i++) a[i] = lower_bound(b, b + n, a[i]) - b + 1; int ql = 0, qr = 0; for (int i = 0; i &lt; qn; i++) &#123; if (Q[i] == 'i') &#123; update(a[qr++], 1); &#125; else if (Q[i] == 'o') &#123; update(a[ql++], -1); &#125; else &#123; printf(\"%d\\n\", b[findK((qr - ql + 2)/ 2)]); &#125; &#125; &#125;&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"}]},{"title":"POJ 1201 [Intervals] 题解","date":"2018-01-17T03:18:14.000Z","path":"post/a568ae24.html","text":"题目大意给定n个区间，现在要从每个区间$[a_i, b_i]$中取出$c_i$个数，所有被取出的数组成一个集合。求这个集合的最小size. 题目分析这种区间覆盖问题，首先考虑贪心法。如果将所有顶点按右端点排序后，依次取数。对每一个区间，尽量取靠右边的数。这是一个挺好的贪心策略，容易证明其正确性。 那么，对每个区间，需要做的事情有两步： （统计）统计这个区间上已经被取过的数的数量，如果已满足要求，则OK；否则进行第二步。 （取数）从右往左依次取新数，直到满足要求。 朴素做法，统计这一步就需要O(n)复杂度，总计O(n^2), 显然不可行。 我们可以采用BIT，把统计这一步优化到O(log n）。 但第二步，取数的复杂度呢？ 直觉来看，最坏情况下，每次取数要O(n)的时间，那么总体是O（n^2）复杂度。 但是，考虑到区间长度有限，也是O(n)的级别，所以实际上达到最坏情况的区间很少；换句话说，需要频繁取数的区间是很少的。（如果一个区间取出了很多数，那么相应的，它之后的重叠区间需要取数的区间个数就会少一些。） 于是，第二步用朴素算法即可。虽然没能估计确切的复杂度，但提交后跑起来很快，94ms就过了。 第二种做法，转化成差分约束问题。 如果用d[i]表示做法一中，BIT的前缀和，那么条件(区间[a,b]中有c个数被取出来)可以表示成不等式d[b]-d[a-1]&gt;=c 有了这个不等关系，就可以很方便的转成差分约束问题了，另外还要加上初始约束：d[i]&lt;=d[i+1]&lt;=d[i]+1 很好理解。 然后求解最短路，即可得到答案。 这道题我们求的是d[Max] - d[Min]的最小值，但是最短路求出来后对应的是一个最大值。 于是我们可以加个负号，求出d[Min] - d[Max]的最大值x，那么-x就是答案。如果一开始将d[Max]赋值为0，那么最后答案就是-d[Min]. 采用经队列优化的Bellmen Ford算法，最坏情况下复杂度仍然为O(VE).但考虑到这题中的图对应了一个规则良好的差分约束系统，很难出现一个极端不均匀的图。所以这种做法耗时仅200ms。 P.S. POJ没有开O2优化，所以用vector表示邻接表，再一次跪了…… source codesolution 1 (贪心+BIT)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int maxn = 50050;int bit[maxn];int lowbit(int i) &#123; return i &amp; -i;&#125;int sum(int i) &#123; int s = 0; for (; i; i -= lowbit(i)) s+= bit[i]; return s;&#125;void add(int i, int x) &#123; for (; i &lt; maxn; i += lowbit(i)) bit[i] += x;&#125;struct node &#123; int l, r, c; bool operator &lt; (const node &amp;b)const &#123; return r &lt; b.r; &#125; &#125;a[maxn];bool used[maxn];int main() &#123; int n = read(); for (int i = 0; i &lt; n; i++) a[i].l = read() + 1, a[i].r = read() + 1, a[i].c = read(); sort(a, a + n); for (int i = 0; i &lt; n; i++) &#123; int need = a[i].c - (sum(a[i].r) - sum(a[i].l - 1)); for (int x = a[i].r; x &gt;= a[i].l &amp;&amp; need &gt; 0; x--) &#123; if (!used[x]) &#123; used[x] = true; add(x, 1); need--; &#125; &#125; &#125; printf(\"%d\\n\", sum(maxn - 1));&#125; solution 2 (差分约束)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int maxn = 50050, INF = 12345634;struct edge&#123; int to, cost, next; edge(int to = 0, int cost = 0, int next = 0):to(to), cost(cost), next(next)&#123;&#125;&#125;a[4 * maxn];int head[maxn], ei = 0;void add_edge(int u, int v, int c) &#123; a[ei] = edge(v, c, head[u]); head[u] = ei++;&#125;bool used[maxn];int d[maxn];void Mini(int &amp;a, int b) &#123; if (b &lt; a) a = b;&#125;void Maxi(int &amp;a, int b) &#123; if (b &gt; a) a = b;&#125;int main() &#123; memset(head, -1, sizeof(head)); int n_ = read(); int L = INF, R = -INF; // [L, R] for (int i = 0; i &lt; n_; i++) &#123; int a = read() + 1, b = read() + 1, c = read(); add_edge(b, a - 1, -c); Mini(L, a - 1); Maxi(R, b); &#125; for (int i = L; i &lt; R; i++) add_edge(i, i + 1, 1), add_edge(i + 1, i, 0); fill(d, d + R + 10, INF); d[R] = 0; queue&lt;int&gt; que; que.push(R); used[R] = true; while (!que.empty())&#123; int v = que.front(); que.pop(); used[v] = false; for (int i = head[v]; i != -1; i = a[i].next) &#123; int to = a[i].to, cost = a[i].cost; if (d[v] + cost &lt; d[to]) &#123; d[to] = d[v] + cost; if (!used[to]) que.push(to), used[to] = true; &#125; &#125; &#125; printf(\"%d\\n\", -d[L]);&#125;","tags":[{"name":"greedy","slug":"greedy","permalink":"http://dafenghh.github.io/tags/greedy/"},{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"graphs","slug":"graphs","permalink":"http://dafenghh.github.io/tags/graphs/"},{"name":"差分约束","slug":"差分约束","permalink":"http://dafenghh.github.io/tags/差分约束/"}]},{"title":"POJ 3368 [Frequent Values] 题解","date":"2018-01-11T01:54:21.000Z","path":"post/c9635eac.html","text":"题目大意给定一个长度为N的单调不下降的数组，M次询问，每次询问原数组区间[i, j]中，出现频数最多的数的频数。 题目分析先使用离散化，然后用lower_bound很方便的求出每一个值在原数组中的始点和终点。（终点可以用下一个值的始点表示） 然后构造一棵值分布的线段树，也就是说这棵线段树的每一个结点维护的是它所对应区间[l, r）中的值的最大的出现频数。 询问区间[i, j]， 先求出a[i], a[j]在[i,j]中的出现频数（用第一步求出的a[i]、a[j]的始点、终点位置很容易得到结果）。 然后往线段树中查询[a[i] + 1, a[j])即可。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;using namespace std;int N, n, Q;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int maxn = 100010;int a[maxn], b[maxn], lt[maxn], tr[maxn * 2];//leftvoid build(int v = 1, int l = 0, int r = n) &#123; // [l, r) if (l + 1 == r) &#123; tr[v] = lt[r] - lt[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1, chl = v * 2, chr = chl + 1; build(chl, l, mid); build(chr, mid, r); tr[v] = max(tr[chl], tr[chr]); &#125;&#125;int query(int L, int R, int v = 1, int l = 0, int r = n) &#123;// query [L, R) if (l &gt;= r || R &lt;= l || r &lt;= L) return -12344; if (L &lt;= l &amp;&amp; r &lt;= R) return tr[v]; int mid = (l + r) &gt;&gt; 1, chl = v * 2, chr = chl + 1; return max(query(L, R, chl, l, mid), query(L, R, chr, mid, r));&#125;void update(int &amp;a, int b) &#123; if (b &gt; a) a = b;&#125;int main() &#123; for(;;) &#123; N = read(); if (!N) break; Q = read(); for (int i = 0; i &lt; N; i++) a[i] = b[i] = read(); n = unique(b, b + N) - b; for (int i = 0; i &lt; N; i++) a[i] = lower_bound(b, b + n, a[i]) - b; for (int i = 0; i &lt; n; i++) lt[i] = lower_bound(a, a + N, i) - a; lt[n] = N; build(); while (Q--) &#123; int l = read(), r = read(); //[l, r] l--; r--; int ans = -1244; if (a[l] == a[r]) ans = r - l + 1; else &#123; update(ans, lt[a[l] + 1] - l); update(ans, r - lt[a[r]] + 1); int L = a[l] + 1, R = a[r]; // [L, R) if (L &lt; R) update(ans, query(L, R)); &#125; printf(\"%d\\n\", ans); &#125; &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"}]},{"title":"POJ 2104 [K-th Number] 题解","date":"2018-01-11T01:51:08.000Z","path":"post/76b5095a.html","text":"题目大意给定一个长度为n的数组，m次查询。每次查询给出三个数（i, j, k），表示要求原数组的区间[i, j]升序排列中的第k个数。 题目分析求区间第k小的经典题目！来源于《挑战程序设计竞赛》P185例题。然后发现，这道题在4个月之前，我学习主席树的时候就做过一次。 书上提供了平方分割和归并树的两种做法，下面我也将重现下这两种解法以及主席树的解法，并在最后对这三种优雅的解法作下对比。 solution 1 (分块)假如题目提供了一个函数cnt(i, j, x)，返回原数组区间[i, j]中小于x的数的个数。那么我们要求的区间[i,j]第k小的数，也就是要求满足cnt(i, j, x) &lt; k的最大的x。 于是，对x进行二分搜索，即可得到答案。 那么，我们怎么样才能自己写出一个类似于cnt(i, j, x)的函数呢？ 假如数组区间[i, j]是有序的，那么我们很容易用lower_bound写出这个函数。 虽然原数组不是有序的，但这么想能够给我们带来灵感。 我们不妨把原数组分成若干块区间，然后对每一块区间进行排序。这就是分块算法。这样，数组在每一块区间内都是有序的。 于是对于要查询的区间[i, j]所包含的那些完整的区间块，我们采用lower_bound算出cnt值。 而区间[i, j]两端有一些元素是不在一个完整区间块的，对这些元素逐一检查即可。（反正这部分元素的个数不超过两倍块的长度，所以数量较少，逐一检查OK） solution 2 (归并树)除了使用分块算法算出函数cnt(i, j, x)的值外，我们还可以采用归并树的做法。 这里的归并树是一种特别的线段树，它完整记录下了归并排序的每一步结果。 也就是，归并树的每一个结点，维护的是一个vector，这个vector就保存着结点对应区间排序后的结果。 于是，建树的过程也就是归并排序的过程，只不过每一步merge的时候，要把中间的结果保存在线段树的结点的vector里。 所以我们计算cnt(i, j, x)的值的时候，用线段树的思想求解即可。 即，若查询区间与当前结点对应区间无交集，返回0；查询区间完整包含当前结点对应区间在内，则对当前结点的vector采用lower_bound返回结果；否则对线段树左右儿子递归查询，求和即可。 solution 3 (主席树)前面两种做法都是采用使数组部分有序后统计cnt值的思想。Solution1 中的部分有序指块数组的部分有序，Solution2中部分有序指线段树维护区间的部分有序。 而主席树的做法采用完全不一样的思路。 主席树也是一种特殊的线段树。它不是像Solution2或者往常RMQ问题一样，维护原数组的区间；而是像维护值域的区间。 就是说，假如这个特殊的线段树的一个结点，维护的区间是[l, r), 记录值为dat，那么dat的意义是原数组中有多少个值位于[l, r)的范围内。 现在考虑，假设我们已经对要查询的区间[i, j]构造了这样一棵线段树，要查询第k小的值，怎么找？ 其实很简单，从根结点找起，其实根结点对应的区间就是整个值域。考察左儿子的dat值，如果它大于等于k，也就是说有大于等于k个数位于左边的值域，于是我们就对左儿子进行递归查找；否则查找右儿子。直到查找的区间长度为1，那么这个就是答案。 那么，假如我们对所有O(n^2)个区间都建这样一棵关于值分布的线段树，我们就能对任意区间，查询到第k小的答案了。 显然，O(n^2)棵线段树是不现实的，根本没有这么多空间。 用一下前缀和的思想，考虑原数组区间[i, j]对应的线段树，其实它可以由[1, j]和[1, i - 1]两棵线段树的值作差而来。（这里的“作差”就是对线段树每一个结点的dat值求一次差） 所以我们实际上，只需要n棵线段树即可，n指值域长度。 但是， O(n)棵线段树仍然不现实，没有这么多空间。 主席树的巧妙之处就在这里。 考察第i棵线段树和第i+1棵线段树的区别，也就是原数组区间[1, i]和[1, i + 1]分别对应的线段树。我们发现，后一棵线段树，比前一棵线段树，仅仅多更新了原数组中的一个数，即a[i+1]. 这样一来，两棵线段树仅仅只有从根到a[i+1]对应的叶这一条链是不同了（增加了1），其他结点完全相同。于是我们，只给这更新的一条链创建新结点可以，其他结点沿用旧的线段树的结点即可。 那么，更新的线段树高度为O(log n)，所以会有O(log n)个结点更新，也就是，这棵线段树实际只占用O(log n)的内存空间，但在逻辑上，它依然是棵完整的线段树。 另外，对于第零棵线段树，即原数组区间[1, 0]对应的线段树，所有结点dat值都为0，所以这整棵线段树用一个零结点来存就可以。 这样一来，我们就能够实现，只用了O(nlogn)的内存空间，存放下了n + 1棵线段树（包括第零棵）的信息，因为很多结点都被多棵线段树共享了嘛。 P.S.其实这种做法与第二种归并树的做法，有异曲同工之妙。归并树是把归并排序的中间结果全部记录下来。而主席树，实际上也是，把更新时的中间结果全部记录下来。对这样一棵表示值分布的线段树，我们依次从左往右拿原数组的值去更新线段树，每一次更新会修改O(log n)个结点，而主席树没有直接修改原树上的O(log n)个结点，而是新建了O(log n)个结点。这样，线段树在动态更新的过程中，每一个历史版本都被完整记录。 source codesolution 1 (分块)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include&lt;cctype&gt;using namespace std;const int maxn = 100002;const int B = 1000;int bucket[maxn / B][B];int a[maxn],nums[maxn];inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;int main() &#123; int n = read(), m = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); bucket[i/B][i%B] = a[i]; nums[i] = a[i]; &#125; sort(nums, nums + n); for (int i = 0; i &lt; n / B; i++) sort(bucket[i], bucket[i] + B); while (m--) &#123; int l = read(), r = read(), k = read(); int ul = 0, ur = n; while (ul + 1 &lt; ur) &#123; int mid = (ul + ur) &gt;&gt; 1; int cnt = 0, tl = l - 1, tr = r; // the number of items less than nums[mid] while (tl &lt; tr &amp;&amp; tl % B) cnt += (a[tl++] &lt; nums[mid]); while (tl &lt; tr &amp;&amp; tr % B) cnt += (a[--tr] &lt; nums[mid]); while (tl &lt; tr) &#123; int bi = tl / B; cnt += lower_bound(bucket[bi], bucket[bi] + B, nums[mid]) - bucket[bi]; tl += B; &#125; if (cnt &gt;= k) ur = mid; else ul = mid; &#125; printf(\"%d\\n\", nums[ul]); &#125; &#125; solution 2 (归并树)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int maxn = 100010;int a[maxn],n,m,nums[maxn];vector&lt;int&gt; vec[maxn * 20];void build(int v = 1, int l = 0, int r = n) &#123; if (l &gt;= r) return; if (l + 1 == r) &#123; vec[v].push_back(a[l]); &#125; else &#123; int mid = (l + r) &gt;&gt; 1, chl = v * 2, chr = v * 2 + 1; build(chl, l, mid); build(chr, mid, r); vec[v].resize(vec[chl].size() + vec[chr].size()); merge(vec[chl].begin(), vec[chl].end(), vec[chr].begin(), vec[chr].end(), vec[v].begin()); &#125;&#125;int query(int L, int R, int x, int v = 1, int l = 0, int r = n) &#123; if (l &gt;= r || r &lt;= L || R &lt;= l) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; int res = lower_bound(vec[v].begin(), vec[v].end(), x) - vec[v].begin(); return res; &#125; int mid = (l + r) &gt;&gt; 1, chl = v * 2, chr = v * 2 + 1; int res= query(L, R, x, chl, l, mid) + query(L, R, x, chr, mid, r); return res;&#125;int main() &#123; n = read(),m = read(); for (int i = 0; i &lt; n; i++) &#123; nums[i] = a[i] = read(); &#125; sort(nums, nums + n); build(); while (m--) &#123; int l = read(), r = read(), k = read(); l--; int ul = 0, ur = n; while (ul + 1 &lt; ur) &#123; int mid = (ul + ur) &gt;&gt; 1; if (query(l, r, nums[mid]) &gt;= k) ur = mid; else ul = mid; &#125; printf(\"%d\\n\", nums[ul]); &#125;&#125; solution 3 (主席树)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;struct node&#123; int l, r, dat; node(int l = 0, int r = 0, int dat = 0):l(l),r(r),dat(dat)&#123;&#125;&#125;T[maxn * 20];int rt[maxn], a[maxn], b[maxn], sz = 0;void update(int &amp;o, int x, int last, int l, int r) &#123; // [l, r) o = ++sz; T[o] = T[last]; T[o].dat++; if (l + 1 &gt;= r) return; int mid = (l + r) &gt;&gt; 1; if (x &lt; mid) update(T[o].l, x, T[last].l, l, mid); else update(T[o].r, x, T[last].r, mid, r);&#125;int query(int t1, int t2, int l, int r, int k) &#123; // [l, r) if (l + 1 &gt;= r) return l; int cnt = T[T[t2].l].dat - T[T[t1].l].dat, mid = (l + r) &gt;&gt; 1; if (cnt &gt;= k) return query(T[t1].l, T[t2].l, l, mid, k); return query(T[t1].r, T[t2].r, mid, r, k - cnt);&#125;int main() &#123; fill(T, T + maxn * 20, node()); fill(rt, rt + maxn, 0); int N = read(), Q = read(); for (int i = 0; i &lt; N; i++) b[i] = a[i] = read(); sort(b, b + N); int n = unique(b, b + N) - b; for (int i = 0; i &lt; N; i++) &#123; a[i] = lower_bound(b, b + n, a[i]) - b; update(rt[i + 1], a[i], rt[i], 0, n); &#125; while (Q--) &#123; int l = read(), r = read(), k = read(); printf(\"%d\\n\", b[query(rt[l - 1], rt[r], 0, n, k)]); &#125;&#125; 总结 Solution Time(ms) Memory(MB) Code Length 分块 11516 1.5 1337 归并树 6344 37.1 1662 主席树 1735 25 1469 最后送上三种解法的耗时，内存占用和代码长度的直观对比。 分块的实现最简单，代码最短，空间开销也最小，但非常慢，濒临超时。实际上，如果不加读入优化的话，那么分块就超时了。可见，非常凶险。 完美复现归并排序的归并树显然内存消耗是最高的，因为采用的是和分块一样的思路，也要有两层的二分查找，所以即使使用了线段树，但总耗时也只是节省了一半不到。 最后一种，主席树的做法，从原理上来讲，最复杂，但同时也最优美。从表中可以看出，时间比归并树快很多，空间开销和代码长度都最小，所以毫无疑问是本题的最佳解法。 P.S. 有同学可以提供比主席树更好的做法吗？感激不禁。（发现自己能在不同解法的对比中学到更多）","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"sqrt decomposition","slug":"sqrt-decomposition","permalink":"http://dafenghh.github.io/tags/sqrt-decomposition/"},{"name":"主席树","slug":"主席树","permalink":"http://dafenghh.github.io/tags/主席树/"}]},{"title":"POJ 2886 [Who gets the Most Candies] 题解","date":"2018-01-10T06:46:27.000Z","path":"post/63c20c7e.html","text":"题目大意N个孩子围一圈玩游戏， 按顺时针从1到N编号，每个孩子手上有张牌，牌上有个非零数字。给定数字K，一开始第K个孩子走出圈。每个出圈的孩子的牌上的数字将决定下一个出圈孩子是谁。若此时出圈孩子的牌的数字为x，正则往顺时针方向数到第x个孩子，负则逆时针方向数到第|x|个孩子，即为下一个要走出圈的孩子。 第i个出圈的孩子将获得F[i]个糖果。F[i]定义为正整数i的因数个数。输出获得糖果最多的孩子的名字和糖果数。若有多个答案，则输取出圈最早的孩子作为答案。 题目分析采用取模的方法很容易算出当前需要出圈的是序列中第几个孩子。但这题难在，如果动态、快速地将一个序列中的一项删除呢？ 不妨不存储实际的序列，而只是用一个BIT（树状数组）来表示每个孩子是否在场。 初始时，1-N的每个点的值都为1，表示每一个孩子都在场。若有一个孩子离场，则将它赋值为0即可。 很容易想到，若编号为i的孩子在场，那么前缀和sum(i)就表示他现在在队伍中的实际位置。 所以采用二分法，就可以快速确定队伍中排在第k位的孩子是谁。 时间复杂度为$O(n\\log^2 n)$ n最大为500000，担心超时。但BIT采用lowbit来算的话，时间节省一半，即带上一个1/2的系数。 那么$0.5\\times 500000 \\times log_2^2 500000 = 8.96 \\times 10^7 $ 所以时间复杂度在可接受的范围内。 另外，算F[i]时直接用素数筛的方法做一遍预处理即可， O(n log n)的复杂度。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 500010;int F[maxn];int n, k;void initF()&#123; for (int i = 1; i &lt; maxn; i++) &#123; for (int j = 1; i * j &lt; maxn; j++) F[i * j]++; &#125;&#125;int bit[maxn];int lowbit(int x) &#123; return x &amp; -x;&#125;int sum(int i) &#123; int s = 0; for (; i; i -= lowbit(i)) s += bit[i]; return s;&#125;void add(int i, int x) &#123; for (; i &lt;= n; i += lowbit(i)) bit[i] += x;&#125;struct kid &#123; int p, id; kid(int p = 0, int id = 0):p(p), id(id) &#123;&#125; bool operator &lt; (const kid &amp;b)const &#123; if (F[p] != F[b.p]) return F[p] &lt; F[b.p]; return p &gt; b.p; &#125;&#125;;priority_queue&lt;kid&gt; que;int cards[maxn];char names[maxn][12];typedef long long ll;ll tr(ll x, ll n) &#123; x += n * 100000000LL; return x % n;&#125;int getP(int k) &#123; int l = 0, r = n; while (l + 1 &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (sum(mid) &lt; k) l = mid; else r = mid; &#125; return r;&#125;int solve(int k, int step, int n) &#123; int ni = getP(k); add(ni, -1); que.push(kid(step, ni)); if (n == 0) return 0; k += -1 + cards[ni]; if (cards[ni] &gt; 0) k--; if (k &lt; 0) k = (int)tr(k, n); k %= n; k++; return k;&#125;void Clear(priority_queue&lt;kid&gt; &amp;que) &#123; priority_queue&lt;kid&gt; q1; swap(q1, que);&#125;int main() &#123; initF(); while (scanf(\"%d%d\", &amp;n, &amp;k) != EOF) &#123; for (int i = 1; i &lt;= n; i++) scanf(\"%s%d\", names[i], cards + i); Clear(que); memset(bit, 0, sizeof(bit)); for (int i = 1; i &lt;= n; i++) add(i, 1); for (int i = 1; i &lt;= n; i++) &#123; k = solve(k, i, n - i); &#125; kid ans = que.top(); printf(\"%s %d\\n\", names[ans.id], F[ans.p]); &#125;&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"}]},{"title":"POJ 2155 [Matrix] 题解","date":"2018-01-09T14:15:40.000Z","path":"post/5eb8db9.html","text":"题目大意一个N*N的布尔矩阵，初始值全为0，T次询问，两种操作： 查询某个点的值 将一个矩形方块的布尔值全部翻转。 题目分析二维BIT的简单题目。一维BIT很容易扩展成二维，直接加多一层循环即可，单次操作复杂度由$O(\\log n)$变成$O(\\log^2 n)$ 区间更新转化为4个端点的更新即可。 由于每个点只有两种状态，所以用异或处理非常方便。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1020;int bit[maxn][maxn], n, q;void init() &#123; memset(bit, 0, sizeof(bit));&#125;int lowbit(int i) &#123; return i &amp; -i;&#125;int sum(int x, int y) &#123; // [1..x, 1..y] int res = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) for (int j = y; j &gt; 0; j -= lowbit(j)) res ^= bit[i][j]; return res;&#125;void add(int x, int y) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= n; j += lowbit(j)) bit[i][j] ^= 1;&#125;void update(int x1, int y1, int x2, int y2) &#123; add(x1, y1); add(x1, y2 + 1); add(x2 + 1, y1); add(x2 + 1, y2 + 1);&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;q); init(); while (q--) &#123; char s[10]; scanf(\"%s\", s); if (s[0] == 'Q') &#123; int x,y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", sum(x, y)); &#125; else &#123; int x1, y1, x2, y2; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); update(x1, y1, x2, y2); &#125; &#125; if (T) printf(\"\\n\"); &#125;&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"}]},{"title":"POJ 3468 [A Simple Problem with Integers] 题解","date":"2018-01-09T09:30:31.000Z","path":"post/8b465320.html","text":"题目大意给出长度为N的数组，Q次询问，每次询问有两种操作： 查询某个区间的和。 将某个区间的数全部加上x。 题目分析要同时支持区间更新和区间查询（求和）两种操作，考虑树状数组。 但我们知道，树状数组只支持区间查询和点更新，或者区间更新和点查询。怎么样才能做到同时更新区间以及对区间求和呢？ 我们先来考察区间更新后，前缀和的增量。记前缀和为S(i)，更新区间[l,r]后前缀和为S’(i). $$\\begin{eqnarray}S’(i)= \\begin{cases} S(i), &amp;ir\\end{cases} \\end{eqnarray} $$ 留意到ir时，增量为常数，像普通BIT那样进行一次点更新即可。 难就难在， $l\\leqslant i\\leqslant r$时，增量是一个关于i的一次函数。 如前面所说，普通BIT进行一次点更新只能导致前缀和增加一个常数。既然如此，我们把上面这个一次函数的增量拆成两项，用两个BIT维护： $$\\Delta S(i)=xi + x(1-l) $$一次项系数为x，常数项为x(1-l)，分别对应BIT1和BIT0的增量值。 这样，记BIT0前缀和为s0，BIT1前缀和为s1，则总的前缀和就是s0 + s1 * x 用前缀和来表示原数组的每一个值，然后区间求和就可转化为左右端点的前缀和差值，即点查询+区间更新的模式。 然后，更新的时候，分别对BIT0和BIT1进行区间更新即可（实质上是更新两个端点）。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;typedef long long ll;const int maxn = 100010;ll bit[2][maxn];int n,q;int lowbit(int x) &#123; return x &amp; -x;&#125;ll sum(int x) &#123; ll s0 = 0, s1 = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) s0 += bit[0][i], s1 += bit[1][i]; return s0 + s1 * x;&#125;void add(int ti, int x, ll val) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) bit[ti][i] += val;&#125;void update(int l, int r, ll val) &#123; // [l, r] add(0, l, val * (1 - l)); add(1, l, val); add(0, r + 1, val * r); add(1, r + 1, -val);&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); update(i, i, x); &#125; while (q--) &#123; char s[10]; int l, r, x; scanf(\"%s%d%d\", s, &amp;l, &amp;r); if(s[0] == 'Q')&#123; printf(\"%lld\\n\", sum(r) - sum(l - 1)); &#125; else &#123; scanf(\"%d\", &amp;x); update(l, r, x); &#125; &#125;&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"}]},{"title":"ZOJ 4003 [Distance] 题解","date":"2018-01-09T05:05:12.000Z","path":"post/6c754de8.html","text":"题目大意定义两个维度为n的向量 $(a_1,a_2,a_3\\dots a_n)$ 和 $(b_1,b_2,b_3\\dots bn)$ 间的距离为 $\\sum {i=1} ^n \\left | a_i - b_i \\right |^p$ 现在给出向量$X = (x_1, x_2, x_3 \\dots x_n)$ 和 $Y = (y_1, y_2, y_3 \\dots y_n)$ 定义子向量（subvector）为原向量的项中连续的一段。从X中取出一个子向量x, 从Y中取出一个子向量y，使得x和y长度相同，x和y的距离小于给定值V。求这样的子向量对(x, y)的个数。 题目分析作一个n*n的矩阵diff[][]，记录X中的每一项到Y中的每一项的距离， 即 diff[i][j] = |X[i] - Y[j]| ^ p 取出这个矩阵的每一条斜线的值，用尺取法统计结果即可。 P.S. 写这题时犯了很多智障错误。如%d写成%p，return res写成return x。 诸如此类。 如何避免这类typo的发生呢？ 这是一个问题。 source code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll Pow(ll x, ll y) &#123; ll res = 1; while (y--) res *= x; return res;&#125;int count(ll a[], int n, ll V) &#123; ll sum = 0; int r = 0, ans = 0; for (int l = 0; l &lt; n; l++) &#123; r = max(r, l); while (r &lt; n &amp;&amp; sum + a[r] &lt;= V) &#123; sum += a[r]; r++; &#125; ans += r - l; if (r &gt; l) sum -= a[l]; &#125; return ans;&#125;const int maxn = 1003;int x[maxn], y[maxn];ll diff[maxn][maxn],diag[maxn];int abs_(int x) &#123; return x &gt; 0 ? x : -x;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n, p; ll V; scanf(\"%d%lld%d\", &amp;n, &amp;V, &amp;p); for (int i = 0; i &lt; n; i++) scanf(\"%d\", x + i); for (int i = 0; i &lt; n; i++) scanf(\"%d\", y + i); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) diff[i][j] = Pow(abs_(x[i] - y[j]), p); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; int di = 0; for (int xi = 0, yi = i; xi &lt; n &amp;&amp; yi &lt; n; xi++, yi++) diag[di++] = diff[xi][yi]; ans += count(diag, di, V); &#125; for (int i = 1; i &lt; n; i++) &#123; int di = 0; for (int xi = i, yi = 0; xi &lt; n &amp;&amp; yi &lt; n; xi++, yi++) diag[di++] = diff[xi][yi]; ans += count(diag, di, V); &#125; printf(\"%d\\n\",ans); &#125;&#125;","tags":[{"name":"尺取法","slug":"尺取法","permalink":"http://dafenghh.github.io/tags/尺取法/"}]},{"title":"POJ 3109 [Inner Vertices] 题解","date":"2018-01-05T08:17:54.000Z","path":"post/c38b5f65.html","text":"题目大意一个无限大的棋盘，给出N个点的坐标，初始时这些点上都放置着黑棋。其他所有点放置着白棋。若一个白棋的上下左右方向上都有黑棋，那么它会被替换成黑棋。求最终黑棋的数量。 题目分析与cf 911G如出一辙的扫描线算法。 将所有点按y坐标排序后（y相同时按x排序），我们可以依次统计，相邻的两个y坐标相同的点之间的白点对答案的贡献。 假设这两个点为(x1, y0) (x2, y0) 那么我们要算的就是${(x, y) | x \\in [x1 + 1, x2 - 1], y = y0}$的范围内有多少个白棋变成了黑棋。 对于此范围中的一个点(xx, yy)，这一个点变成黑棋的充要条件是，(xx, yy)的上方和下方还有别的黑棋。 假设在原黑棋的点集合中，当x = xx时，y的最大、最小值分别为Max, Min。那么上面这个充要条件就可以表示为Min &lt; y &lt; Max. 我们很容易想到，当访问到y = yy的最低点也即(xx, Min)时，给x加上标记（表示此条线x == xx上的点将可能变黑）, 当访问到最高点即(xx, Max)时，给x消除标记（表示此条线x == xx上的点将不再会变黑）。 用BIT快速统计出区间[x1 + 1, x2 - 1]上会变黑的点的数量, 本题完成。 P.S. 这题做得也挺尴尬的，一开始写的扫描线算法还要统计出对每个x、y对应的y、x的极值，然后用很累赘的方法打标记，用了很多次vector，导致TLE。后来把vector全部去掉，全部换成数组才过。 感谢此篇博文by lolicon480 提供的思路！ source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;const ll maxn = 200010;ll cnt = 200020;ll bit[maxn];void Maxi(int &amp;a, int b) &#123; if (b &gt; a) a = b;&#125;ll lowbit(ll x) &#123; return x &amp; -x;&#125;ll sum(ll i) &#123; ll res = 0; for (; i &gt; 0; i -= lowbit(i)) res += bit[i]; return res;&#125;void add(ll i, ll x) &#123; for (; i &lt;= cnt; i += lowbit(i)) bit[i] += x;&#125;struct P &#123; int x, y; P(int x = 0, int y = 0):x(x), y(y) &#123;&#125;&#125;a[maxn];bool cmpx(const P&amp;a, const P&amp;b)&#123; if (a.x != b.x) return a.x &lt; b.x; return a.y &lt; b.y;&#125;bool cmpy(const P&amp;a, const P&amp;b)&#123; if (a.y != b.y) return a.y &lt; b.y; return a.x &lt; b.x;&#125;int mx[maxn];bool sc[maxn]; // scopeint main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); sort(a, a + n, cmpx); int val = 1; for (int i = 0; i &lt; n; i++) &#123; int temp = a[i].x; a[i].x = val; if (temp != a[i + 1].x) val++; &#125; sort(a, a + n, cmpy); val = 1; for (int i = 0; i &lt; n; i++) &#123; int temp = a[i].y; a[i].y = val; if (temp != a[i + 1].y) val++; &#125; for (int i = 0; i &lt; n; i++) Maxi(mx[a[i].x], a[i].y); ll ans = 0; for (int i = 0; i &lt; n - 1; i++) &#123; int x = a[i].x, y = a[i].y, nx = a[i + 1].x, ny = a[i + 1].y; if (!sc[x] &amp;&amp; y &lt; mx[x]) &#123; sc[x] = true; add(x, 1); &#125; if (y == ny &amp;&amp; nx &gt; x + 1) &#123; ans += sum(nx - 1) - sum(x); &#125; if (sc[x] &amp;&amp; y == mx[x]) &#123; sc[x] = false; add(x, -1); &#125; &#125; ans += n; printf(\"%lld\\n\", ans);&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"scanline","slug":"scanline","permalink":"http://dafenghh.github.io/tags/scanline/"}]},{"title":"POJ 1990 [MooFest] 题解","date":"2017-12-30T16:23:57.000Z","path":"post/a0a6f15.html","text":"题目大意N头牛排成一排，现在给出它们的坐标x[i]和听觉阈值v[i]. 两头牛i和j之间谈话的音量为max(v[i], v[j]) * dist(i, j) dist表示两者距离。求所有N*(N-1)对牛谈话音量的总和。 题目分析按v[i]降序排序。然后用BIT求出每一头牛和后面的牛的距离的和即可。（我用了两个BIT，一个维护累计和，一个维护个数） source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 20200;typedef long long ll;int n = 20000;int lowbit(int x) &#123; return x &amp; -x;&#125;ll bit[maxn];ll sum(int i) &#123; ll res = 0; for (; i; i -= lowbit(i)) &#123; res += bit[i]; &#125; return res;&#125;void add(int i, ll x) &#123; for (; i &lt;= n; i += lowbit(i)) &#123; bit[i] += x; &#125;&#125;ll bit2[maxn];ll sum2(int i) &#123; ll res = 0; for (; i; i -= lowbit(i)) &#123; res += bit2[i]; &#125; return res;&#125;void add2(int i, ll x) &#123; for (; i &lt;= n; i += lowbit(i)) &#123; bit2[i] += x; &#125;&#125;struct cow &#123; int v, x; bool operator &lt; (const cow &amp; b) const &#123; return v &gt; b.v; &#125;&#125;a[maxn];int main() &#123; int N; scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) scanf(\"%d%d\", &amp;a[i].v, &amp;a[i].x), add(a[i].x, a[i].x), add2(a[i].x, 1); sort(a, a + N); ll ans = 0; for (int i = 0; i &lt; N - 1; i++) &#123; add(a[i].x, -a[i].x); add2(a[i].x, -1); ll dist_tot = sum2(a[i].x) * a[i].x - sum(a[i].x) + sum(n) - sum(a[i].x) - (sum2(n) - sum2(a[i].x)) * a[i].x; ans += dist_tot * a[i].v; &#125; printf(\"%lld\\n\", ans);&#125;","tags":[{"name":"BIT","slug":"BIT","permalink":"http://dafenghh.github.io/tags/BIT/"},{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"}]},{"title":"codeforces 911G [Mass Change Queries] # educational round 35 题解","date":"2017-12-30T13:20:40.000Z","path":"post/360e2773.html","text":"题目大意给定一个数组a，长度为n，q次操作，每次操作给定四个整数，l,r,x,y表示将[l, r]区间中的值为x元素全部变成y，输出最终数组。 数据范围：n, q &lt;= 200000, a[i], x, y &lt;= 100 题目分析educational round的最后一题，本来以为非常难，看了pannibal 的代码后，非常惊奇。这道题竟能如此简洁优美地解决。于是关掉网页，用自己的代码习惯重打一遍（当然大部分雷同哈哈，毕竟这个解法真的太简洁了）。 总结一下思路： 本题的难点在于每次操作，需要更新[l, r]的整段区间。如果直接更新，复杂度将是O(nq) ，不可接受。 我们采用类似于用前缀和快速查询区间和的思想，讲区间转化为两个端点处理，即在区间开始处l打上一个标记，表示从这里开始，x将被视作y ，再在区间结束后的r+1处打上标记，表示还原x的状态（将x重新视为x）。 或者说，这个修改操作包含两个修改，(1) [l, +inf)区间的x变成y; (2) [r+1, +inf)区间的x变回x. 另外，修改的顺序也是很重要的。我们将所有修改按照点的标记位置存在vector里。见main函数代码: 12vec[l].push_back(Change(t, x, y));vec[r + 1].push_back(Change(t, x, x)); 其中t表示修改的顺序。这样一来，我们相当于将所有修改按点的位置重新排序。这么做有什么好处吗？其实，这就是这道题的关键转化步骤。 作为一个经验尚浅的ACM选手，我对这题的直觉思路是依次考虑每次修改操作，寻找一种快速的更新区间方法。但注意到这道题只需要一个最终的结果，对中间结果并不关心。所以我们可以采用离线做法，不必完全跟从修改的次序来求解。 那么我们采用怎样的求解次序呢？ 按数组下标依次求解最终结果。这也是很自然的思路，假如我们要求a[x]的最终结果，那么所有在x之后的点的更新对a[x]的值毫无影响。所以我们在输入完成后，依次拿出vec[i]的修改操作，来修改[i, +inf)这个区间. 这样在i后移的同时，我们就能依次得到a[i]的最终结果。 下面讨论如果实现每次修改操作。 比如现在我们要把x的值变成y，是不是要找出数组中所有的x，然后依次赋值成y呢？显然时间不允许这么做。 我们只需要存一份转移表（transition table）即可。一开始所有数字无变化，对所有的i， 有T[i] = i。 当我们将x修改成y时，修改T[x] = y; 如果这样一份转移表被构造出来，那么我们要求a[i]的最终结果就很简单了，那就是T[a[i]] 但转移表既随时间（修改次序）变化，也随区间变化，即受两个维度影响，t维度（修改次序）和i维度（数组下标）。留意到，刚刚第2点说到，我们沿着i维度来提交修改。那么不妨，我们固定t维度，或称，保留下t维度的所有状态，即对每一个修改的时刻构造一张转移表。这道题最多200000次查询，也就是200000张转移表。 比如我们在时刻t = 5和t = 6分别做了一次修改，得到两个转移表T_5, T_6, 很明显将T_5, T_6的转移表合并（合并的过程非常简单，相当于函数的组合）,就是这两次修改的最终效果。 我们将所有转移表合并后得到的就是最终结果需要的转移表。而在i维度（数组下标）更新的过程中，我们需要快速地修改某些转移表，并将修改结果合并起来，得到a[i]的最终值。 于是，线段树呼之欲出！线段树的每个叶子结点就代表一个时刻的转移表，它们的父结点就是合并后的转移表。对特定的x，所有修改合并操作都能在O(log n)时间内完成了。合并也只需要一条代码： seg[t][i] = seg[chr][seg[chl][i]] 解法非常简洁优美！ source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = (1 &lt;&lt; 18) - 1;struct Change &#123; int t, x, y; Change(int t, int x, int y):t(t),x(x),y(y)&#123;&#125;&#125;;vector&lt;Change&gt; vec[maxn];int a[maxn], seg[maxn * 2 + 20][101];void printAll(int n) &#123; for (int i = 1; i &lt;= n; i++) printf(\"%d%c\", seg[1][i], \" \\n\"[i == n]);&#125;void update(int t, int x, int y) &#123; seg[t += maxn][x] = y; for (t &gt;&gt;= 1; t; t &gt;&gt;= 1) &#123; int chl = t &lt;&lt; 1, chr = chl | 1; for (int i = 1; i &lt;= 100; i++) &#123; seg[t][i] = seg[chr][seg[chl][i]]; &#125; &#125;&#125;void init() &#123; for (int t = 1; t &lt; maxn * 2 + 20; t++) for (int i = 1; i &lt;= 100; i++) seg[t][i] = i;&#125;inline int get() &#123; int ans=0,flag=1; char c=getchar(); while(c&lt;'0' || c&gt;'9')&#123; if(c=='-') flag=-1; c=getchar(); &#125; while(c&gt;='0' &amp;&amp; c&lt;='9')&#123; ans=ans*10+(int)(c-'0'); c=getchar(); &#125; return ans*flag;&#125;int main() &#123; int n = get(), q; for (int i = 1; i &lt;= n; i++) a[i] = get(); q = get(); for (int t = 1; t &lt;= q; t++) &#123; int l = get(), r = get(), x = get(), y = get(); if (x != y) &#123; vec[l].push_back(Change(t, x, y)); vec[r + 1].push_back(Change(t, x, x)); &#125; &#125; init(); for (int i = 1; i &lt;= n; i++) &#123; for (auto cg: vec[i]) update(cg.t, cg.x, cg.y); printf(\"%d%c\", seg[1][a[i]], \" \\n\"[i == n]); &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"scanline","slug":"scanline","permalink":"http://dafenghh.github.io/tags/scanline/"}]},{"title":"codeforces 908F [New Year and Rainbow Roads] (good bye 2017) 题解","date":"2017-12-30T07:05:48.000Z","path":"post/8234636.html","text":"题目大意给定一维直线上的N个点，每个点有一个颜色标记（红、绿、蓝），现在要连边，一条边的代价为两点距离。现求最小总代价，使红、绿点连通，并且蓝、绿点连通。 题目分析考虑到，红、蓝点连线并无意义，所以可忽略；另外考虑假如出现了连续三个点，颜色分别为红绿红，那么红和红之间连线一定不必红-绿-红这样连线优。所以，以绿点为分割点，分成若干个区间单独考虑即可。 对于两个连续的绿点之间的区间，有两种连线方式：（1）连接两个绿点，再以从这两个绿点为端点，连出两条线，分别连接中间的红点和蓝点，接着分别去掉这两条线的最长一个区间；（2）直接从这两个绿点为端点，连出两条线，分别连接中间的红点和蓝点。 分别统计两种连线方式的代价，选最优即可。 代码写得很丑，要看漂亮代码请戳这：by aaaaajack source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;vector&lt;ll&gt; v0, v1, v2;ll ans;void add(vector&lt;ll&gt; &amp;v)&#123; if (v.empty()) return; ans += max(0LL, v0.front() - v.front()) + max(0LL, v.back() - v0.back());&#125;vector&lt;ll&gt;::iterator LB(vector&lt;ll&gt; &amp;v, ll x) &#123; return lower_bound(v.begin(), v.end(), x);&#125;ll calc(ll l, ll r) &#123; if (LB(v1, l) == LB(v1, r) &amp;&amp; LB(v2, l) == LB(v2, r)) return r - l; ll x = l, max_interval = 0; for (auto it = LB(v1, l); it != v1.end() &amp;&amp; (*it) &lt; r; it++) &#123; max_interval = max(max_interval, (*it) - x); x = *it; &#125; max_interval = max(max_interval, r - x); ll ans1 = 3 * (r - l) - max_interval; x = l; max_interval = 0; for (auto it = LB(v2, l); it != v2.end() &amp;&amp; (*it) &lt; r; it++) &#123; max_interval = max(max_interval, (*it) - x); x = *it; &#125; max_interval = max(max_interval, r - x); ans1 -= max_interval; return min(ans1, 2 * (r - l));&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); ll N; cin &gt;&gt; N; for (ll i = 0; i &lt; N; i++) &#123; ll x; string s; cin &gt;&gt; x &gt;&gt; s; if (s[0] == 'G') v0.push_back(x); else if (s[0] == 'B') v1.push_back(x); else v2.push_back(x); &#125; if (v0.size() &lt;= 1) &#123; if (!v1.empty()) ans += v1.back() - v1.front(); if (!v2.empty()) ans += v2.back() - v2.front(); &#125; else &#123; add(v1); add(v2); for (ll i = 0; i &lt; v0.size() - 1; i++) &#123; ans += calc(v0[i], v0[i + 1]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;","tags":[{"name":"greedy","slug":"greedy","permalink":"http://dafenghh.github.io/tags/greedy/"}]},{"title":"codeforces 343D [Water Tree] 题解","date":"2017-12-30T06:26:56.000Z","path":"post/a28d78f2.html","text":"题目大意给定一棵树，可以进行以下三种操作： 选择一个结点v，使v对应的子树全部充满水。 选择一个结点v，除去v和v所有的祖先的水。 选择一个结点v，查询v是否有水。 题目分析看完《挑战程序设计竞赛》的线段树章节后，搜了下codeforces的线段树题目来做，然后就搜到这题。这题做了很长时间哎，而且犯了不少很囧的错误。 首先看错了题，以为第二种操作是除去子树的水，所以很轻巧的敲了个BIT，跑起来不对才发现自己弄错了题意…… 于是删掉代码重写。想到要更新所有祖先结点，岂不是要用树链剖分？参考了下cf的Tutorial，原来使用一个很巧妙的转化，就能变成普通的线段树问题。 我思考这题的时候，总是想着加水就是染成1，去水就是染成0，所以这两个操作分别对应子树的更新和路径的更新，这么做起来就很麻烦。Tutorial将思路倒转一下，便是去水只需要在v（最末端结点）上打个标记，加水是将子树上的所有标记去掉，查询某点是否有水是看这个点对应子树是否有标记，只要有一个标记，说明这点没水；没标记才表示有水。 而初始状态，我们将所有叶子结点打上标记，就可表示全没水的状态。 这样一来，确定dfs序之后，找出每个结点对应子树区间[L,R], 然后使用std::set即可实现这个算法，还很简单，都不需要线段树了。 cf上的前排代码求dfs时，将R[v] = cnt + 1写成R[v] = ++cnt 我一开始很疑惑，这样写有什么区别，因为++后，就相当于对每个子树在末端新建了个虚拟的占位位置。 其实没区别。只是前排代码这么写，那么这一句S.erase(S.lower_bound(L[v]), S.lower_bound(R[v])) 的后半部分S.lower_bound(R[v])既可以用lower_bound, 又可以用upper_bound, 我的代码就只能用lower_bound source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 500010;vector&lt;int&gt; G[maxn];int L[maxn], R[maxn], fa[maxn];int cnt,n ,q;set&lt;int&gt; S;void dfs(int v, int par = -1) &#123; L[v] = ++cnt; for (auto i:G[v]) &#123; if (i != par) &#123; fa[i] = v;dfs(i, v); &#125; &#125; R[v] = cnt + 1; if (R[v] == L[v] + 1) S.insert(L[v]);&#125;bool empty(int v) &#123; auto it = S.lower_bound(L[v]); return it != S.end() &amp;&amp; (*it) &lt; R[v];&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n - 1; i++) &#123; int x,y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); G[y].push_back(x); &#125; dfs(1); scanf(\"%d\", &amp;q); while (q--) &#123; int c, v; scanf(\"%d%d\", &amp;c, &amp;v); if (c == 3) puts((empty(v) ? \"0\" : \"1\")); else if (c == 1) &#123; if (fa[v] &amp;&amp; empty(fa[v])) S.insert(L[fa[v]]); S.erase(S.lower_bound(L[v]), S.lower_bound(R[v])); &#125; else S.insert(L[v]); &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"trees","slug":"trees","permalink":"http://dafenghh.github.io/tags/trees/"},{"name":"dfs and similar","slug":"dfs-and-similar","permalink":"http://dafenghh.github.io/tags/dfs-and-similar/"}]},{"title":"POJ 3264 [Balance Lineup] 题解","date":"2017-12-29T12:56:34.000Z","path":"post/de36ffa1.html","text":"题目大意长度为N的数组，Q次查询，查询区间[A, B]的最大值与最小值之差。 题目分析线段树模板题。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100050;const int INF = 1234567;int mx[2 * maxn], lx[2 * maxn];int n;void update(int x, int y, int v = 0, int l = 0, int r = n) &#123; // a[x] = y; // printf(\"v = %d, l = %d, r = %d\\n\", v, l, r); if (l &gt;= r || x &lt; l || x &gt;= r) return; int chl = v * 2 + 1, chr = v * 2 + 2, mid = (l + r) / 2; if (l + 1 == r) &#123; mx[v] = lx[v] = y; &#125; else &#123; update(x, y, chl, l, mid); update(x, y, chr, mid, r); mx[v] = max(mx[chl], mx[chr]); lx[v] = min(lx[chl], lx[chr]); &#125;&#125;int queryMax(int L, int R, int v = 0, int l = 0, int r = n) &#123; if (l &gt;= r || R &lt;= l || L &gt;= r) return -INF; if (L &lt;= l &amp;&amp; r &lt;= R) return mx[v]; int chl = v * 2 + 1, chr = v * 2 + 2, mid = (l + r) / 2; return max(queryMax(L, R, chl, l, mid), queryMax(L, R, chr, mid, r));&#125;int queryMin(int L, int R, int v = 0, int l = 0, int r = n) &#123; if (l &gt;= r || R &lt;= l || L &gt;= r) return INF; if (L &lt;= l &amp;&amp; r &lt;= R) return lx[v]; int chl = v * 2 + 1, chr = v * 2 + 2, mid = (l + r) / 2; return min(queryMin(L, R, chl, l, mid), queryMin(L, R, chr, mid, r));&#125;int main() &#123; int q; scanf(\"%d%d\", &amp;n, &amp;q); fill(mx, mx + 2 * maxn, -INF); fill(lx, lx + 2 * maxn, INF); int y; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;y); update(i, y); &#125; while (q--) &#123; int A, B; scanf(\"%d%d\", &amp;A, &amp;B); int L = A - 1, R = B; printf(\"%d\\n\", queryMax(L, R) - queryMin(L, R)); &#125;&#125;","tags":[{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"trees","slug":"trees","permalink":"http://dafenghh.github.io/tags/trees/"}]},{"title":"POJ 2991 [Crane] 题解","date":"2017-12-29T11:03:22.000Z","path":"post/a9a98564.html","text":"题目大意N条线段首尾相连，初始时全都垂直于x轴呈一直线。标号从下往上，1到N。C次询问，每次询问给出S和A，将第S条线段和第S+1条线段的角度修改成A，角度指的是从S开始沿逆时针方向旋转到S+1经过的角度。求每次询问时第N条线段的末端点坐标。 题目分析《挑战程序设计竞赛》P170 例题，线段树的经典应用，很启发思维！ 如何转化成线段树问题呢？ 其实也是一种分治的思想。用v(i,j)表示第i条线段的始点到第j条线段的终点的向量，那么题目要求的就是每次更新后的v(1, n)如何求得v(1, n)呢？分而治之，将区间折半，v(1, n) = v(1, n / 2) + v(n / 2 + 1, n),。 如果我们旋转第i条线段，那么显然i到n的线段坐标都要变化。这样一来，我们就需要对这所有的点更新坐标一次，很明显效率是不足够的。 我们需要将旋转的特征提取出来，在上面这个例子中，(i..n)的点的相对位置是不变的，只是整体发生了旋转。 所以，我们可以只记录一个整体旋转的角度$\\alpha$ （相对于竖直方向的角度增量，逆时针为正），外加修改原来v(i, j)的定义，变成将第i条线段旋转至与地面垂直的时候，第i条线段的始点到第j条线段的终点的向量。 这样一来，我们求v(i,j)的实际值时，乘上$\\alpha$对应的旋转变换矩阵即可：\\begin{bmatrix} \\cos \\alpha &amp; -\\sin \\alpha\\\\ \\sin \\alpha &amp; \\cos \\alpha \\end{bmatrix} 所以构造这样一棵线段树，每个结点表示一段连续的线段区间，维护这两个值： 将线段区间的第一条线段旋转至垂直方向后，第一条线段的起点到最后一条线段的终点的向量 (v[i])两个儿子连接后，右儿子需要旋转的角度 (ang[i])记第i个结点的左右儿子结点为chl,chr，那么v[i] = v[chl] + M(ang[i]) * v[chr] P.S. WA了几发，原因是：当更新角度的线段s在当前区间mid之前时，我没有更新当前区间的ang值。后来发现，区间ang值的增量跟线段s角度增量一致。其实这个也很好理解（理解不了在图上画个三角形来旋转也能证明出来），因为旋转变换其实是对整个坐标系旋转，所以点旋转的是相同角度，向量旋转也是相同角度（注意平移变换不改变角度）。 P.S. 这题POJ有坑，输出格式是假的，样例中间不用加空行。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const double PI = acos(-1.0);const int maxn = 100010;double vx[2 * maxn], vy[2 * maxn], ang[2 * maxn], prv[maxn];int len[maxn];int n, q;void init(int v, int l, int r) &#123;// [l, r] if (l &gt;= r) return; ang[v] = 0; vx[v] = 0; if (l + 1 == r) &#123; vy[v] = len[l]; return; &#125; int chl = 2 * v + 1, chr = 2 * v + 2, mid = (l + r) / 2; init(chl, l, mid); init(chr, mid, r); vy[v] = vy[chl] + vy[chr];&#125;void update(int s, double a, int v, int l, int r) &#123; // angle changes a if (s &lt;= l ||s &gt;= r) return; int chl = 2 * v + 1, chr = 2 * v + 2, mid = (l + r) / 2; update(s, a, chl, l, mid); update(s, a, chr, mid, r); if (s &lt;= mid) ang[v] += a; double Co = cos(ang[v]), Si = sin(ang[v]); vx[v] = vx[chl] + Co * vx[chr] - Si * vy[chr]; vy[v] = vy[chl] + Si * vx[chr] + Co * vy[chr];&#125;int main() &#123; int testcnt = 0; while (scanf(\"%d%d\", &amp;n, &amp;q)!=EOF) &#123; testcnt++; for (int i = 0; i &lt; n; i++) scanf(\"%d\", len + i); init(0, 0, n); for (int i = 0; i &lt; n; i++) prv[i] = PI; while (q--) &#123; int s, angle_360; scanf(\"%d%d\", &amp;s, &amp;angle_360); double a = (double)angle_360 / 180 * PI; update(s, a - prv[s], 0, 0, n); prv[s] = a; printf(\"%.2lf %.2lf\\n\", vx[0], vy[0]); &#125; &#125;&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://dafenghh.github.io/tags/segment-tree/"},{"name":"geometry","slug":"geometry","permalink":"http://dafenghh.github.io/tags/geometry/"}]},{"title":"POJ 2785 [4 Values whose Sum is 0] 题解","date":"2017-11-30T14:45:20.000Z","path":"post/5396864a.html","text":"题目大意大小都为N的四个数组A[], B[], C[], D[], 从每个数组中分别选出一个数，a, b, c, d , 使得 a + b + c + d = 0，问有多少种选择方式。 题目分析《挑战程序设计竞赛》P160例题。《挑战》通过这道题介绍了重要的思想方法，即“折半枚举”的方法，将问题一拆为二进行枚举。 枚举出A[i]+B[j]的所有可能值和C[i]+D[j]的所有可能值, 之后用二分查找互为相反数的两个值的组数即可。 source code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 4200;typedef long long ll;int a[maxn], b[maxn], c[maxn], d[maxn];int ab[maxn * maxn], cd[maxn * maxn];ll ans = 0;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i] &gt;&gt; d[i]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) ab[i * n + j] = a[i] + b[j], cd[i * n + j] = c[i] + d[j]; sort(cd, cd + n * n); for (int i = 0; i &lt; n * n; i++) ans += upper_bound(cd, cd + n * n, -ab[i]) - lower_bound(cd, cd + n * n, -ab[i]); cout &lt;&lt; ans &lt;&lt; endl; &#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"}]},{"title":"POJ 3684 [Physics Experiment] 题解","date":"2017-11-30T07:30:55.000Z","path":"post/d839a1f6.html","text":"题目大意N个半径为R厘米的球竖直叠放在H米的高度上。实验开始时释放最下面的第一个球，1s后释放最下面的第二个球，1s后释放第三个球……一次类推。求T秒时每个球底端的高度。所有碰撞都是弹性碰撞， g取10 m/s^2 题目分析这题的转化非常巧妙。 首先观察到很重要的一点，所有球的顺序在碰撞过程中都是不变的。很明显最下面一个球永远会在最下面，最上面一个球永远在最上面……这个很显然的结论将会给我们下面的转化过程带来帮助。 考虑两个球碰撞时的情形，根据物理知识，我们知道碰撞时的两个球的速度一定大小相同，方向相反。碰撞后交换速度。 这时候我们可以将两个球互相弹回的过程视作两个球“穿过了对方”而继续运动。在穿过的这个瞬间，球的速度没有变化，但下面的球高度获得2R的增量，上面的球高度获得-2R的增量。 然后，最关键的一步转化来了。 如果我们修改每个球的高度的定义，将每个球的高度h[i]定义为实际高度-2*i*R （球的坐标分别为0..N-1, 从下往上），这样会发生什么？ 首先在初始时刻，所有的球的高度h[i]都是H。 然后我们再来看两个球碰撞的过程，碰撞时“穿过了对方”也就是“带着自己的速度到了对方的位置”。 这样想的话，我们就相当于交换了两个相邻的球的顺序，与一开始我们的结论“所有球的顺序一直不变有点矛盾”。 我们加多一层转化，就是将碰撞过程视作“带着自己的速度到了对方的位置，并变成了对方”。比如i和i+1碰撞，我们看作，i保持着自己的速度瞬间跳转i+1的位置，并变成了i+1；i+1同理。 i变成i+1的话，高度的定义也发生了改变，从实际高度-2*i*R 变成 实际高度-2*(i+1)*R]， 与实际高度的差值加多了一个2R, 另外这个过程里，i也会获得2R高度的增量，所以两部分抵消，h高度值完全没有变化。 这么一来，问题就变成，N个球相隔1s依次从高度H开始下落，求T秒后各球高度。另外我们要还原成实际高度，将高度排序后从下往上依次加上2*i*R即可. 就这样完美转化成一道简单物理题。 source code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const double g = 10;double solve(double h, double t) &#123; double t0 = sqrt(2 * h / g); t -= 2 * t0 * ((int)(t / (2 * t0))); if (t &gt; t0) t = 2 * t0 - t; return h - 0.5 * g * t * t;&#125;const int maxn = 200;double a[maxn];int main() &#123; int Test; scanf(\"%d\", &amp;Test); while (Test--)&#123; int N; double H, R, T; scanf(\"%d%lf%lf%lf\", &amp;N, &amp;H, &amp;R, &amp;T); R /= 100; for (int i = 0; i &lt; N; i++) &#123; a[i] = H; &#125; for (int i = 0; i &lt; min((int)T,N); i++) &#123; a[i] = solve(a[i], T - i); &#125; sort(a, a + N); for (int i = 0; i &lt; N; i++) &#123; printf(\"%.2lf%c\", a[i] + 2 * i * R, (i == N - 1 ? 10:32)); &#125; &#125;&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"},{"name":"巧妙的转化","slug":"巧妙的转化","permalink":"http://dafenghh.github.io/tags/巧妙的转化/"}]},{"title":"POJ 3279 [Fliptile] 题解","date":"2017-11-29T14:39:42.000Z","path":"post/bdca6a8a.html","text":"题目大意一个游戏，M*N的方格，每个格子可以翻转正反面，一面白色，一面黑色。当翻转一个格子时，它的相邻格子都会被翻转。用最小的翻转次数使所有格子变成白色。 题目分析考虑(1,1)这个格子，翻转(1,1) (1,2) (2,1)三个格子都能改变它的状态。但当我们确定第一行的操作后，就只有翻转(2,1)能够改变(1,1)的状态。 所以，如果我们指定第一行的操作，就能根据(1,1)的状态来确定(2,1)是否需要翻转。同样的，也能确定余下所有方格是否需要翻转。最后确定一下最下一行是否全部变成白色即可。 所以这道题，就枚举第一行的所有操作即可。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;int m,n;const int maxn = 20;int a[maxn][maxn], flip[maxn][maxn], ans_flip[maxn][maxn], stat[maxn][maxn];int ans = 1000;#define Forij \\ for (int i = 0; i &lt; m; i++)\\ for (int j = 0; j &lt; n; j++)void F(int x, int y) &#123; stat[x][y] = 1 - stat[x][y]; int d[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int di = 0; di &lt; 4; di++)&#123; int nx = x + d[di][0], ny = y + d[di][1]; if (nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n) stat[nx][ny] = 1 - stat[nx][ny]; &#125;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n; Forij cin &gt;&gt; a[i][j]; for (int x = 0; x &lt; (1 &lt;&lt; n); x++) &#123; bool flag = true, cnt = 0; Forij stat[i][j] = a[i][j], flip[i][j] = 0; for (int xi = 0; xi &lt; n; xi++)&#123; if (x &amp; (1 &lt;&lt; xi)) &#123; F(0, xi); flip[0][xi] = 1; cnt++; &#125; &#125; Forij &#123; if (i == m - 1)&#123; if (stat[i][j])&#123; flag = false; break; &#125; &#125; else &#123; if (stat[i][j])&#123; F(i + 1, j); flip[i + 1][j] = 1; cnt++; &#125; &#125; &#125; if (flag &amp;&amp; (cnt &lt; ans)) &#123; ans = cnt; Forij ans_flip[i][j] = flip[i][j]; &#125; &#125; if (ans == 1000) cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; endl; else&#123; Forij cout &lt;&lt; ans_flip[i][j] &lt;&lt; (j == n - 1 ? '\\n' : ' '); &#125;&#125;","tags":[{"name":"反转","slug":"反转","permalink":"http://dafenghh.github.io/tags/反转/"},{"name":"brute force","slug":"brute-force","permalink":"http://dafenghh.github.io/tags/brute-force/"},{"name":"位运算","slug":"位运算","permalink":"http://dafenghh.github.io/tags/位运算/"}]},{"title":"codeforces gym 101612 H [Hidden Supervisors] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:38:43.000Z","path":"post/2cb42504.html","text":"题目描述gym 101612 H题链接： gym 给定若干棵树，其中一棵的根结点为1，现在把这所有的树合并成一棵根结点为1的树，并且要使这棵树中能够组成的(a,b)(a是b的父结点)的组数最大。 题目分析先对每棵树做下DFS，用贪心的方式分好组。这棵树的根结点要么分好组，要么没分好。对所有不等于1的根结点，如果它已经分好组，就直接连到1上面；如果没分好组，就连到结点1的树未分组的一个结点上。对没分好组的根结点，用下贪心策略，对应的树的未分组结点越多的根结点越优先连接。 就这样简单的贪心策略，完成此题……想复杂了，并且细节上犯了弱智错误，debug很久。（根结点的分组居然写在了countUnmatchedNodesForAllTrees函数之前）。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//#define LOCAL#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n;int p[maxn], rt[maxn];vector&lt;int&gt; G[maxn];typedef pair&lt;int, int&gt; P;bool matched[maxn];int cnt = 0;vector&lt;int&gt; unmatched_nodes[maxn];set&lt;int&gt; S;void addUnmatchedNodes(int v)&#123; int u = rt[v]; unmatched_nodes[u].push_back(v);&#125;void addUnmatchedNodesToRoot(int v)&#123; for (auto i: unmatched_nodes[v])&#123; S.insert(i); &#125; //unmatched_nodes[v].clear();&#125;bool Match(int v, int root) &#123; rt[v] = root; bool res = false; for (auto i: G[v]) &#123; if (!Match(i, root))&#123; if (!res)&#123; matched[v] = true; matched[i] = true; res = true; cnt++; &#125; &#125; &#125; return res;&#125;void countUnmatchedNodesForAllTrees() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (!matched[i]) &#123; addUnmatchedNodes(i); &#125; &#125;&#125;int main() &#123; #ifndef LOCAL freopen(\"hidden.in\", \"r\", stdin); freopen(\"hidden.out\", \"w\", stdout); #endif scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; scanf(\"%d\", p + i); G[p[i]].push_back(i); &#125; Match(1, 1); queue&lt;int&gt; que0; priority_queue&lt;P&gt; que1;//que0: matched que1: unmatched for (auto i: G[0]) &#123; Match(i, i); &#125; countUnmatchedNodesForAllTrees(); for (auto i: G[0]) &#123; if (matched[i]) &#123; que0.push(i); &#125; else que1.push(P(unmatched_nodes[i].size(),i)); &#125; addUnmatchedNodesToRoot(1); while (!que0.empty()) &#123; int u = que0.front(); que0.pop(); p[u] = 1; addUnmatchedNodesToRoot(u); &#125; while (!que1.empty()) &#123; int u = que1.top().second; que1.pop(); if (!S.empty())&#123; int v = *S.begin(); p[u] = v; cnt++; addUnmatchedNodesToRoot(u); S.erase(u); S.erase(v); &#125; else &#123; p[u] = 1; addUnmatchedNodesToRoot(u); &#125; &#125; printf(\"%d\\n\", cnt); for (int i = 2; i &lt;= n; i++) printf(\"%d%c\", p[i], (i == n?10:32));&#125;","tags":[{"name":"greedy","slug":"greedy","permalink":"http://dafenghh.github.io/tags/greedy/"},{"name":"trees","slug":"trees","permalink":"http://dafenghh.github.io/tags/trees/"}]},{"title":"codeforces gym 101612 I [Intelligence in Perpendicularia] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:38:10.000Z","path":"post/7ec55acf.html","text":"题目描述gym 101612 I题链接： gym 给出一个多边形（只包含水平边和垂直边），求所有边中不能从外面看见的部分的长度。 题目分析注意到能被外面看到的边经过平移后刚好能组成一个矩形，所以这题就简单了。先统计出周长，然后减去外接矩形的周长就得到答案了。 source code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;fstream&gt;#include &lt;algorithm&gt;using namespace std;ifstream cin(\"intel.in\");ofstream cout(\"intel.out\");const int maxn = 2000;typedef long long ll;ll x[maxn], y[maxn];int n;ll abs_(ll x)&#123; return x &gt; 0 ? x : -x;&#125;ll getL(int i, int j) &#123; if (x[i] == x[j]) return abs_(y[i] - y[j]); else return abs_(x[i] - x[j]);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; ll len = 0; ll minX, maxX, minY, maxY; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; len += getL(i , (i + 1) % n); if (i == 0) minX = maxX = x[i], minY = maxY = y[i]; else minX = min(minX, x[i]), maxX = max(maxX, x[i]), minY = min(minY, y[i]), maxY = max(maxY, y[i]); &#125; // cout &lt;&lt; len &lt;&lt; endl; //cout &lt;&lt; maxX &lt;&lt; \" \" &lt;&lt; minX &lt;&lt; \" \" &lt;&lt; maxY &lt;&lt; \" \" &lt;&lt; minY &lt;&lt; endl; cout &lt;&lt; len - 2 * (maxX - minX + maxY - minY) &lt;&lt;endl;&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"codeforces gym 101612 K [Kotlin Island] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:36:06.000Z","path":"post/f48dff26.html","text":"题目描述gym 101612 K题链接： gym 一个岛可以看成一个h*w的网格，现在可以在任意的行或者任意的类挖水渠，目标是将网格剩下没被挖水渠的点划分成k个连通块。给出一种方案即可。 题目分析显然最后分成的连通块数目 = 行的分块数 * 列的分块数。比如有5行，那么我们最多可以分成3块。 枚举一遍就出答案了。 source code12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;const int maxn = 120;bool row[maxn], col[maxn];int h, w, n;int main() &#123; #ifndef LOCAL freopen(\"kotlin.in\", \"r\", stdin); freopen(\"kotlin.out\", \"w\", stdout); #endif scanf(\"%d%d%d\", &amp;h, &amp;w, &amp;n); for (int hi = 1; hi &lt;= (h + 1) / 2; hi++) for (int wi = 1; wi &lt;= (w + 1) / 2; wi++) &#123; if (hi * wi == n)&#123; for (int i = 0; i &lt; hi - 1; i++) row[1 + i * 2] = true; for (int i = 0; i &lt; wi - 1; i++) col[1 + i * 2] = true; for (int i = 0; i &lt; h; i++) &#123; for (int j = 0; j &lt; w; j++)&#123; if (row[i] || col[j]) printf(\"#\"); else printf(\".\"); &#125; printf(\"\\n\"); &#125; return 0; &#125; &#125; printf(\"Impossible\\n\");&#125;","tags":[{"name":"brute force","slug":"brute-force","permalink":"http://dafenghh.github.io/tags/brute-force/"}]},{"title":"codeforces gym 101612 C [Consonant Fencity] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:35:36.000Z","path":"post/9c682bc0.html","text":"题目描述gym 101612 C题链接： gym 定义辅音字母为除了{a,e,i,o,u,w,y}之外的19个字母。然后定义一个字符串的fencity为串中有多少对相邻的辅音字母，且它们一个大写一个小写。给出一个只包含小写字母的字符串，现在你要指定19个辅音字母中的若干个字母，将字符串中的这些字母全部转换为大写。求fencity最大的串。 题目分析一共有19个字母要考虑。将这19个字母想象成图中的点。我们先扫一遍字符串，当遇到辅音字母相邻时，就将这两个辅音字母的边权+1. 然后这题就是说，往19个点染两种颜色（大写或者非大写），当一条边的两个端点颜色不一样时，这条边的边权生效。求边权和最大值。 由于对称性，我们可以固定一个点的颜色，然后只有18个点需要考虑，那么就是2^18中情况需要枚举。每个情况扫一遍所有的边，那么就是2^18 * 19 * 18 / 2的复杂度，大概为4500万，所以暴力方式能够解决此题。 P.S.有个小插曲，(1 &lt;&lt; M[s[i]])) &gt; 0 忘了加前面的括号，debug了好长时间。下次打比赛时要先打印一份C/C++运算符优先级列表，然后将它压在台面上。 source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;int n = 19;int w[20][20];int fencity[(1 &lt;&lt; 18)];void solve() &#123; int xn = (1 &lt;&lt; (n - 1)); for (int x = 0; x &lt; xn; x++) &#123; fencity[x] = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++)&#123; int p = (x &amp; (1 &lt;&lt; i)); int q = (x &amp; (1 &lt;&lt; j)); if (p == 0 &amp;&amp; q &gt; 0 || p &gt; 0 &amp;&amp; q == 0)&#123; fencity[x] += w[i][j]; &#125; &#125; &#125;&#125;char s[1000010];char voewls[] = \"aeiouwy\";int main() &#123; #ifndef LOCAL freopen(\"consonant.in\", \"r\", stdin); freopen(\"consonant.out\", \"w\", stdout); #endif scanf(\"%s\", s); int len = strlen(s); set&lt;char&gt; S(voewls, voewls+ 7); map&lt;char, int&gt; M; int cnt = 0; for (char ch = 'b'; ch &lt;= 'z'; ch++) &#123; if (!S.count(ch)) M[ch] = cnt++; &#125; for (int i = 0; i &lt; len - 1; i++) &#123; if (M.count(s[i]) &amp;&amp; M.count(s[i + 1])) &#123; w[M[s[i]]][M[s[i + 1]]]++; w[M[s[i + 1]]][M[s[i]]]++; &#125; &#125; solve(); int ans = 0, xn = (1 &lt;&lt; (n - 1)); for (int x = 1; x &lt; xn; x++) if (fencity[ans] &lt; fencity[x]) ans = x; for (int i = 0; i &lt; len; i++) &#123; if (!S.count(s[i]) &amp;&amp; ((ans &amp; (1 &lt;&lt; M[s[i]])) &gt; 0)) printf(\"%c\", s[i] + 'A' - 'a'); else printf(\"%c\", s[i]); &#125; printf(\"\\n\");&#125;","tags":[{"name":"brute force","slug":"brute-force","permalink":"http://dafenghh.github.io/tags/brute-force/"},{"name":"位运算","slug":"位运算","permalink":"http://dafenghh.github.io/tags/位运算/"}]},{"title":"codeforces gym 101612 E [Equal Numbers] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解","date":"2017-11-29T14:30:09.000Z","path":"post/79e97c8b.html","text":"题目描述gym 101612 E题链接： gym 给定一个大小为n的正整数的数组，每次操作可以选取数组中一个数，将它乘上若干倍。求经过k次操作后，数组中最少有多少个不同的数？输出所有0&lt;=k&lt;=n的k的结果。 题目分析样例输入是n = 4, a[] = {1, 1, 2, 2, 3, 4} 我们先将相同的数合并成一堆，比如这里a[]可以看作{1(2), 2(2), 3(1), 4(1)} 括号里的数表示这个数字的出现次数。 假定初始状态有vn堆数，这个样例里vn = 4 题目要求的就是经过若干次操作后，最少剩下多少堆。 不妨换个思路，我们来求把vn堆数合并成vn - k堆至少需要多少次操作。如果能求出这个结果，我们将数组逆一下，并且空白处的值用前面的值填充好就得到题目要求的答案。 下面思考把vn堆数合并成vn - k堆， 也就是减少k堆，至少需要多少次操作。 我们把原来的数分成两类，一类是它的倍数也存在于数组中，另一类是它没有一个倍数存在与数组中，分别记为A类，B类。 样例中A类为： 1(2), 2(2)样例中B类为： 3(1), 4(1) 为了减少k堆，我们有两种决策方法： 直接在A类中选取大小最小的k堆，将这些数全部提升为它们的倍数。 在B类中选取大小最小的两堆，将这两堆数提升为所有数的最小公倍数，这时候减少了原有的2堆，但新增了1堆（所有数的最小公倍数），并且因为出现了所有数的最小公倍数，所以原有的所有数都变成A类，再按方法1选取(k-1)堆即可。 两种方法分别求出来比较一下，取最优就得到答案了。 源代码中用x表示第一种决策方式需要的操作数，y表示第二种决策方式需要的操作数。 source_code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1000060;int a[maxn], cnt[maxn], ops[maxn], ans[maxn], bucket[maxn];vector&lt;int&gt; v0, v1, v2;void bucket_sort(vector&lt;int&gt; &amp;v)&#123; memset(bucket, 0, sizeof(bucket)); for (int i = 0; i &lt; v.size(); i++) bucket[v[i]]++; v.clear(); for (int i = 0; i &lt; maxn; i++) for (int j = 0; j &lt; bucket[i]; j++) v.push_back(i);&#125;int main() &#123; #ifndef LOCAL freopen(\"equal.in\", \"r\", stdin); freopen(\"equal.out\", \"w\", stdout); #endif int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", a + i); cnt[a[i]]++; &#125; for (int i = 1; i &lt; maxn; i++)&#123; if (cnt[i])&#123; bool flag = false; for (int j = 2; i * j &lt; maxn; j++) &#123; if (cnt[i * j]) &#123; flag = true; break; &#125; &#125; if (flag) v0.push_back(cnt[i]); else v1.push_back(cnt[i]); &#125; &#125; int vn = v0.size() + v1.size(); bucket_sort(v0); bucket_sort(v1); for (int i = 0; i &lt; v0.size(); i++) v2.push_back(v0[i]); for (int i = 2; i &lt; v1.size(); i++) v2.push_back(v1[i]); bucket_sort(v2); ops[vn] = 0; int x = 0, y = 0; if (v1.size() &gt;= 2) y+=v1[0] + v1[1]; else y = 2 * n; for (int k = 1; k &lt; vn; k++) &#123; if (k &lt;= v0.size()) x += v0[k - 1]; else x = 2 * n; if (k &gt; 1) y+=v2[k - 2]; // printf(\"x = %d, y = %d, k = %d\\n\", x, y, k); ops[vn - k] = min(x, y); &#125; for (int i = 1; i &lt;= vn; i++)&#123; ans[ops[i]] = i; &#125; for (int i = 1; i &lt;= n; i++)&#123; if (ans[i] == 0) ans[i] = ans[i-1]; &#125; for (int i = 0; i &lt;= n; i++) printf(\"%d%c\", ans[i], (i == n?10:32));&#125;","tags":[{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"POJ 3484 [Showstopper] 题解","date":"2017-11-28T14:44:04.000Z","path":"post/b9568341.html","text":"题目大意给定若干等差数列，初项x，公差z，末项不大于y（均为正整数）。在所有数列有，有且仅有一个数的出现次数是奇数，求这个数以及它出现的次数。 题目分析初看此题，真的毫无思路。虽然知道实在《挑战程序设计竞赛》的二分专题中，肯定使用二分算法，但怎么联系到二分上去呢？ 有且只有一个奇数，这就是突破口。对解空间中的所有数，统计它们在数列中的出现次数，记为c[i]，然后对c[i]求个前缀和，那么在答案点x前，前缀和均为偶，答案点x及之后，前缀和均为奇。由此得到二分的单调性，得解。 有点小插曲，这道题的输入方式很麻烦……最讨厌按行输入了。WA几次后以为是输入有问题，其实是算法部分写错了细节。统计区间的数在数列的出现次数时，左端应该向上取整…… 代码比较累赘，特别是统计的时候，可以写精简些。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Tuple &#123; ll x, y, z; Tuple(ll x = 0, ll y = 0, ll z = 0):x(x), y(y), z(z)&#123;&#125;&#125;;vector&lt;Tuple&gt; vec;ll count_(ll L, ll R, Tuple t) &#123; //[L, R] ll x = t.x, y = t.y, z = t.z; if (R &lt; x || L &gt; y) return 0; if (L &lt; x) L = x; if (R &gt; y) R = y; ll res = (R - x ) / z - (L - x) / z + 1; if ((L - x) % z) res--; return res;&#125;void solve() &#123; /*printf(\"-------------\\n\"); for (ll i = 0; i &lt; vec.size(); i++) &#123; printf(\"%lld %lld %lld\\n\", vec[i].x, vec[i].y, vec[i].z); &#125; printf(\"-------------\\n\");*/ if (vec.empty()) return; ll L = vec[0].x, R = vec[0].y; for (ll i = 1; i &lt; vec.size(); i++) &#123; L = min(L, vec[i].x); R = max(R, vec[i].y); &#125; L--; ll sum = 0; for (ll i = 0; i &lt; vec.size(); i++) &#123; sum += count_(L, R, vec[i]); &#125; if (sum % 2 == 0) &#123; printf(\"no corruption\\n\"); return; &#125; while (L + 1 &lt; R) &#123; ll mid = (L + R) / 2; ll sum = 0; for (ll i = 0; i &lt; vec.size(); i++) &#123; sum += count_(L, mid, vec[i]); &#125; if (sum % 2 == 0) L = mid; else R = mid; &#125; sum = 0; for (ll i = 0; i &lt; vec.size(); i++) &#123; sum += count_(R, R, vec[i]); &#125; ll ans = (ll)R; printf(\"%I64d %I64d\\n\", ans, sum);&#125;char s[1000];void work() &#123; ll x = 0, y = 0, z = 0; sscanf(s, \"%I64d %I64d %I64d\", &amp;x, &amp;y, &amp;z); if (!x) return; vec.clear(); vec.push_back(Tuple(x, y, z)); memset(s, 0, sizeof(s)); while (gets(s), *s) &#123; sscanf(s, \"%I64d %I64d %I64d\", &amp;x, &amp;y, &amp;z); vec.push_back(Tuple(x, y, z)); memset(s , 0 , sizeof(s)); &#125; solve();&#125;int main() &#123; while (gets(s)) work();&#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"},{"name":"按行输入","slug":"按行输入","permalink":"http://dafenghh.github.io/tags/按行输入/"}]},{"title":"POJ 3276 [Face The Right Way] 题解","date":"2017-11-28T12:22:37.000Z","path":"post/49886522.html","text":"题目大意n头牛排成一行，有的牛面朝前，有的牛面朝后，每一次操作可以使连续的K头牛改变方向；求一个K，使得操作次数最少。输出K以及最少的操作次数。当有多个K满足条件时，输出最小的K。 题目分析对一个区间来说，多次进行反转操作是没有意义的；另外反转的顺序对结果是没有影响的。所以这道题只需要对所有的可操作区间（即长度为K的区间）考虑是否需要反转。 考虑最左边的牛，当它面朝前时无需反转，当它面朝后时，就反转[1, K]区间一次。然后继续考虑第二头牛即可。 反转的时候不必每头牛都操作一次，只需用一个turns来记录当前区间的反转次数，考虑的下一头牛的状态就由它本身状态+turns的值来决定。随着区间往右移动，我们用区间左右更改的地方来更新turns即可。复杂度为O(n ^ 2) source code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 5500;const int INF = 100243535;int a[maxn], f[maxn], cnt[maxn];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; char s[10]; scanf(\"%s\", s); a[i] = (s[0] == 'F' ? 0 : 1); &#125; for (int k = 1; k &lt;= n; k++) &#123; memset(f, 0, sizeof(f)); int turns = 0; for (int i = 0; i &lt; n; i++) &#123; if ((a[i] + turns) % 2 == 1) &#123; if (i + k &gt; n) &#123; cnt[k] = INF; break; &#125; f[i] = 1; cnt[k]++; turns++; &#125; if (i - k + 1 &gt;= 0) turns -= f[i - k + 1]; &#125; &#125; int ansK = 1; for (int k = 2; k &lt;= n; k++) if (cnt[k] &lt; cnt[ansK]) ansK = k; printf(\"%d %d\\n\", ansK, cnt[ansK]);&#125;","tags":[{"name":"区间处理","slug":"区间处理","permalink":"http://dafenghh.github.io/tags/区间处理/"},{"name":"反转","slug":"反转","permalink":"http://dafenghh.github.io/tags/反转/"}]},{"title":"POJ 3320 [Jessica's Reading Problem] 题解","date":"2017-11-28T04:51:03.000Z","path":"post/6f199fb1.html","text":"题目大意给定一个大小为P的数组，取出一个子区间，要求这个子区间上的数能覆盖整个数组的数，求满足条件的子区间的最小长度。 题目分析《挑战程序设计竞赛》P149例题，采用“尺取法”可以很快地做出这道题。 挑战程序设计竞赛 使用map来记录的时间复杂度为O(P log P)。 由于P最大为10e6，所以我提交的时候很担心超时。结果真的超时了，但并不是复杂度的锅，而是我用了cin cout，改成scanf printf就过了。 后来查了下，在windows下不开ios::sync_with_stdio(false)的优化时，cin比scanf慢差不多十倍;开了后，慢三倍。只有在linux下g++编译，并且写上这一句优化的情况下，cin才达到和scanf差不多的效率。 之后，将map改成hash，将时间复杂度降到线性，并且采用快速读入，这样才能47ms通过。 source codesolution 1 (454ms)12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1000100;int a[maxn];int main() &#123; int n; scanf(\"%d\", &amp;n); set&lt;int&gt; S; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", a + i); S.insert(a[i]); &#125; int sn = S.size(); S.clear(); map&lt;int, int&gt; M; int s = 0, t = 0, cnt = 0, ans = n; for (;;) &#123; while (t &lt; n &amp;&amp; cnt &lt; sn) &#123; if (M[a[t]] == 0) cnt++; M[a[t]]++; t++; &#125; if (cnt &lt; sn) break; ans = min(ans, t - s); if (M[a[s]] == 1) cnt--; M[a[s]]--; s++; &#125; printf(\"%d\\n\", ans);&#125; solution 2 (47ms)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1000100;int a[maxn];const int hash_n = 535442;int M0[hash_n], M[hash_n];inline int get()&#123; int k=0; char f=1; char c=getchar(); for(;!isdigit(c);c=getchar() ) if(c=='-') f=-1; for(;isdigit(c);c=getchar() ) k=k*10+c-'0'; return k*f;&#125;int main() &#123; int n; n = get(); for (int i = 0; i &lt; n; i++) &#123; a[i] = get(); a[i] %= hash_n; M0[a[i]]++; &#125; int sn = 0; for (int i = 0; i &lt; hash_n; i++) if (M0[i]) sn++; int s = 0, t = 0, cnt = 0, ans = n; for (;;) &#123; while (t &lt; n &amp;&amp; cnt &lt; sn) &#123; if (M[a[t]] == 0) cnt++; M[a[t]]++; t++; &#125; if (cnt &lt; sn) break; ans = min(ans, t - s); if (M[a[s]] == 1) cnt--; M[a[s]]--; s++; &#125; printf(\"%d\\n\", ans);&#125;","tags":[{"name":"尺取法","slug":"尺取法","permalink":"http://dafenghh.github.io/tags/尺取法/"},{"name":"hash","slug":"hash","permalink":"http://dafenghh.github.io/tags/hash/"}]},{"title":"POJ 1759 [Garland] 题解","date":"2017-11-28T02:08:39.000Z","path":"post/68c8caf8.html","text":"题目大意给定一个数列H[]，满足下面的关系：1234H[1] = AH[i] = (H[i-1] + H[i+1])/2 - 1, for all 1 &lt; i &lt; N H[N] = B H[i] &gt;= 0, for all 1 &lt;= i &lt;= N 已知A，求B的最小值。 题目分析化成递推式， 有H[i+1] = 2 * H[i] - H[i-1] + 2 作下变形，有H[i+1] - H[i] = H[i] - H[i-1] + 2 所以H[i+1] - H[i]是一个等差数列，公差为2，那么：H[i+1] - H[i] = H[2] - H[1] + 2 * (i - 1) 做累加求和即得H[i]通项公式： H[i] = (i - 1) * H[2] + (2 - i) * H[1] + (i - 1) * (i - 2) 题目要求B，即H[N] = (N - 1) * H[2] + (2 - N) * H[1] + (N - 1) * (N - 2) 这个式子中，仅有H[2]为未知项，其他均已知。而且H[2]项前的系数N-1为正，H[N]与H[2]线性正相关，所以H[N]取最小值当且仅当H[2]取最小值。 于是我们将问题转化为求H[2]最小值即可。对H[2]进行二分，每次验证数列里的所有项是否全部大于零即可。 P.S. 交了几发WA，因为一不小心交了G++编译器，POJ的G++编译器有点老，浮点支持得不好。 source_code1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cmath&gt;int n;double A,B;bool judge(double mid) &#123; double a = A, b = mid,x; for (int i = 3; i &lt;= n; i++) &#123; x = 2 * b - a + 2; if (x &lt; 0) return false; a = b; b = x; &#125; B = x; return true;&#125;int main() &#123; scanf(\"%d%lf\", &amp;n, &amp;A); double L = -1, R = 1060; for (int i = 0; i &lt; 100; i++) &#123; double mid = (L + R) / 2; if (judge(mid)) R = mid; else L = mid; &#125; printf(\"%.2lf\\n\", B);&#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"},{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"codeforces 894E [Ralph and Mushrooms] #round 447 div2E 题解","date":"2017-11-27T11:39:47.000Z","path":"post/2fde12e8.html","text":"题目大意一个有向图，n个点，m条边，每条边初始有w[i]个蘑菇。有可能存在自环或重边。从点s出发，任意移动，当第一次经过一条边时，能采集w[i]个蘑菇；第二次经过这条边时，能采集w[i] - 1个蘑菇；第三次经过时，能采集w[i] - 1 - 2个；第四次则为w[i] - 1 - 2 - 3个，依次类推。当可采集蘑菇数变成0或负数后，仍能从这条边经过，但不会获得蘑菇。求能采集到的蘑菇的最大数量。 题目分析经过强连通分量(scc)分解后，并缩成一个DAG。显然每个scc上，可以任意次数遍历这个scc包含的边，直至无蘑菇可采。然后scc之间的边，最多只能经过一次。对那些可以无限遍历的边，我们先用二分求出总蘑菇数，然后汇总到所在的scc中。最后应用DAG上的动态规划，算出从点s出发, 能采集到的最大蘑菇数。 source_code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;utility&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;int V;const int maxv= 1000010;vector&lt;int&gt; G[maxv], rG[maxv], vs;bool used[maxv];int cmp[maxv];void add_edge(int from, int to)&#123; G[from].push_back(to); rG[to].push_back(from); &#125;void dfs(int v)&#123; used[v] = true; for(int i = 0; i &lt; G[v].size(); i++)&#123; if (!used[G[v][i]]) dfs(G[v][i]); &#125; vs.push_back(v);&#125;void rdfs(int v, int k)&#123; used[v] = true; cmp[v] = k; for (int i = 0; i &lt; rG[v].size(); i++)&#123; if (!used[rG[v][i]]) rdfs(rG[v][i], k); &#125;&#125;int scc() &#123; memset(used, 0, sizeof(used)); vs.clear(); for (int v = 1; v &lt;= V; v++)&#123; if (!used[v]) dfs(v); &#125; memset(used, 0 , sizeof(used)); int k = 0; for (int i = vs.size() - 1; i &gt;= 0; i--)&#123; if(!used[vs[i]]) rdfs(vs[i], k++); &#125; return k;&#125;const int sn = 22000;ll sum[sn], accSum[sn];void init_sum() &#123; sum[0] = accSum[sn] = 0; for (int i = 1; i &lt; sn; i++) sum[i] = sum[i - 1] + i; for (int i = 1; i &lt; sn; i++) accSum[i] = accSum[i - 1] + sum[i];&#125;ll calWeight(int x) &#123; int k = upper_bound(sum, sum + sn, x) - sum - 1; return (ll)(k+1) * x - accSum[k]; &#125; ll shrink_vertex_weight[maxv], dp[maxv];int sV;vector&lt;int&gt; shrink_graph[maxv];map&lt;P, ll&gt; shrink_edge_weight;struct edge&#123;int from, to, weight;&#125;;edge edges[maxv];void update(ll &amp;a, ll b) &#123; if (b &gt; a) a = b;&#125;ll f(int v) &#123; if (dp[v] &gt; -1) return dp[v]; ll reward = 0; for (auto i: shrink_graph[v]) &#123; update(reward, shrink_edge_weight[P(v, i)] + f(i)); &#125; return dp[v] = shrink_vertex_weight[v] + reward;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); init_sum(); int n, m; cin &gt;&gt; n &gt;&gt; m; V = n; for (int i = 0; i &lt; m; i++) &#123; int from, to, weight; cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight; add_edge(from, to); edges[i] = edge&#123;from, to, weight&#125;; &#125; int start; cin &gt;&gt; start; sV = scc(); for (int i = 0; i &lt; m; i++) &#123; int v1 = edges[i].from, v2 = edges[i].to; if (cmp[v1] == cmp[v2]) &#123; shrink_vertex_weight[cmp[v1]] += calWeight(edges[i].weight); &#125; else &#123; update(shrink_edge_weight[P(cmp[v1], cmp[v2])], edges[i].weight); shrink_graph[cmp[v1]].push_back(cmp[v2]); &#125; &#125; memset(dp, -1, sizeof(dp)); cout &lt;&lt; f(cmp[start]) &lt;&lt; endl;&#125;","tags":[{"name":"dp","slug":"dp","permalink":"http://dafenghh.github.io/tags/dp/"},{"name":"graphs","slug":"graphs","permalink":"http://dafenghh.github.io/tags/graphs/"},{"name":"scc","slug":"scc","permalink":"http://dafenghh.github.io/tags/scc/"}]},{"title":"POJ 3061 [Subsequence] 题解","date":"2017-11-27T07:43:53.000Z","path":"post/acca6816.html","text":"题目大意给定一个长度为N的数列，以及整数S。求出和不小于S的连续子序列的长度的最小值。如果解不存在，则输出0. 题目分析先求前缀和，然后就能用O(1)的时间, 求出一个区间的和。 之后用二分就能解决这道题。 但《挑战程序设计竞赛》(P146)中提供了一种更高效和简单的解法，叫“尺取法”。 source codesolution 11234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int maxn = 100010;typedef long long ll;ll a[maxn], sum[maxn];int N;ll S;bool judge(int len) &#123; for (int i = 0; i + len &lt;= N; i++) &#123; if (sum[i + len] - sum[i] &gt;= S) return true; &#125; return false;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N &gt;&gt; S; for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; sum[0] = 0; for (int i = 0; i &lt; N; i++) sum[i + 1] = sum[i] + a[i]; if (sum[N] &lt; S) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int L = 0, R = N; while (L + 1 &lt; R) &#123; int mid = (L + R) / 2; if (judge(mid)) R = mid; else L = mid; &#125; cout &lt;&lt; R &lt;&lt; endl; &#125;&#125; solution 212345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;typedef long long ll;ll a[maxn];int N;ll S;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N &gt;&gt; S; for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; int s = 0, t = 0; ll sum = 0; int ans = N + 1; for (;;) &#123; while (t &lt; N &amp;&amp; sum &lt; S) sum += a[t++]; if (sum &lt; S) break; ans = min(ans, t - s); sum -= a[s++]; &#125; if (ans &gt; N) ans = 0; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"},{"name":"尺取法","slug":"尺取法","permalink":"http://dafenghh.github.io/tags/尺取法/"}]},{"title":"POJ 1064 [Cable master] 题解","date":"2017-11-27T07:13:40.000Z","path":"post/52b6f961.html","text":"题目大意N条绳子，长度分别为Li，从它们之中切割出K条长度相同的绳子，求这K条绳子每条最长的长度，答案保留至小数点后二位。 题目分析二分搜索的经典应用，“假定一个解并判断是否可行”。现在我们假定要切割出长度为x的绳子，然后判断能否切割成K条即可。 这道题卡在最后输出答案上了，不能四舍五入，一定要向下取。 source code12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cmath&gt;int N, K;double a[12000];bool judge(double k) &#123; int cnt = 0; for (int i = 0; i &lt; N; i++) &#123; cnt += a[i] / k; &#125; return cnt &gt;= K;&#125;int main() &#123; scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 0; i &lt; N; i++) &#123; scanf(\"%lf\", a + i); &#125; double L = 0.0001, R = 110000; for (int i = 0; i &lt; 100; i++)&#123; double mid = (L + R) / 2; if (judge(mid)) L = mid; else R = mid; &#125; printf(\"%.2lf\\n\", floor(L * 100) / 100);&#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"}]},{"title":"POJ 3662 [Telephone Lines] 题解","date":"2017-11-27T06:21:30.000Z","path":"post/e84ff597.html","text":"题目大意一个无向图，N的点，P条边，给出每条边的长度，定义一条路径的代价为省略路径上的K条边后剩余边的边长最大值。求点1到点N代价最小的路径的代价。 题目分析“最小化最大值”的题目，考虑二分。二分时，设当前设定代价为k，然后考虑在代价为k的约束下能否找到一条可行路径。在寻找路径时，碰到一条边长大于k的边，那么连上这条边需要省略它。显然，一条可行路径就是指路径上所有被省略的边数量不超过K。 那么就可以转化一下，边长大于k的边权值为1，边长小于等于k的边权值为0.然后用dijkstra计算1到n的最短路，如果答案不大于K，说明被省略的边数量不超过K. source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;functional&gt;using namespace std;const int INF = 20344;const int MAX_V = 1500;struct edge &#123; int to, cost; edge(int to, int cost):to(to),cost(cost)&#123;&#125;&#125;;typedef pair&lt;int, int&gt; P;int V;vector&lt;edge&gt; G[MAX_V];int d[MAX_V];int dijkstra(int s, int t, int k) &#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; fill(d + 1, d + V + 1, INF); d[s] = 0; que.push(P(0, s)); while (!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second; if (d[v] &lt; p.first) continue; for (int i = 0; i &lt; G[v].size(); i++) &#123; edge e = G[v][i]; if (d[e.to] &gt; d[v] + (e.cost &gt; k ? 1 : 0)) &#123; d[e.to] = d[v] + (e.cost &gt; k ? 1 : 0); que.push(P(d[e.to], e.to)); &#125; &#125; &#125; return d[t];&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int N, P, K; cin &gt;&gt; N &gt;&gt; P &gt;&gt; K; V = N; for (int i = 0; i &lt; P; i++)&#123; int from, to, cost; cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost; G[from].push_back(edge(to, cost)); G[to].push_back(edge(from, cost)); &#125; int L = -1, R = 1000010; if (dijkstra(1, N, R) == INF) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return 0; &#125; while (L + 1 &lt; R) &#123; int mid = (L + R) &gt;&gt; 1; if (dijkstra(1, N, mid) &lt;= K) R = mid; else L = mid; &#125; cout &lt;&lt; R &lt;&lt; endl;&#125;","tags":[{"name":"binary search","slug":"binary-search","permalink":"http://dafenghh.github.io/tags/binary-search/"},{"name":"graphs","slug":"graphs","permalink":"http://dafenghh.github.io/tags/graphs/"}]},{"title":"codeforces 894D [Ralph And His Tour in Binary Country] round 447 div2D 题解","date":"2017-11-26T01:56:29.000Z","path":"post/2d71363f.html","text":"题目大意给出一棵结点数为n的完全二叉树以及所有边的长度，m次查询，每次查询输入两个正整数A和H，A为起始点，任选树上一个结点（可以选择A本身）作为终点来构成一段旅程，定义这段旅程的快乐值为H-起点到终点的路径长度。求所有快乐值为正的旅程的快乐值的和。 题目分析完全二叉树的性质在这道题要好好利用一下。因为是完全二叉树，所以树的高度为O(log n)级别。这样，我们对每一个结点，建一个数组（vector），记录从这个结点出发往它的子树上所有结点的路径长度，并且排好序。 因为一个结点最多在O(log n)个数组中出现，所以这些数组的总空间为O(n log n).另外每一个结点的数组显然可以由0（到自己的长度）+左儿子数组+右儿子数组 merge而来，那么每次合并使用归并排序，时间复杂度也是O(n log n) 做好这一步预处理后，我们怎么回答每一次询问呢？其实已经很简单了。对结点A，先统计A的子树上的路径，然后A的父节点上移动，统计A的兄弟子树上的路径；接着不断往上移动，直到根节点即可。因为树高为O(log n), 然后每一次统计时采用二分，所以每次查询的复杂度为O(log^2 n) 总复杂度为O(nlog n + mlog^2 n)实现起来还是比较容易的。 source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;typedef long long ll;int L[maxn];vector&lt;ll&gt; dist[maxn], accDist[maxn];int n, m;void calDist(int i) &#123; if (i &lt;= 0 || i &gt; n) return; if (2 * i &lt;= n &amp;&amp; 2 * i + 1 &lt;= n) &#123; calDist(2 * i); calDist(2 * i + 1); dist[i].push_back(0); for (int di = 0; di &lt; dist[2 * i].size(); di++) &#123; dist[i].push_back(dist[2 * i][di] + L[2 * i - 1]); &#125; for (int di = 0; di &lt; dist[2 * i + 1].size(); di++) &#123; dist[i].push_back(dist[2 * i + 1][di] + L[2 * i]); &#125; inplace_merge(dist[i].begin() + 1, dist[i].begin() + 1 + dist[2 * i].size(), dist[i].end()); &#125; else if (2 * i &lt;= n &amp;&amp; 2 * i + 1 &gt; n) &#123; calDist(2 * i); dist[i].push_back(0); for (int di = 0; di &lt; dist[2 * i].size(); di++) &#123; dist[i].push_back(dist[2 * i][di] + L[2 * i - 1]); &#125; &#125; else &#123; dist[i].push_back(0); &#125; ll acc_ = 0; for (int di = 0; di &lt; dist[i].size(); di++)&#123; accDist[i].push_back((acc_ += dist[i][di])); &#125;&#125;ll forSubtree(int v, ll H) &#123; if (H &lt; 0 || v &gt; n) return 0; int pos = upper_bound(dist[v].begin(), dist[v].end(), H) - dist[v].begin(); return H * pos - accDist[v][pos - 1];&#125;ll forPar(int v, int p, ll H) &#123; // calculate happiness int v_ = (v == 2 * p ? 2 * p + 1 : 2 * p); return forSubtree(v_, H - L[v_ - 1]);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt; n; i++) cin &gt;&gt; L[i]; calDist(1); for (int mi = 0; mi &lt; m; mi++) &#123; int A, H; cin &gt;&gt; A &gt;&gt; H; ll ans = forSubtree(A, H); while (A &gt; 1) &#123; H -= L[A - 1]; if (H &lt;= 0) break; ans += H; ans += forPar(A, A / 2, H); A /= 2; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","tags":[{"name":"data structures","slug":"data-structures","permalink":"http://dafenghh.github.io/tags/data-structures/"},{"name":"trees","slug":"trees","permalink":"http://dafenghh.github.io/tags/trees/"}]},{"title":"codeforces 894C [Marco and GCD Sequence] #round 447 div2C 题解","date":"2017-11-25T14:04:20.000Z","path":"post/d93115b9.html","text":"题目分析将输入的数组求一次gcd, 设求出来的值为s，然后判断s是否在原来的数组中。如果不在，那么无解；否则可以构造出一组解，往输入数组的每两个相邻的数中插入一个s，然后就得到一组解。 简单证明这组解是正确的： 设输入数组为a[]，依照上面的方式构造出来的数组为b[]，下面证明：b数组中任意一个区间的gcd值恰好构成集合a。 若i==j，即区间长度为1，那么gcd(b[i]) = b[i]， 而b[i]构成的集合与集合a等价，即表明a[]中的值都是b数组一个区间的gcd值；若i!=j，那么gcd(b[i..j]) = s, s属于集合a。以上两点说明b[]就是答案。 source code1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int gcd(int a, int b)&#123; return b == 0?a:gcd(b, a%b);&#125;int main()&#123; int m; int a[2000]; scanf(\"%d\", &amp;m); set&lt;int&gt; S; for (int i = 0; i &lt; m; i++)&#123; scanf(\"%d\", a + i); S.insert(a[i]); &#125; int g = a[0]; for (int i = 1; i &lt; m; i++) g = gcd(g, a[i]); if (S.count(g))&#123; printf(\"%d\\n%d\", 2 * m - 1, a[0]); for (int i= 1; i &lt; m; i++) printf(\" %d %d\", g, a[i]); printf(\"\\n\"); &#125; else printf(\"-1\\n\");&#125;","tags":[{"name":"constructive algorithms","slug":"constructive-algorithms","permalink":"http://dafenghh.github.io/tags/constructive-algorithms/"},{"name":"math","slug":"math","permalink":"http://dafenghh.github.io/tags/math/"}]},{"title":"ACM训练计划","date":"2017-11-24T12:49:10.000Z","path":"post/3c0e0710.html","text":"从2017年11月25日开始，每天3题的日常任务。","tags":[]}]