<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dafenghh&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/a7b4d3cfc66b429f7c4de28226cdb1a4</icon>
  <subtitle>To Be Top Coder</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dafenghh.github.io/"/>
  <updated>2019-07-04T09:27:28.000Z</updated>
  <id>http://dafenghh.github.io/</id>
  
  <author>
    <name>Dafenghh</name>
    <email>xudafeng88@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Course Note: Software System Analysis and Design</title>
    <link href="http://dafenghh.github.io/post/956bf9e0.html"/>
    <id>http://dafenghh.github.io/post/956bf9e0.html</id>
    <published>2019-07-03T04:22:05.000Z</published>
    <updated>2019-07-04T09:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><h2 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h2><p>软件工程是：<br>(1) 将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件；<br>(2) 在(1)中所述方法的研究.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><blockquote><p>Analysis emphasizes an <strong>investigation</strong> of the problem and requirements, rather than a solution.</p></blockquote><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><blockquote><p>Design emphasizes a <strong>conceptual solution</strong> (in software and hardware) that fulfils the requirements, rather than its implementation.</p></blockquote><h2 id="Object-oriented-analysis"><a href="#Object-oriented-analysis" class="headerlink" title="Object-oriented analysis"></a>Object-oriented analysis</h2><blockquote><p>Object-oriented analysis emphasizes on finding and describing the objects or concepts in the problem domain. </p></blockquote><h2 id="Object-oriented-design"><a href="#Object-oriented-design" class="headerlink" title="Object-oriented design"></a>Object-oriented design</h2><blockquote><p>Object-oriented design emphasizes on defining software objects and how they collaborate to fulfill the requirements. </p></blockquote><h2 id="Unified-Modeling-Language"><a href="#Unified-Modeling-Language" class="headerlink" title="Unified Modeling Language"></a>Unified Modeling Language</h2><blockquote><p>The UML is standard diagramming language to <strong>visualize</strong> the results of analysis and design.</p></blockquote><p>UML is not</p><ul><li>a process or methodology</li><li>object-oriented analysis and design</li><li>guidelines for design</li></ul><h1 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h1><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_notes/waterfall_model.png" alt="瀑布模型" title="">                </div>                <div class="image-caption">瀑布模型</div>            </figure><h2 id="统一过程"><a href="#统一过程" class="headerlink" title="统一过程"></a>统一过程</h2><blockquote><p>The Unified Process (UP) represents a mainstream approach for software development across the spectrum of project scales.</p></blockquote><ul><li>The process is <strong>scalable</strong>: you need not use the entire framework of the process for every project, only those that are effective.</li><li>The process is <strong>effective</strong>: it has been successfully employed on a large population of projects.</li><li>Improves <strong>productivity</strong> through use of practical methods that you’ve probably used already (but didn’t know it).</li><li>Iterative and incremental approach <em>allows start of work with incomplete, imperfect knowledge</em>.</li></ul><h2 id="Unified-Process-Workflows"><a href="#Unified-Process-Workflows" class="headerlink" title="Unified Process Workflows"></a>Unified Process Workflows</h2><blockquote><p>Workflows define a set of activities that are performed<br>Workflows cut across the phases, but with different levels of emphasis in each phase</p></blockquote><p>The core workflows</p><ul><li>Business Modeling</li><li>Requirements analysis</li><li>Design</li><li>Implementation</li><li>Test and Integration</li></ul><h2 id="Use-Case-Driven"><a href="#Use-Case-Driven" class="headerlink" title="Use Case Driven"></a>Use Case Driven</h2><ul><li>Use Case<ul><li>A prose representation of a <strong>sequence of actions</strong></li><li>Actions are performed by one or more <em>actors</em> (human or nonhuman) and the system itself</li><li>These actions lead to valuable results for one or more of the actors, helping the actors to achieve their goals.</li></ul></li><li>Use cases are expressed from the perspective of the users, in natural language, and should be understandable by all stakeholders</li><li>Use-case-driven means the development team employs the use cases from requirements gathering through code and test</li></ul><h2 id="Architecture-Centric"><a href="#Architecture-Centric" class="headerlink" title="Architecture Centric"></a>Architecture Centric</h2><blockquote><p>Software architecture captures decisions about:</p><ul><li>The overall structure of the software system</li><li>The structural elements of the system and their interfaces</li><li>The collaborations among these structural elements and their expected behavior</li></ul></blockquote><p>Architecture-centric: software architecture provides the central point around which all other development evolves </p><ul><li>provides a ‘big picture’ of the system</li><li>provides an organizational framework for development</li></ul><h2 id="Iterative-and-Evolutionary"><a href="#Iterative-and-Evolutionary" class="headerlink" title="Iterative and Evolutionary"></a>Iterative and Evolutionary</h2><p>迭代和进化式开发</p><blockquote><p>An iterative and evolutionary approach allows start of development with incomplete, imperfect knowledge</p></blockquote><p>Advantages:</p><ul><li>Logical <strong>progress</strong> toward a robust architecture（逐步趋向稳定）</li><li>Effective management of <strong>changing requirements</strong>（有效管理需求变化）</li><li>Continuous integration（持续集成）</li><li>Early understanding of the system （尽早接触整个系统）</li><li>Ongoing risk assessment（在线风险评估）</li></ul><h2 id="UP-Phases"><a href="#UP-Phases" class="headerlink" title="UP Phases"></a>UP Phases</h2><ol><li>Inception 初始：大体上的构想、业务案例、范围和模糊评估</li><li>Elaboration 细化：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估</li><li>Construction 构造：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署。</li><li>Transition 移交：进行beta测试和部署。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_notes/rup_process_model.png" alt="RUP Process model" title="">                </div>                <div class="image-caption">RUP Process model</div>            </figure><h1 id="Inception"><a href="#Inception" class="headerlink" title="Inception"></a>Inception</h1><p>Envision the product scope, vision, and business case.</p><p>初始阶段更关注对基本范围的理解以及10%的需求。</p><h1 id="Evolutionary-Requirement"><a href="#Evolutionary-Requirement" class="headerlink" title="Evolutionary Requirement"></a>Evolutionary Requirement</h1><p>进化式需求</p><p>在统一过程中，需求按照”FURPS+”模型进行分裂。</p><ul><li><strong>Functional</strong>: features, capability, security</li><li><strong>Usability</strong>: human factors, help, documentation</li><li><strong>Reliability</strong>: frequency of failure, recoverability, predictability</li><li><strong>Performance</strong>: response times, throughput, accuracy,availability, resource usage.</li><li><strong>Supportability</strong>: adaptability, maintainability, internationalization, configurability</li></ul><p>The ‘+’ in FURPS+ indicates sub-factors</p><ul><li>Implementation: resource limitation, languages and tools, hardware…</li><li>Interface: constraint imposed by interfacing with external systems</li><li>Operations: system management in its operational setting</li><li>Packaging: a physical box</li><li>Legal (授权): 许可证等</li></ul><h1 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h1><p>用例是文本形式的情节描述。</p><p>用例建模主要是编写文本的活动，而非制图。</p><h2 id="Actors"><a href="#Actors" class="headerlink" title="Actors"></a>Actors</h2><ul><li>Primary actor has user goals fulfilled through using services. (e.g. the cashier)</li><li>Supporting actor provides a service (e.g. the automated payment authorization service is an example)<ul><li>to clarify external interfaces and protocols 明确外部接口和协议</li></ul></li><li>Offstage actor has an interest in the behavior of the use case, but is not primary or supporting (e.g. a government tax agency)</li></ul><p>详述用例(fully dressed use case)是结构化的，展示了更多细节，并且更为深入。</p><h2 id="用例模板"><a href="#用例模板" class="headerlink" title="用例模板"></a>用例模板</h2><ul><li>用例名称</li><li>范围</li><li>级别</li><li>主要参与者</li><li>涉众及其关注点</li><li>前置条件</li><li>主成功场景</li><li>扩展</li><li>特殊需求</li><li>技术和数据变元表</li><li>发生频率</li></ul><h2 id="Guideline-to-Write-Use-Case"><a href="#Guideline-to-Write-Use-Case" class="headerlink" title="Guideline to Write Use Case"></a>Guideline to Write Use Case</h2><ul><li>Write in an essential UI-free style</li><li>Write terse use case</li><li>Write black-box use case</li><li>take an actor and actor-goal perspective</li></ul><p>How to find use case?</p><blockquote><p>Use cases are defined to satisfy the goals of the primary actors. The basic procedure is:</p></blockquote><ol><li>Choose the system boundary. Is it just a software application, the hardware and application as a unit, that plus a person using it, or an entire organization?</li><li>Identify the primary actors that have goals fulfilled through using services of the system.</li><li>Identify the goals for each primary actor.</li><li>Define use cases that satisfy user goals; name them according to their goal. </li></ol><h2 id="Find-Actors-and-Goals-Event-Analysis"><a href="#Find-Actors-and-Goals-Event-Analysis" class="headerlink" title="Find Actors and Goals: Event Analysis"></a>Find Actors and Goals: Event Analysis</h2><ul><li>Event Based<ul><li>to identify external events that a system must respond to.</li><li>What are they, where from, and why? Often, a group of events belong to the same use case.</li><li>Relate the events to actors and use cases.</li></ul></li></ul><h2 id="识别用例准则"><a href="#识别用例准则" class="headerlink" title="识别用例准则"></a>识别用例准则</h2><ul><li>Boss Test</li><li>EBP Test (Elementary Business Process)<blockquote><p>A task performed by one person in one place at one time, in response to a business event, which adds measurable business value and leaves the data in a consistent state.</p></blockquote></li><li>Size Test</li></ul><h2 id="UML-活动图"><a href="#UML-活动图" class="headerlink" title="UML 活动图"></a>UML 活动图</h2><p>应用场合</p><blockquote><p>描述某一用例中执行的步骤，使复杂的多场景用例以及与Include或extend用例的关系可视化。<br>描述用户和系统之间的业务流程协作。<br>描述软件中的方法、函数或操作。（描述算法）</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_notes/uml_activity.png" alt="UML activicy" title="">                </div>                <div class="image-caption">UML activicy</div>            </figure><h1 id="Domain-Model"><a href="#Domain-Model" class="headerlink" title="Domain Model"></a>Domain Model</h1><p>领域模型表示真实世界概念类。</p><p>Provides a conceptual perspective: </p><ul><li>domain objects or conceptual classes</li><li>associations between conceptual classes</li><li>attributes of conceptual classes</li></ul><h2 id="Guideline-Find-Conceptual-Classes"><a href="#Guideline-Find-Conceptual-Classes" class="headerlink" title="Guideline: Find Conceptual Classes"></a>Guideline: Find Conceptual Classes</h2><ul><li>Identify noun phrases.<ul><li>Identify the <strong>nouns and noun phrases</strong> in textual descriptions of a domain, and consider them as candidate conceptual classes or attributes</li><li>Some of these noun phrases may refer to conceptual classes that are ignored in this iteration (e.g., “Accounting” and “commissions”), and some may be simply attributes of conceptual classes.</li><li>A weakness of this approach is the imprecision of natural language; different noun phrases may represent the same conceptual class or attribute, among other ambiguities.</li></ul></li></ul><h3 id="A-Common-Mistake-with-Attributes-vs-Classes"><a href="#A-Common-Mistake-with-Attributes-vs-Classes" class="headerlink" title="A Common Mistake with Attributes vs. Classes"></a>A Common Mistake with Attributes vs. Classes</h3><blockquote><p>If we do not think of some conceptual class X as a number or text in the real world, X is probably a conceptual class, not an attribute.</p></blockquote><h3 id="When-to-Model-with-‘Description’-Classes"><a href="#When-to-Model-with-‘Description’-Classes" class="headerlink" title="When to Model with ‘Description’ Classes"></a>When to Model with ‘Description’ Classes</h3><p>何时需要描述类：</p><ul><li>需要有关商品或服务的描述，独立于任何商品或服务的现有实例。</li><li>避免删除所有示例后，原有的商品描述信息丢失。</li><li>减少冗余或重复信息。</li></ul><h2 id="Association"><a href="#Association" class="headerlink" title="Association"></a>Association</h2><ul><li>A is a part of B</li><li>A contains B</li><li>A descibes B</li><li>A is logged/recorded/reported/captured in B</li><li>A is a member of B</li><li>A is a subunit of B</li><li>A uses or manages or owns B</li></ul><h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><h3 id="导出属性"><a href="#导出属性" class="headerlink" title="导出属性"></a>导出属性</h3><p>在属性名称前加’/‘</p><h3 id="准则：任何属性都不表示外键"><a href="#准则：任何属性都不表示外键" class="headerlink" title="准则：任何属性都不表示外键"></a>准则：任何属性都不表示外键</h3><p>领域模型中，不能将外键作为属性，应当使用关联。</p><h3 id="准则：对数量和单位建模"><a href="#准则：对数量和单位建模" class="headerlink" title="准则：对数量和单位建模"></a>准则：对数量和单位建模</h3><p>大部分用数字表示的数量不应该表示为纯数字，应该加上单位。</p><h2 id="状态模型"><a href="#状态模型" class="headerlink" title="状态模型"></a>状态模型</h2><blockquote><p>状态图描述一个 事物或对象 受 事件或消息 刺激产生 可见的状态（属性/属性组合） 的数据变化。</p></blockquote><ul><li>基础符号<ul><li>起始状态（Initial）</li><li>终止状态（Final）</li><li>取消/对象取消（Termination）</li><li>状态（State）</li><li>变迁（Transform），含条件（Condition）、事件（Event）和事件处理动作（Action/Handler）</li></ul></li><li>扩展符号<ul><li>复合状态</li><li>信号</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;intro&quot;&gt;&lt;a href=&quot;#intro&quot; class=&quot;headerlink&quot; title=&quot;intro&quot;&gt;&lt;/a&gt;intro&lt;/h1&gt;&lt;h2 id=&quot;软件工程的定义&quot;&gt;&lt;a href=&quot;#软件工程的定义&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="SystemDesign" scheme="http://dafenghh.github.io/categories/SystemDesign/"/>
    
    
      <category term="Notes" scheme="http://dafenghh.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 Homework 5</title>
    <link href="http://dafenghh.github.io/post/e1d7adc4.html"/>
    <id>http://dafenghh.github.io/post/e1d7adc4.html</id>
    <published>2019-05-15T01:24:11.000Z</published>
    <updated>2019-07-04T07:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="订旅馆建模"><a href="#订旅馆建模" class="headerlink" title="订旅馆建模"></a>订旅馆建模</h1><h2 id="绘制用例图模型（到子用例）"><a href="#绘制用例图模型（到子用例）" class="headerlink" title="绘制用例图模型（到子用例）"></a>绘制用例图模型（到子用例）</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework5/RH_use_case.png" alt="Rerserve Hotel Use Case" title="">                </div>                <div class="image-caption">Rerserve Hotel Use Case</div>            </figure><h2 id="给出-make-reservation-用例的活动"><a href="#给出-make-reservation-用例的活动" class="headerlink" title="给出 make reservation 用例的活动"></a>给出 make reservation 用例的活动</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework5/RH_activity.png" alt="Rerserve Hotel Activity" title="">                </div>                <div class="image-caption">Rerserve Hotel Activity</div>            </figure><h1 id="课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"><a href="#课程练习“投递员使用投递箱给收件人快递包裹”的业务场景" class="headerlink" title="课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"></a>课程练习“投递员使用投递箱给收件人快递包裹”的业务场景</h1><h2 id="分别用多泳道图建模三个场景的业务过程"><a href="#分别用多泳道图建模三个场景的业务过程" class="headerlink" title="分别用多泳道图建模三个场景的业务过程"></a>分别用多泳道图建模三个场景的业务过程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework5/swim1.png" alt="场景1" title="">                </div>                <div class="image-caption">场景1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework5/swim2.png" alt="场景2" title="">                </div>                <div class="image-caption">场景2</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework5/swim3.png" alt="场景3" title="">                </div>                <div class="image-caption">场景3</div>            </figure><h2 id="根据上述流程，给出快递柜系统最终的用例图模型"><a href="#根据上述流程，给出快递柜系统最终的用例图模型" class="headerlink" title="根据上述流程，给出快递柜系统最终的用例图模型"></a>根据上述流程，给出快递柜系统最终的用例图模型</h2><blockquote><p>用正常色彩表示第一个业务流程反映的用例<br>用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor<br>用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework5/express_use_case.png" alt="快递柜 Use Case" title="">                </div>                <div class="image-caption">快递柜 Use Case</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;订旅馆建模&quot;&gt;&lt;a href=&quot;#订旅馆建模&quot; class=&quot;headerlink&quot; title=&quot;订旅馆建模&quot;&gt;&lt;/a&gt;订旅馆建模&lt;/h1&gt;&lt;h2 id=&quot;绘制用例图模型（到子用例）&quot;&gt;&lt;a href=&quot;#绘制用例图模型（到子用例）&quot; class=&quot;header
      
    
    </summary>
    
      <category term="SystemDesign" scheme="http://dafenghh.github.io/categories/SystemDesign/"/>
    
    
      <category term="homework" scheme="http://dafenghh.github.io/tags/homework/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 Homework 4</title>
    <link href="http://dafenghh.github.io/post/96d09d52.html"/>
    <id>http://dafenghh.github.io/post/96d09d52.html</id>
    <published>2019-05-04T02:12:52.000Z</published>
    <updated>2019-07-04T02:34:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="用例的概念"><a href="#用例的概念" class="headerlink" title="用例的概念"></a>用例的概念</h2><p>用例是一组相关的成功和失败场景集合，用来描述参与者如何使用系统来实现其目标。</p><h2 id="用例和场景的关系？什么是主场景或-happy-path？"><a href="#用例和场景的关系？什么是主场景或-happy-path？" class="headerlink" title="用例和场景的关系？什么是主场景或 happy path？"></a>用例和场景的关系？什么是主场景或 happy path？</h2><p>场景也称为用例实例。一个用例代表了场景的集合，包含主场景和一些可选场景。主场景相当于主要的系统交互，即成功场景。</p><h2 id="用例有哪些形式？"><a href="#用例有哪些形式？" class="headerlink" title="用例有哪些形式？"></a>用例有哪些形式？</h2><ul><li>Brief 摘要</li><li>Casual 非正式</li><li>Fully 详述</li></ul><h2 id="对于复杂业务，为什么编制完整用例非常难？"><a href="#对于复杂业务，为什么编制完整用例非常难？" class="headerlink" title="对于复杂业务，为什么编制完整用例非常难？"></a>对于复杂业务，为什么编制完整用例非常难？</h2><p>复杂业务涉及的故事和场景非常多，用例的完全性依赖于其编写者。</p><h2 id="什么是用例图？"><a href="#什么是用例图？" class="headerlink" title="什么是用例图？"></a>什么是用例图？</h2><p>用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。 用例图（User Case）是外部用户（被称为参与者）所能观察到的系统功能的模型图。</p><h2 id="用例图的基本符号与元素？"><a href="#用例图的基本符号与元素？" class="headerlink" title="用例图的基本符号与元素？"></a>用例图的基本符号与元素？</h2><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">椭圆</td><td style="text-align:center">表示每个用例</td></tr><tr><td style="text-align:center">矩形框</td><td style="text-align:center">表示整个系统</td></tr><tr><td style="text-align:center">小人</td><td style="text-align:center">绘制在矩形框外，表示参与者</td></tr><tr><td style="text-align:center">连线</td><td style="text-align:center">连接某一参与者与某一用例，表示该参与者和该用例有交互</td></tr><tr><td style="text-align:center">箭头</td><td style="text-align:center">用例之间的包含关系/扩展关系/泛化关系</td></tr></tbody></table><h2 id="用例图的画法与步骤"><a href="#用例图的画法与步骤" class="headerlink" title="用例图的画法与步骤"></a>用例图的画法与步骤</h2><ol><li>绘制“子系统”边界, 重命名“子系统”</li><li>绘制参与者（放在所有系统边界之外）, 重命名参与者</li><li>绘制用例<br> a) 使用参与者自身能够理解的名称重命名用例，不要使用与代码有关的名称<br> b) 从主要的事务开始，直到后面较小的交互为止<br> c) 将每个用例放入支持它的系统或主要子系统（忽略只与用户有关的外观或组件）<br> d) 可以在系统边界外绘制用例，表明系统不支持该用例</li><li>将参与者与用例相连</li><li>使用“包括”、“扩展”和“泛化”关系结构化用例</li></ol><h2 id="用例图给利益相关人与开发者的价值有哪些？"><a href="#用例图给利益相关人与开发者的价值有哪些？" class="headerlink" title="用例图给利益相关人与开发者的价值有哪些？"></a>用例图给利益相关人与开发者的价值有哪些？</h2><ol><li>利益相关人：更加清楚系统的功能和用途</li><li>开发者：更加清楚用户需求和软件使用方式，使软件架构的设计思路更清晰。</li></ol><h1 id="建模练习题（用例模型）"><a href="#建模练习题（用例模型）" class="headerlink" title="建模练习题（用例模型）"></a>建模练习题（用例模型）</h1><blockquote><p>选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：</p><ul><li>请使用用户的视角，描述用户目标或系统提供的服务</li><li>粒度达到子用例级别，并用 include 和 exclude 关联它们</li><li>请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例</li><li>尽可能识别外部系统和服务</li></ul></blockquote><p>选择背单词APP百词斩，绘制用例图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework4/baicizhan_use_case.png" alt="百词斩" title="">                </div>                <div class="image-caption">百词斩</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework4/shanbei_use_case.png" alt="扇贝" title="">                </div>                <div class="image-caption">扇贝</div>            </figure><blockquote><p>然后，回答下列问题：<br>为什么相似系统的用例图是相似的？</p></blockquote><p>因为相似系统的需求也相近，用户需要的功能相近，所以用例图也是相似的。</p><blockquote><p>如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用</p></blockquote><p>因为用例图可以表示出用户在实现某个目标所需要经过的关键步骤，因此可以在这些关键步骤中寻找业务创新、技术创新、商业模式创新。比如背单词APP可以在问题的设置上寻求创新，百词斩的创新是以图片帮助记忆，扇贝的创新是由用户选择是否记得一个单词。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;h2 id=&quot;用例的概念&quot;&gt;&lt;a href=&quot;#用例的概念&quot; class=&quot;headerlink&quot; title=&quot;用例的概念&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="SystemDesign" scheme="http://dafenghh.github.io/categories/SystemDesign/"/>
    
    
      <category term="homework" scheme="http://dafenghh.github.io/tags/homework/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 Homework 3</title>
    <link href="http://dafenghh.github.io/post/8b408f1.html"/>
    <id>http://dafenghh.github.io/post/8b408f1.html</id>
    <published>2019-04-29T08:37:16.000Z</published>
    <updated>2019-07-04T02:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。"><a href="#简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。" class="headerlink" title="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。"></a>简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。</h2><blockquote><p>从项目特点、风险特征、人力资源利用角度思考</p></blockquote><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型试图在编程之前详细定义所有或大部分需求，通常在编程之前创建出完整的设计，会试图在开始前定义“可靠的”计划或时间表，但往往事与愿违。</p><p>瀑布模型带来了高失败率，低生产率和高缺陷率。原因：软件开发的需求是时常变化的。变更对于软件项目来说是永恒的。计划很难是一成不变的，几乎不可能在开始阶段就确立好详细计划。计划必须要随项目进行而动态修改，以适应新的需求和风险。</p><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件。运用增量模型的软件开发过程是递增式的过程。相对于瀑布模型而言，采用增量模型进行开发，开发人员不需要一次性地把整个软件产品提交给用户，而是可以分批次进行提交。</p><p>增量模型适用于具有以下特征的软件开发项目：</p><ol><li>软件产品可以分批次地进行交付。</li><li>待开发的软件系统能够被模块化。</li><li>软件开发人员对应用领域不熟悉，难以一次性地进行系统开发。</li><li>项目管理人员把握全局的水平较高。</li></ol><p>增量模型对软件设计有更高的技术要求，特别是对软件体系结构，要求它具有很好的开放性与稳定性，能够顺利地实现构件的集成。增量构件要求具有相当好的功能独立性，其接口应该简单，以方便集成时与系统的连接。$[1]$</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级的软件应用。$[2]$</p><h2 id="简述统一过程三大特点，与面向对象的方法有什么关系？"><a href="#简述统一过程三大特点，与面向对象的方法有什么关系？" class="headerlink" title="简述统一过程三大特点，与面向对象的方法有什么关系？"></a>简述统一过程三大特点，与面向对象的方法有什么关系？</h2><ol><li>可伸缩性(scalable)：不需要使用统一过程的全部框架，只需要有用的部分。</li><li>有效性(effective): 统一过程已被大量项目成功实践。</li><li>用已有的实践方法提高生产效率(productivity)。</li></ol><h2 id="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"><a href="#简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？" class="headerlink" title="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"></a>简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</h2><p>划分准则是达成里程碑的时间点。</p><ol><li><p>初始阶段<br>生命周期目标里程碑：评价项目基本的生存能力。</p></li><li><p>细化阶段<br>生命周期结构里程碑：为系统的结构简历管理基准并使得项目小组能够在构建阶段中进行衡量，需要检验详细的系统目标和范围、结构的选择以及主要风险的解决方案。</p></li><li><p>构造阶段<br>初始功能里程碑：决定产品是否可以在测试环境中进行部署，要确定软件、环境、用户是否可以开始系统的运作。</p></li><li><p>交付阶段<br>产品发布里程碑：确定目标是否实现，是否应该开始另一个开发周期。</p></li></ol><h2 id="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"><a href="#软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？" class="headerlink" title="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"></a>软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</h2><p>软件企业可以按固定节奏生产，固定周期发布软件产品，是因为软件企业有规范的管理体系和方法，了解软件的本质特征，能够很好地认识项目的工期、质量、范围、预算，遵循先做到再做好的原则，运用了正确的开发模型。</p><p>它可以使得企业项目管理具有明确的阶段划分，由于每个阶段都会有显著的里程碑，使得每个迭代阶段都有明确的目标。这反逼项目管理确定合理的产品范围，不投入大量时间在冗余的工作中，从而提到团队生产效率。</p><p>Reference:<br>1: <a href="https://baike.baidu.com/item/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">增量模型_百度百科</a><br>2: <a href="https://baike.baidu.com/item/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">螺旋模型_百度百科</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;h2 id=&quot;简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。&quot;&gt;&lt;a href=&quot;#简述瀑布模型、增量模型、螺旋模型（含
      
    
    </summary>
    
      <category term="SystemDesign" scheme="http://dafenghh.github.io/categories/SystemDesign/"/>
    
    
      <category term="homework" scheme="http://dafenghh.github.io/tags/homework/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 Homework 2</title>
    <link href="http://dafenghh.github.io/post/7fb33867.html"/>
    <id>http://dafenghh.github.io/post/7fb33867.html</id>
    <published>2019-04-03T03:59:59.000Z</published>
    <updated>2019-07-03T04:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="用简短的语言给出对分析、设计的理解。"><a href="#用简短的语言给出对分析、设计的理解。" class="headerlink" title="用简短的语言给出对分析、设计的理解。"></a>用简短的语言给出对分析、设计的理解。</h2><p>分析是捕捉现实世界的业务的特性，描述处理的数据和处理数据的各种过程，得到软件需求。</p><p>设计是根据软件需求，对软件结构、功能进行规划、拆分，构建可实现的解决方案。</p><h2 id="用一句话描述面向对象的分析与设计的优势。"><a href="#用一句话描述面向对象的分析与设计的优势。" class="headerlink" title="用一句话描述面向对象的分析与设计的优势。"></a>用一句话描述面向对象的分析与设计的优势。</h2><p>对象的引入方便了在软件虚拟世界中模拟现实世界，面向对象方法带来更强的封装能力，有利于模块化开发。封装、抽象、继承和多态，提高了软件的可重用性、可维护性和可扩展性。</p><h2 id="简述-UML（统一建模语言）的作用。考试考哪些图？"><a href="#简述-UML（统一建模语言）的作用。考试考哪些图？" class="headerlink" title="简述 UML（统一建模语言）的作用。考试考哪些图？"></a>简述 UML（统一建模语言）的作用。考试考哪些图？</h2><ul><li>UML以图形作为表现形式，产生的模型清晰简洁，易于理解。</li><li>有利于开发人员与用户之间的沟通。</li><li>用UML进行系统建模得到的建模制品不仅仅包含各种模型框图，还有大量丰富的文档，这些文档给系统后期的维护工作带来了便捷。</li><li>用UML作为编程语言，使用UML完成软件系统的执行规范，可运行的代码就能够被自动生成。</li><li>用UML敏捷建模，与草图的功能类似，通过建立UML顺序图，能够提高开发的质量和速度。</li></ul><p>考试要考：</p><ul><li>用例图：(用户角度) 功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态写作关系</li></ul></li><li>状态图：对象的动态行为。状态 - 事件 - 状态迁移 - 响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布状况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul><h2 id="从软件本质的角度，解释软件范围（需求）控制的可行性"><a href="#从软件本质的角度，解释软件范围（需求）控制的可行性" class="headerlink" title="从软件本质的角度，解释软件范围（需求）控制的可行性"></a>从软件本质的角度，解释软件范围（需求）控制的可行性</h2><p>对需求进行限制，有利于需求更加清晰明确，降低管理成本。需求频繁变更会带来严重成本，限制需求范围可减少变更数量，使开发更有效率。</p><h1 id="项目管理实践"><a href="#项目管理实践" class="headerlink" title="项目管理实践"></a>项目管理实践</h1><h2 id="看板使用练习"><a href="#看板使用练习" class="headerlink" title="看板使用练习"></a>看板使用练习</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework2/kanban.png" alt="看板练习" title="">                </div>                <div class="image-caption">看板练习</div>            </figure><h2 id="UML绘图工具练习"><a href="#UML绘图工具练习" class="headerlink" title="UML绘图工具练习"></a>UML绘图工具练习</h2><p>画系统顺序图，课本129页 P10-3<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/system_design_homework/homework2/system_sequence_diagram.png" alt="系统顺序图" title="">                </div>                <div class="image-caption">系统顺序图</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;h2 id=&quot;用简短的语言给出对分析、设计的理解。&quot;&gt;&lt;a href=&quot;#用简短的语言给出对分析、设计的理解。&quot; class=&quot;head
      
    
    </summary>
    
      <category term="SystemDesign" scheme="http://dafenghh.github.io/categories/SystemDesign/"/>
    
    
      <category term="homework" scheme="http://dafenghh.github.io/tags/homework/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 Homework 1</title>
    <link href="http://dafenghh.github.io/post/e6ba69dd.html"/>
    <id>http://dafenghh.github.io/post/e6ba69dd.html</id>
    <published>2019-03-17T13:45:28.000Z</published>
    <updated>2019-03-17T14:44:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="1-软件工程的定义"><a href="#1-软件工程的定义" class="headerlink" title="1. 软件工程的定义"></a>1. 软件工程的定义</h2><p>简单来讲，软件工程即软件开发领域里对工程方法的系统应用。</p><p>IEEE对软件工程的定义是将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中。</p><h2 id="2-解释导致-software-crisis-本质原因、表现，述说克服软件危机的方法"><a href="#2-解释导致-software-crisis-本质原因、表现，述说克服软件危机的方法" class="headerlink" title="2. 解释导致 software crisis 本质原因、表现，述说克服软件危机的方法"></a>2. 解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</h2><p>软件危机是由于计算机能力的迅速增加以及无法解决的问题的复杂性，而导致软件危机的本质原因是软件的复杂性、一致性、可变性和不可视性。典型表现有以下几种：</p><ul><li>项目运行超出预算</li><li>项目运行时间过长</li><li>软件效率低</li><li>软件质量差</li><li>软件不符合要求</li><li>项目难以管理，代码难以维护</li><li>软件无法成功交付</li></ul><p>克服软件危机的方法是系统化、与时俱进的软件工程。</p><h2 id="3-软件生命周期"><a href="#3-软件生命周期" class="headerlink" title="3. 软件生命周期"></a>3. 软件生命周期</h2><p>软件生命周期是软件的产生直到报废的生命周期，周期内有问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级到废弃等阶段，这种按时间分程的思想方法是软件工程中的一种思想原则，即按部就班、逐步推进，每个阶段都要有定义、工作、审查、形成文档以供交流或备查，以提高软件的质量。</p><h2 id="4-SWEBoK-的-15-个知识域（An-Overview-of-the-SWEBOK-Guide-请中文翻译其名称与简短说明）"><a href="#4-SWEBoK-的-15-个知识域（An-Overview-of-the-SWEBOK-Guide-请中文翻译其名称与简短说明）" class="headerlink" title="4. SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）"></a>4. SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）</h2><h3 id="1-Software-Requirements"><a href="#1-Software-Requirements" class="headerlink" title="(1) Software Requirements"></a>(1) Software Requirements</h3><p>软件需求。</p><p>软件需求知识域关注的方面是软件需求的启发，协商，分析，规范和验证。人们普遍认为，若需求不清晰，则软件项目会变得很脆弱。软件需求表达了对软件产品的需求和限制，这些需求和约束有助于解决一些现实问题。</p><h3 id="2-Software-Design"><a href="#2-Software-Design" class="headerlink" title="(2) Software Design"></a>(2) Software Design</h3><p>软件设计。</p><p>设计的定义是：定义体系结构、组建、接口以及其他系统或组建特性的过程和结果。</p><p>软件设计知识域涵盖了设计过程和最终产品。软件设计过程是软件工程生命周期活动，包括分析软件需求以产生软件内部结构及其行为的描述，将其作为其构造的基础。软件设计（结果）必须描述软件体系结构，即软件如何分解和组织成组件与组件之间的接口。</p><h3 id="3-Software-Construction"><a href="#3-Software-Construction" class="headerlink" title="(3) Software Construction"></a>(3) Software Construction</h3><p>软件构建。</p><p>软件构建是指通过结合详细设计，编码，单元测试，集成测试，调试和验证来详细创建工作软件。</p><h3 id="4-Software-Testing"><a href="#4-Software-Testing" class="headerlink" title="(4) Software Testing"></a>(4) Software Testing</h3><p>软件测试。</p><p>测试是一项旨在评估产品质量并通过识别缺陷来改进产品质量的活动。软件测试涉及在有限的测试用例集上针对预期行为动态验证程序的行为。这些测试用例是从（通常非常大的）执行域中选择的。软件测试知识域包括软件测试的基础知识、测试技术、交互界面测试与评估、与测试有关的方法和实际考虑。</p><h3 id="5-Software-Maintenance"><a href="#5-Software-Maintenance" class="headerlink" title="(5) Software Maintenance"></a>(5) Software Maintenance</h3><p>软件维护。</p><p>软件维护包括增强现有功能，调整软件以在新的和修改的操作环境中运行，以及纠正缺陷。这些类别分别称为完善，自适应和纠正性软件维护。软件维护知识域包括软件维护的基础知识（维护的性质和需求，维护类别，维护成本）、软件维护中的关键问题（技术问题，管理问题，维护成本估算，软件维护测量）、维护过程、 软件维护技术（程序理解，重新设计，逆向工程，重构，软件退役）、 灾难恢复技术和软件维护工具。</p><h3 id="6-Software-Configuration-Management"><a href="#6-Software-Configuration-Management" class="headerlink" title="(6) Software Configuration Management"></a>(6) Software Configuration Management</h3><p>软件配置管理。</p><p>系统的配置是硬件，固件，软件或这些的组合的功能和物理特征。软件配置管理（SCM）是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。软件配置管理知识域涵盖SCM过程的管理、软件配置识别，控制，状态核算，审计、软件发布管理和交付.</p><h3 id="7-Software-Engineering-Management"><a href="#7-Software-Engineering-Management" class="headerlink" title="(7) Software Engineering Management"></a>(7) Software Engineering Management</h3><p>软件工程管理。</p><p>软件工程管理涉及规划，协调，测量，报告和控制项目或程序，以确保软件的开发和维护是系统化的，规范化的和量化的。软件工程管理知识域涵盖了启动和范围定义（确定和协商要求，可行性分析以及要求的审查和修订）; 软件项目计划（过程计划，工作量估算，成本和进度，资源分配，风险分析，质量计划）; 软件项目制定（计量，报告和控制;收购和供应商合同管理）; 产品验收; 审查和分析项目绩效; 项目结束; 和软件管理工具。</p><h3 id="8-Software-Engineering-Process"><a href="#8-Software-Engineering-Process" class="headerlink" title="(8) Software Engineering Process"></a>(8) Software Engineering Process</h3><p>软件工程过程。</p><h3 id="9-Software-Engineering-Models-and-Methods"><a href="#9-Software-Engineering-Models-and-Methods" class="headerlink" title="(9) Software Engineering Models and Methods"></a>(9) Software Engineering Models and Methods</h3><p>软件工程模型和方法。<br>软件工程模型和方法知识域提出了不同生命周期阶段的工程方法。<br>包括建模、模型类型、分析和软件开发方法。</p><h3 id="10-Software-Quality"><a href="#10-Software-Quality" class="headerlink" title="(10) Software Quality"></a>(10) Software Quality</h3><p>软件质量。<br>软件质量是软件生命周期中无处不在的关注点。<br>软件质量知识域涵盖了软件质量基础、软件质量管理过程和实际考虑。</p><h3 id="11-Software-Engineering-Professional-Practice"><a href="#11-Software-Engineering-Professional-Practice" class="headerlink" title="(11) Software Engineering Professional Practice"></a>(11) Software Engineering Professional Practice</h3><p>软件工程专业实践。</p><p>软件工程专业实践是关于软件工程师进行专业、负责、合乎道德的软件工程实践时所需要的知识、技术和态度。<br>软件工程专业实践知识域包含敬业精神、道德准则、小组活力和交流技巧。</p><h3 id="12-Software-Engineering-Economics"><a href="#12-Software-Engineering-Economics" class="headerlink" title="(12) Software Engineering Economics"></a>(12) Software Engineering Economics</h3><p>软件工程经济学。</p><p>软件工程经济学知识域关注的是在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。涵盖的主题包括软件工程经济学的基本原理、非营利性决策、经济风险和不确定性估计和多属性决策。</p><h3 id="13-Computing-Foundations"><a href="#13-Computing-Foundations" class="headerlink" title="(13) Computing Foundations"></a>(13) Computing Foundations</h3><p>计算基础。<br>计算基础知识域涵盖了提供软件工程实践所需的计算基础主题。涵盖的主题包括问题解决技术，抽象，算法和复杂度，编程基础，并行和分布式计算的基础知识，计算机组成原理，操作系统和网络通信。</p><h3 id="14-Mathematical-Foundations"><a href="#14-Mathematical-Foundations" class="headerlink" title="(14) Mathematical Foundations"></a>(14) Mathematical Foundations</h3><p>数学基础。<br>数学基础知识域涵盖了提供软件工程实践所必需的数学背景的基础主题。涵盖的主题包括集合，关系和函数; 基本命题和谓词逻辑; 证明技巧; 图形和树; 离散概率; 语法和有限状态机和数论。</p><h3 id="15-Engineering-Foundations"><a href="#15-Engineering-Foundations" class="headerlink" title="(15) Engineering Foundations"></a>(15) Engineering Foundations</h3><p>工程基础。</p><p>工程基础知识域涵盖了提供软件工程实践所必需的工程背景的基础主题。涵盖的主题包括经验方法和实验技术; 统计分析; 测量和指标; 工程设计; 仿真与建模以及根本原因分析。</p><h2 id="5-简单解释-CMMI-的五个级别。例如：Level-1-Initial：无序，自发生产模式。"><a href="#5-简单解释-CMMI-的五个级别。例如：Level-1-Initial：无序，自发生产模式。" class="headerlink" title="5. 简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。"></a>5. 简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。</h2><h2 id="6-用自己语言简述-SWEBok-或-CMMI-（约200字）"><a href="#6-用自己语言简述-SWEBok-或-CMMI-（约200字）" class="headerlink" title="6. 用自己语言简述 SWEBok 或 CMMI （约200字）"></a>6. 用自己语言简述 SWEBok 或 CMMI （约200字）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;h2 id=&quot;1-软件工程的定义&quot;&gt;&lt;a href=&quot;#1-软件工程的定义&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="SystemDesign" scheme="http://dafenghh.github.io/categories/SystemDesign/"/>
    
    
      <category term="homework" scheme="http://dafenghh.github.io/tags/homework/"/>
    
  </entry>
  
  <entry>
    <title>CCPC-Wannafly Winter Camp 2019 Day 4 题解</title>
    <link href="http://dafenghh.github.io/post/5505493b.html"/>
    <id>http://dafenghh.github.io/post/5505493b.html</id>
    <published>2019-01-24T23:49:58.000Z</published>
    <updated>2019-01-25T02:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="H-命命命运"><a href="#H-命命命运" class="headerlink" title="H 命命命运"></a>H 命命命运</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>wls等六人在玩大富翁。</p><p>大富翁的棋盘上一共有n块地，这些地围成了一个圈（n号地的下一块地是1号地）。</p><p>每一轮，六个玩家会依次掷出一颗骰子（编号小的玩家先掷），并往前走骰子上显示的数字那么多步。</p><p>第一个踩到某块地的玩家能够得到这块地。</p><p>给出<code>p[i][j]</code>, 表示第i个玩家掷出j的概率。</p><p>现在请问，500轮以后，每个玩家拥有的地的块数的期望分别是多少？</p><p>所有人都从1号点出发，出发前大家不能买地（第二次到1号点才能买这块地）。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们需要求出对于i号玩家，第j轮，获得第k块地的概率，然后把所有j,k取值下的概率累加起来，就是每个人获得地的块数的期望。i号玩家，获得第j块地等价于<code>1..(i-1)</code>号玩家前j轮不曾走到k，i号玩家第j轮第一次走到k，<code>(i+1)..6</code>号玩家前(j-1)轮未曾走到k.</p><p>于是我们要求出两个概率来，<code>never[i][j][k]</code>表示i号玩家前j轮未曾走到k的概率，<code>first[i][j][k]</code>表示i号玩家第j轮第一次走到k的概率。</p><p>为了求出这两个东西，我们还需要一维状态，即玩家当前所处的位置。所以<code>pos[i][j][k][m]</code>表示i号玩家前j轮未曾走到k，走完第i轮后位于m的概率。</p><p>转移式很好写出来。于是我们得到了一个个复杂度<code>O(6*6*500*n^2)</code>的优秀算法, n为500， 爆了。</p><p>那么怎么优化这个东西呢？</p><p>突破口在于，pos数组的k只需要求前7块地就可以了。这样由pos的结果得到前7块地的first和never值，而后面8..n块地的first,never值可以直接由前面7块地的first,never值分别递推出来。因为每一轮掷骰子的概率是独立的，跟所处位置无关，j轮移动可以看成1+(j-1)轮，即走完第一轮再走j-1轮。例如，我们求<code>first[i][j][k]</code>, 可以枚举第一轮移动的步数t，贡献就是<code>p[i][t]*first[i][j-1][k-t]</code>. never同理。</p><p>于是我们得到了正解。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">502</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> p[<span class="number">6</span>][<span class="number">6</span>], first[<span class="number">6</span>][N][N], never[<span class="number">6</span>][N][N], pos[<span class="number">6</span>][N][<span class="number">7</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> p[], <span class="keyword">double</span> first[N][N], <span class="keyword">double</span> never[N][N], <span class="keyword">double</span> pos[N][<span class="number">7</span>][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">6</span>; j++) pos[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">500</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">6</span>; j++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        never[i][j] += pos[i][j][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">6</span>; t++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nk = (k+t+<span class="number">1</span>)%n;</span><br><span class="line">            <span class="keyword">if</span> (nk == j) first[i+<span class="number">1</span>][j] += pos[i][j][k] * p[t];</span><br><span class="line">            <span class="keyword">else</span> pos[i+<span class="number">1</span>][j][nk] += pos[i][j][k] * p[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) never[<span class="number">0</span>][k] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">500</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">7</span>; j &lt; n; j++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">6</span>; t++) &#123;</span><br><span class="line">        first[i][j] += p[t] * first[i<span class="number">-1</span>][j-t<span class="number">-1</span>];</span><br><span class="line">        never[i][j] += p[t] * never[i<span class="number">-1</span>][j-t<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;p[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) solve(p[i], first[i], never[i], pos[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">500</span>; j++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">double</span> prob = first[i][j][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; i; t++) prob *= never[t][j][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = i+<span class="number">1</span>; t &lt; <span class="number">6</span>; t++) prob *= never[t][j<span class="number">-1</span>][k];</span><br><span class="line">        ans[i] += prob;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;H-命命命运&quot;&gt;&lt;a href=&quot;#H-命命命运&quot; class=&quot;headerlink&quot; title=&quot;H 命命命运&quot;&gt;&lt;/a&gt;H 命命命运&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="DP" scheme="http://dafenghh.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CCPC-Wannafly Winter Camp 2019 Day 3 题解</title>
    <link href="http://dafenghh.github.io/post/5fc04022.html"/>
    <id>http://dafenghh.github.io/post/5fc04022.html</id>
    <published>2019-01-24T23:49:44.000Z</published>
    <updated>2019-01-25T02:18:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CCPC-Wannafly Winter Camp 2019 Day 2 题解</title>
    <link href="http://dafenghh.github.io/post/936a40bc.html"/>
    <id>http://dafenghh.github.io/post/936a40bc.html</id>
    <published>2019-01-24T23:48:22.000Z</published>
    <updated>2019-01-25T02:18:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CCPC-Wannafly Winter Camp 2019 Day 1 题解</title>
    <link href="http://dafenghh.github.io/post/1de5475f.html"/>
    <id>http://dafenghh.github.io/post/1de5475f.html</id>
    <published>2019-01-24T23:48:10.000Z</published>
    <updated>2019-01-25T02:18:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Computer Networking, Chapter 4, THE NETWORK LAYER, Notes</title>
    <link href="http://dafenghh.github.io/post/77b83dd5.html"/>
    <id>http://dafenghh.github.io/post/77b83dd5.html</id>
    <published>2018-11-06T02:27:49.000Z</published>
    <updated>2019-01-25T02:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Forwarding involves the transfer of a packet from an incoming link to an outgoing link within a <em>single</em> router. </p><p>Routing involves <em>all</em> of a network’s routers, whose collective interactions via routing protocols determine the paths that packets take on their trips from source to destination node. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Forwarding involves the transfer of a packet from an incoming link to an outgoing link within a &lt;em&gt;single&lt;/em&gt; router. &lt;/p&gt;
&lt;p&gt;Routing i
      
    
    </summary>
    
      <category term="Notes" scheme="http://dafenghh.github.io/categories/Notes/"/>
    
    
      <category term="Computer Networking" scheme="http://dafenghh.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 1025G Company Acquisitions 题解</title>
    <link href="http://dafenghh.github.io/post/d05b63c9.html"/>
    <id>http://dafenghh.github.io/post/d05b63c9.html</id>
    <published>2018-09-11T09:07:52.000Z</published>
    <updated>2018-09-11T09:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>n家公司，每个公司有两种状态，独立或者附属于某一独立公司。每天发生这样一次操作：等概率选择两个独立公司A和B，等概率指定A吞并B,或者B吞并A。假设A吞并B，那么B就成为A的附属公司，然后原来附属B的公司全部独立。给定初始每个公司的状态，求期望多少天后，只有一家独立公司。<br><a id="more"></a></p><h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>超有意思的数学（构造）题……<br>一直在想DP做法，但这个状态没办法表示。所以要转化思路。<br>设一个有k个附属公司的独立公司的potential值为$2^k-1$，则可证明，一次操作后，potential和的增量的期望为1. 然后这就简单了，将终态和初始态的potential相减就行了。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x, ll n)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * x % Mod;</span><br><span class="line">        x = x * x % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">600</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    a = (a + b) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    add(ans, mod_pow(<span class="number">2</span>, n - <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">-1</span>) ++cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[x] &gt; <span class="number">0</span>) add(ans, <span class="number">1</span> - mod_pow(<span class="number">2</span>, cnt[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    add(ans, Mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;n家公司，每个公司有两种状态，独立或者附属于某一独立公司。每天发生这样一次操作：等概率选择两个独立公司A和B，等概率指定A吞并B,或者B吞并A。假设A吞并B，那么B就成为A的附属公司，然后原来附属B的公司全部独立。给定初始每个公司的状态，求期望多少天后，只有一家独立公司。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="constructive algorithms" scheme="http://dafenghh.github.io/tags/constructive-algorithms/"/>
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Computer Networking, Chapter 1, Computer Networks and the Internet, Notes</title>
    <link href="http://dafenghh.github.io/post/527c28.html"/>
    <id>http://dafenghh.github.io/post/527c28.html</id>
    <published>2018-09-04T02:13:08.000Z</published>
    <updated>2018-09-07T08:43:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-3-What’s-Protocol"><a href="#1-1-3-What’s-Protocol" class="headerlink" title="1.1.3 What’s Protocol?"></a>1.1.3 What’s Protocol?</h2><p>A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event.</p><h1 id="1-2-Network-Edge"><a href="#1-2-Network-Edge" class="headerlink" title="1.2 Network Edge"></a>1.2 Network Edge</h1><p><strong>end systems</strong> = <strong>hosts</strong> (Two categories: clients and servers)</p><p>Today, most of the servers from which we receive search results, e-mail, Web pages, and videos reside in large <strong>data centers</strong>.</p><h2 id="1-2-1-Access-Networks"><a href="#1-2-1-Access-Networks" class="headerlink" title="1.2.1 Access Networks"></a>1.2.1 Access Networks</h2><p>The <strong>access network</strong>: the network that physically connects an end system to the first router (also known as the “edge router”) on a path from the end system to any other distant end system. </p><h3 id="Home-Access"><a href="#Home-Access" class="headerlink" title="Home Access"></a>Home Access</h3><p>Today, the two most prevalent types of broadband residential access are <strong>digital subscriber line</strong> (DSL) and <strong>cable</strong>.</p><p>DSL: 数字用户线路，是以电话线为传输介质的传输技术组合。<br>DSLAM: DSL access multiplexer<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/cn1.1.png" alt="DSL Internet access" title="">                </div>                <div class="image-caption">DSL Internet access</div>            </figure></p><p>Fiber optics connect the cable head end to neighborhood-level junctions, from which traditional coaxial cable is then used to reach individual houses and apartments.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/cn1.2.png" alt="A hybrid fiber-coaxial access network" title="">                </div>                <div class="image-caption">A hybrid fiber-coaxial access network</div>            </figure><br>Because both fiber and coaxial cable are employed in this system, it is often referred to as <strong>hybrid fiber coax</strong> (HFC).</p><p>Coaxial cable: 同轴电缆</p><p>cable modem termination system (CMTS)</p><h3 id="Ethernet-and-Wi-Fi"><a href="#Ethernet-and-Wi-Fi" class="headerlink" title="Ethernet and Wi-Fi"></a>Ethernet and Wi-Fi</h3><p>LAN: local area network<br>Although there are many types of LAN technologies, Ethernet is by far the most prevalent access technology.</p><h3 id="Wide-Area-Wireless-Access-3G-and-LTE"><a href="#Wide-Area-Wireless-Access-3G-and-LTE" class="headerlink" title="Wide-Area Wireless Access: 3G and LTE"></a>Wide-Area Wireless Access: 3G and LTE</h3><p>LTE: Long-Term Evolution 长期演进技术</p><h2 id="1-2-2-Physical-Media"><a href="#1-2-2-Physical-Media" class="headerlink" title="1.2.2 Physical Media"></a>1.2.2 Physical Media</h2><p>Physical media fall into two categories: guided media and unguided media.</p><p>With guided media, the waves are guided along a solid medium, such as a fiber-optic cable, a twisted-pair copper wire, or a coaxial cable. With unguided media, the waves propagate in the atmosphere and in outer space, such as in a wireless LAN or a digital satellite channel.</p><ol><li>Twisted-Pair Copper Wire</li><li>Coaxial Cable</li><li>Fiber Optics<br>high-speedoperation, low error rate</li><li>Terrestrial Radio Channels</li><li>Satellite Radio Channels<br>geostationary satellites, low-earth orbiting (LEO) satellites</li></ol><h1 id="1-3-Network-Core"><a href="#1-3-Network-Core" class="headerlink" title="1.3 Network Core"></a>1.3 Network Core</h1><h2 id="1-3-1-Packet-Switching"><a href="#1-3-1-Packet-Switching" class="headerlink" title="1.3.1 Packet Switching"></a>1.3.1 Packet Switching</h2><p>packet switches (for which there are two predominant types, routers and link layer switches)</p><h3 id="Store-and-Forward-Transmission"><a href="#Store-and-Forward-Transmission" class="headerlink" title="Store-and-Forward Transmission"></a>Store-and-Forward Transmission</h3><blockquote><p>The packet switch must receive the entire packet before it can begin to transmit the first bit of the packet onto the outbound link.</p></blockquote><h3 id="Queuing-Delays-and-Packet-Loss"><a href="#Queuing-Delays-and-Packet-Loss" class="headerlink" title="Queuing Delays and Packet Loss"></a>Queuing Delays and Packet Loss</h3><p><strong>output buffer</strong><br>In addition to the store-and-forward delays, packets suffer output buffer <strong>queuing delays</strong>.</p><p><strong>Packet loss</strong> may occur when buffer is completely full.</p><h3 id="Forwarding-Tables-and-Routing-Protocols"><a href="#Forwarding-Tables-and-Routing-Protocols" class="headerlink" title="Forwarding Tables and Routing Protocols"></a>Forwarding Tables and Routing Protocols</h3><p>Each router has a <strong>forwarding table</strong> that maps destination addresses (or portions of the destination addresses) to that router’s outbound links. </p><p>The Internet has a number of special <strong>routing protocols</strong> that are used to automatically set the forwarding tables.</p><h3 id="Ad-amp-Disad"><a href="#Ad-amp-Disad" class="headerlink" title="Ad. &amp; Disad."></a>Ad. &amp; Disad.</h3><ol><li>great for bursty data (resource sharing, simpler)</li><li>excessive congestion possible.</li></ol><h2 id="1-3-2-Circuit-Switching"><a href="#1-3-2-Circuit-Switching" class="headerlink" title="1.3.2 Circuit Switching"></a>1.3.2 Circuit Switching</h2><p>In circuit-switched networks, the resources needed along a path (buffers, link transmission rate) to provide for communication between the end systems are reserved for the duration of the communication session between the end systems.</p><p>e.g. traditional telephone networks</p><p><strong>guaranteed</strong> constant rate</p><h3 id="Multiplexing-in-Circuit-Switched-Networks"><a href="#Multiplexing-in-Circuit-Switched-Networks" class="headerlink" title="Multiplexing in Circuit-Switched Networks"></a>Multiplexing in Circuit-Switched Networks</h3><p>A circuit in a link is implemented with either frequency-division multiplexing (FDM) or time-division multiplexing (TDM).</p><p>频分/时分多路复用</p><h2 id="1-3-3-A-Network-of-Networks"><a href="#1-3-3-A-Network-of-Networks" class="headerlink" title="1.3.3 A Network of Networks"></a>1.3.3 A Network of Networks</h2><ol><li>regional ISPs</li><li>tier-1 ISPs</li><li><strong>PoP</strong>: points of presence, a group of one or more routers (at the same location) in the provider’s network where customer ISPs can connect into the provider ISP.</li><li>Any ISP (except for tier-1 ISPs) may choose to <strong>multi-home</strong>, that is, to connect to two or more provider ISPs. </li><li>ISPs at the same level of the hierarchy can <strong>peer</strong>. When two ISPs peer, it is typically settlement-free, that is, neither ISP pays the other.</li><li><strong>Internet Exchange Point (IXP)</strong>: a meeting point where multiple ISPs can peer together. </li><li><strong>content provider networks</strong></li></ol><p>见P61 图片</p><h1 id="1-4-Delay-Loss-and-Throughput-in-Packet-Switched-Networks"><a href="#1-4-Delay-Loss-and-Throughput-in-Packet-Switched-Networks" class="headerlink" title="1.4 Delay, Loss, and Throughput in Packet-Switched Networks"></a>1.4 Delay, Loss, and Throughput in Packet-Switched Networks</h1><h2 id="1-4-1-overview"><a href="#1-4-1-overview" class="headerlink" title="1.4.1 overview"></a>1.4.1 overview</h2><h3 id="Processing-Delay"><a href="#Processing-Delay" class="headerlink" title="Processing Delay"></a>Processing Delay</h3><p>The time required to:</p><ol><li>examine the packet’s header and determine where to direct the packet </li><li>check for bit-level errors in the packet<br>(on the order of microseconds)<h3 id="Queuing-Delay"><a href="#Queuing-Delay" class="headerlink" title="Queuing Delay"></a>Queuing Delay</h3>The number of packets that an arriving packet might expect to find is a function of the intensity and nature of the traffic arriving at the queue.<h3 id="Transmission-Delay"><a href="#Transmission-Delay" class="headerlink" title="Transmission Delay"></a>Transmission Delay</h3>L/R<h3 id="Propagation-Delay"><a href="#Propagation-Delay" class="headerlink" title="Propagation Delay"></a>Propagation Delay</h3>d/s</li></ol><h2 id="1-4-2-Queuing-Delay-and-Packet-Loss"><a href="#1-4-2-Queuing-Delay-and-Packet-Loss" class="headerlink" title="1.4.2 Queuing Delay and Packet Loss"></a>1.4.2 Queuing Delay and Packet Loss</h2><p>traffic intensity: La/R (a: the average rate at which packets arrive at the queue, in units of packets/sec)<br>Golden rule: Design your system so that the traffic intensity is no greater than 1.<br>As the traffic intensity approaches 1, the average queuing delay increases rapidly.</p><h3 id="Packet-Loss"><a href="#Packet-Loss" class="headerlink" title="Packet Loss"></a>Packet Loss</h3><h2 id="1-4-3-End-to-End-Delay"><a href="#1-4-3-End-to-End-Delay" class="headerlink" title="1.4.3 End-to-End Delay"></a>1.4.3 End-to-End Delay</h2><p>Traceroute</p><h2 id="1-4-4-Throughput-in-Computer-Networks"><a href="#1-4-4-Throughput-in-Computer-Networks" class="headerlink" title="1.4.4 Throughput in Computer Networks"></a>1.4.4 Throughput in Computer Networks</h2><p>When transferring a large file from Host A to Host B, the <strong>instantaneous throughput</strong> at any instant of time is the rate (in bits/sec) at which Host B is receiving the file. </p><p><strong>Average throughput</strong>: F/T bits/sec</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-3-What’s-Protocol&quot;&gt;&lt;a href=&quot;#1-1-3-What’s-Protocol&quot; class=&quot;headerlink&quot; title=&quot;1.1.3 What’s Protocol?&quot;&gt;&lt;/a&gt;1.1.3 What’s Protocol?
      
    
    </summary>
    
      <category term="Notes" scheme="http://dafenghh.github.io/categories/Notes/"/>
    
    
      <category term="Computer Networking" scheme="http://dafenghh.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #493 Summary</title>
    <link href="http://dafenghh.github.io/post/96fa61b.html"/>
    <id>http://dafenghh.github.io/post/96fa61b.html</id>
    <published>2018-07-21T14:07:54.000Z</published>
    <updated>2018-09-05T16:07:26.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="codeforces" scheme="http://dafenghh.github.io/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef - SCIENCEF Science Fair 题解</title>
    <link href="http://dafenghh.github.io/post/a5930d20.html"/>
    <id>http://dafenghh.github.io/post/a5930d20.html</id>
    <published>2018-05-09T13:43:01.000Z</published>
    <updated>2018-05-09T13:47:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。</p><p>大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下：</p><p> cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）)</p><p> 司机会选择一条使cost最小的路线行驶。问cost的期望。</p><a id="more"></a><h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>扩展版旅行商问题。<br>关键是先重构图。压缩至只有S，F跟学生所在点。而这些点间的边权应该定义为原图中不经过别的学生的最短路长度。用$n^2$次dijkstra重构图完成后，就是一个旅行商问题了。之后状态压缩DP解决。</p><p><code>dp1[x][i]</code>表示当前走到第i个点，访问过的点集为x的最小cost。<br><code>dp2[x]</code>表示访问学生集合为x以及x的超集的最小cost。这就是最终答案了。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll Mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll&amp; <span class="title">Add</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a = sum(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">product</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll&amp; <span class="title">Mul</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a = product(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ll iv = <span class="number">570000004L</span>L;</span><br><span class="line"></span><br><span class="line">ll talkative[<span class="number">1</span> &lt;&lt; <span class="number">17</span>], ti[<span class="number">17</span>], pi[<span class="number">20</span>], mi[<span class="number">17</span>];</span><br><span class="line"><span class="keyword">int</span> V, E, S, F, n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1020</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">253432145421354L</span>L;</span><br><span class="line">ll sp[<span class="number">20</span>][<span class="number">20</span>], d[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    ll cost;</span><br><span class="line">    edge(<span class="keyword">int</span> to = <span class="number">0</span>, ll cost = <span class="number">0</span>):to(to), cost(cost)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> studentOnVertex[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mini</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, P&gt; Tuple;</span><br><span class="line">ll dp[<span class="number">1</span>&lt;&lt;<span class="number">17</span>][<span class="number">20</span>], dp2[<span class="number">1</span>&lt;&lt;<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;V, &amp;E, &amp;S, &amp;F, &amp;n);</span><br><span class="line">    S--, F--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, pi + i, ti + i, mi + i);</span><br><span class="line">        pi[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        --x,--y;</span><br><span class="line">        G[x].push_back(edge(y, w));</span><br><span class="line">        G[y].push_back(edge(x, w));</span><br><span class="line">    &#125;</span><br><span class="line">    talkative[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">                talkative[x|(<span class="number">1</span>&lt;&lt;i)] = product(talkative[x], ti[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(studentOnVertex, <span class="number">-1</span>, <span class="keyword">sizeof</span> studentOnVertex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        studentOnVertex[pi[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    pi[n] = S;</span><br><span class="line">    pi[n + <span class="number">1</span>] = F;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= n + <span class="number">1</span>; s++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = s + <span class="number">1</span>; t &lt;= n + <span class="number">1</span>; t++) &#123;</span><br><span class="line">        fill(d, d + V, INF);</span><br><span class="line">        d[pi[s]] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class="line">        que.push(P(<span class="number">0</span>, pi[s]));</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            P p = que.top(); que.pop();</span><br><span class="line">            <span class="keyword">int</span> v = p.second;</span><br><span class="line">            <span class="keyword">if</span> (p.first &gt; d[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> e: G[v]) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = e.to;</span><br><span class="line">                ll cost = e.cost;</span><br><span class="line">                <span class="keyword">int</span> stui = studentOnVertex[u];</span><br><span class="line">                <span class="keyword">if</span> (stui != <span class="number">-1</span> &amp;&amp; stui != s &amp;&amp; stui != t) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (d[u] &gt; d[v] + cost) &#123;</span><br><span class="line">                    d[u] = d[v] + cost;</span><br><span class="line">                    que.push(P(d[u], u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sp[s][t] = sp[t][s] = d[pi[t]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[x][i] = INF;</span><br><span class="line">        </span><br><span class="line">    dp[<span class="number">0</span>][n] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Tuple, <span class="built_in">vector</span>&lt;Tuple&gt;, greater&lt;Tuple&gt; &gt; que;</span><br><span class="line">    que.push(Tuple(<span class="number">0</span>, P(<span class="number">0</span>,n)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        Tuple tup = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">int</span> x = tup.second.first, i = tup.second.second;</span><br><span class="line">        <span class="keyword">if</span> (tup.first &gt; dp[x][i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> nx = x | (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">if</span> (dp[nx][j] &gt; dp[x][i] + sp[i][j]) &#123;</span><br><span class="line">                dp[nx][j] = dp[x][i] + sp[i][j];</span><br><span class="line">                que.push(Tuple(dp[nx][j], P(nx,j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++) &#123;</span><br><span class="line">        dp2[x] = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i))  Mini(dp2[x], dp[x][i] + sp[i][n+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp2[x] += talkative[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; x &gt; <span class="number">0</span>; x--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            Mini(dp2[x], dp2[x|(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++) &#123;</span><br><span class="line">        ll temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                Mul(temp, mi[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Mul(temp, <span class="number">100</span> - mi[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Mul(temp, iv);</span><br><span class="line">        &#125;</span><br><span class="line">        Mul(temp, dp2[x]);</span><br><span class="line">        Add(ans, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。&lt;/p&gt;
&lt;p&gt;大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下：&lt;/p&gt;
&lt;p&gt; cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）)&lt;/p&gt;
&lt;p&gt; 司机会选择一条使cost最小的路线行驶。问cost的期望。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="DP" scheme="http://dafenghh.github.io/tags/DP/"/>
    
      <category term="shortest path" scheme="http://dafenghh.github.io/tags/shortest-path/"/>
    
      <category term="graph" scheme="http://dafenghh.github.io/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef - GENPERM Generating A Permutation 题解</title>
    <link href="http://dafenghh.github.io/post/75299267.html"/>
    <id>http://dafenghh.github.io/post/75299267.html</id>
    <published>2018-05-09T13:15:57.000Z</published>
    <updated>2018-05-09T13:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, p3) + … + max(pN-1, pN)</p><p>给出N，K。构造排列P， 使f(P) = K. 如果不存在，就输出-1.</p><h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>f(P)的值是N-1个数的和。而原排列中的数，最多贡献两次答案。</p><p>考虑排列是正序时，f(P)取到最小值，为2+3+…+N。也即2到N的数，每个数贡献1次。<br>最大值应该是在最大的那些数都贡献2次时取到。</p><p>怎么让最大那个数贡献2次？只需要不把它放两端就可以了。</p><p>另外注意到，一个大的数a多贡献一次的同时，就会剥夺另外一个较小的数b的贡献机会，这时候就会使答案增加a-b.</p><p>所以这道题的构造方法就是，设a为下一个贡献多一次的数，b为下一个被剥夺贡献机会的数。考虑当前的和，如果加上b-a比答案大，我们就让b大一些，直到满足条件。然后把刚刚考虑过的b依次append到答案数组，再append a就行。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll k;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) x += i;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; x) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + r - l - <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">                x += r - l - <span class="number">1</span>;</span><br><span class="line">                vec.push_back(l++);</span><br><span class="line">                vec.push_back(r--);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                vec.push_back(l++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) vec.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (x != k || vec.size() != n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, vec[i], <span class="string">" \n"</span>[i==n<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, 
      
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="constructive algorithms" scheme="http://dafenghh.github.io/tags/constructive-algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://dafenghh.github.io/post/4a17b156.html"/>
    <id>http://dafenghh.github.io/post/4a17b156.html</id>
    <published>2018-05-02T06:38:13.860Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Educational Codeforces Round 43 Summary</title>
    <link href="http://dafenghh.github.io/post/af1c4a82.html"/>
    <id>http://dafenghh.github.io/post/af1c4a82.html</id>
    <published>2018-05-01T01:57:28.000Z</published>
    <updated>2018-05-09T13:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>比赛中仅仅做出3道水题。</p><p>卡E。E一直想不出。曾有猜测“所有1st type spells全部用于一个creature”，但无法证明，也不敢下定论。没想到这就是正解。</p><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="E-Well-played"><a href="#E-Well-played" class="headerlink" title="E. Well played!"></a>E. Well played!</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有n个物品，每个物品有两个值hp和dmg. 现有a个第一类道具和b个第二类道具。第一类道具可以使某个物品的hp翻倍，第二类道具可以将某个物品的hp赋值给dmg.</p><p>问使用了这些道具后，所有物品dmg和的最大值。</p><p>数据范围: $1\leq n\leq2\cdot10^5,0\leq b\leq2\cdot10^5,0\leq a\leq 20$</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>下面先证明，最优解一定是全部第一类道具用于同一个物品。分别用x和y表示物品的hp和dmg.</p><p>那么如果两个物品同时用了第一类道具，分别用了$a_1$和$a_2$个，它们的总dmg就是$d_1 = {x_1}2^{a_1}+{x_2}2^{a_2}$.</p><p>如果将第一类道具全部用于第1个物品，总dmg为$d_2={x_1}2^{a_1+a_2}+\max(x_2, y_2)$</p><p>假设d1更优，则有$${x_1}2^{a_1}+{x_2}2^{a_2} &gt; {x_1}2^{a_1+a_2}+\max(x_2, y_2)$$</p><p>移项，有$${x_1}2^{a_1}(2^{a_2}-1) &lt; {x_2}2^{a_2} - \max(x_2, y_2)$$</p><p>考虑到$\max(x_2, y_2) \geq x_2$,则有$${x_1}2^{a_1}(2^{a_2}-1) &lt; {x_2}(2^{a_2}-1)$$</p><p>即$${x_1}2^{a_1}&lt; {x_2}$$</p><p>同理，为了让$d_1$比第一类道具全部用于第2个物品的情况更优，有<br>$${x_2}2^{a_2}&lt; {x_1}$$</p><p>两个不等式矛盾，证毕。</p><p>这样一来，就可以O(n)枚举每个物品使用第一类道具的情况。</p><h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    ll h, d;</span><br><span class="line">    <span class="keyword">bool</span> used;</span><br><span class="line">    P(ll h = <span class="number">0</span>, ll d = <span class="number">0</span>): h(h), d(d), used(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> P &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> h - d &gt; b.h - b.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maxi</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, A, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;A, &amp;b);</span><br><span class="line">    ll k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; i++) k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> h,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;h, &amp;d);</span><br><span class="line">        a[i] = P(h, d);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    ll tot = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].h &gt; a[i].d &amp;&amp; cnt &lt; b) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                tot += a[i].h;</span><br><span class="line">                a[i].used = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tot += a[i].d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ll h = a[i].h * k;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= a[i].d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i].used) &#123;</span><br><span class="line">            Maxi(ans, tot - a[i].h + h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ll temp = tot - a[i].d + h;</span><br><span class="line">            <span class="keyword">if</span> (cnt == b) &#123;</span><br><span class="line">                temp = temp - a[b - <span class="number">1</span>].h + a[b - <span class="number">1</span>].d;</span><br><span class="line">            &#125;</span><br><span class="line">            Maxi(ans, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;&lt;p&gt;比赛中仅仅做出3道水题。&lt;/p&gt;
&lt;p&gt;卡E。E一直想不出。曾有猜测“所有1st type spel
      
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="summary" scheme="http://dafenghh.github.io/tags/summary/"/>
    
      <category term="codeforces" scheme="http://dafenghh.github.io/tags/codeforces/"/>
    
      <category term="greedy" scheme="http://dafenghh.github.io/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>2018.04.22 Kharagpur Regional 2017 集训总结</title>
    <link href="http://dafenghh.github.io/post/9ffddd26.html"/>
    <id>http://dafenghh.github.io/post/9ffddd26.html</id>
    <published>2018-04-29T12:13:01.000Z</published>
    <updated>2018-05-09T13:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>赛中通过3题，FDK.  F是暴力水题，D和K一共7记罚时，做得不好。D的错误是考虑错了复杂度，所以超时，加上输出%lld写成%d（经典错误）。K的错误是思考不谨慎，连边时加了一个多余的判断条件。</p><p>赛后没把H想出来。已经想得差不多，不过看错数据范围。一直以为要O(n^2)算法，其实是O(n^3). 要是看仔细点说不定就能想出来。（经典DP套路，请把训练指南的DP章节刷一遍，锻炼思维！）</p><p>赛后补了AHJ。还差EIB。加油，补完！</p><ul><li style="list-style: none"><input type="checkbox" checked> A</li><li style="list-style: none"><input type="checkbox" checked> J</li><li style="list-style: none"><input type="checkbox"> B</li><li style="list-style: none"><input type="checkbox"> E</li><li style="list-style: none"><input type="checkbox"> I</li></ul><a id="more"></a><h2 id="A-Science-Fair"><a href="#A-Science-Fair" class="headerlink" title="A Science Fair"></a>A Science Fair</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。</p><p>大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下：</p><p> cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）)</p><p> 司机会选择一条使cost最小的路线行驶。问cost的期望。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>扩展版旅行商问题。<br>关键是先重构图。压缩至只有S，F跟学生所在点。而这些点间的边权应该定义为原图中不经过别的学生的最短路长度。用$n^2$次dijkstra重构图完成后，就是一个旅行商问题了。之后状态压缩DP解决。</p><p><code>dp1[x][i]</code>表示当前走到第i个点，访问过的点集为x的最小cost。<br><code>dp2[x]</code>表示访问学生集合为x以及x的超集的最小cost。这就是最终答案了。</p><p>见<a href="a5930d20.html">Science Fair题解</a></p><h2 id="B-Black-Discs"><a href="#B-Black-Discs" class="headerlink" title="B Black Discs"></a>B Black Discs</h2><h2 id="C-Uniform-Strings"><a href="#C-Uniform-Strings" class="headerlink" title="C Uniform Strings"></a>C Uniform Strings</h2><h2 id="D-SAD-Queries"><a href="#D-SAD-Queries" class="headerlink" title="D SAD Queries"></a>D SAD Queries</h2><h2 id="E-Chef-and-XOR-Queries"><a href="#E-Chef-and-XOR-Queries" class="headerlink" title="E Chef and XOR Queries"></a>E Chef and XOR Queries</h2><h2 id="F-Taxi-Making-Sharp-Turns"><a href="#F-Taxi-Making-Sharp-Turns" class="headerlink" title="F Taxi Making Sharp Turns"></a>F Taxi Making Sharp Turns</h2><h2 id="G-Spam-Classification-Using-Neural-Net"><a href="#G-Spam-Classification-Using-Neural-Net" class="headerlink" title="G Spam Classification Using Neural Net"></a>G Spam Classification Using Neural Net</h2><h2 id="H-Non-Overlapping-Segments"><a href="#H-Non-Overlapping-Segments" class="headerlink" title="H Non Overlapping Segments"></a>H Non Overlapping Segments</h2><h2 id="I-Spanning-Tree"><a href="#I-Spanning-Tree" class="headerlink" title="I Spanning Tree"></a>I Spanning Tree</h2><h2 id="J-Generating-A-Permutation"><a href="#J-Generating-A-Permutation" class="headerlink" title="J Generating A Permutation"></a>J Generating A Permutation</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, p3) + … + max(pN-1, pN)</p><p>给出N，K。构造排列P， 使f(P) = K. 如果不存在，就输出-1.</p><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h3><p>f(P)的值是N-1个数的和。而原排列中的数，最多贡献两次答案。</p><p>考虑排列是正序时，f(P)取到最小值，为2+3+…+N。也即2到N的数，每个数贡献1次。<br>最大值应该是在最大的那些数都贡献2次时取到。</p><p>怎么让最大那个数贡献2次？只需要不把它放两端就可以了。</p><p>另外注意到，一个大的数a多贡献一次的同时，就会剥夺另外一个较小的数b的贡献机会，这时候就会使答案增加a-b.</p><p>所以这道题的构造方法就是，设a为下一个贡献多一次的数，b为下一个被剥夺贡献机会的数。考虑当前的和，如果加上b-a比答案大，我们就让b大一些，直到满足条件。然后把刚刚考虑过的b依次append到答案数组，再append a就行。</p><p>见<a href="75299267.html">Generating A Permutation题解</a></p><h2 id="K-Number-Game"><a href="#K-Number-Game" class="headerlink" title="K Number Game"></a>K Number Game</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;&lt;p&gt;赛中通过3题，FDK.  F是暴力水题，D和K一共7记罚时，做得不好。D的错误是考虑错了复杂度，所以超时，加上输出%lld写成%d（经典错误）。K的错误是思考不谨慎，连边时加了一个多余的判断条件。&lt;/p&gt;
&lt;p&gt;赛后没把H想出来。已经想得差不多，不过看错数据范围。一直以为要O(n^2)算法，其实是O(n^3). 要是看仔细点说不定就能想出来。（经典DP套路，请把训练指南的DP章节刷一遍，锻炼思维！）&lt;/p&gt;
&lt;p&gt;赛后补了AHJ。还差EIB。加油，补完！&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; A&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; J&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; B&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; E&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; I&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="summary" scheme="http://dafenghh.github.io/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101635C [Macarons] 2017-2018 ACM-ICPC, Southwestern European Regional Programming Contest (SWERC 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/9049154c.html"/>
    <id>http://dafenghh.github.io/post/9049154c.html</id>
    <published>2018-01-26T07:22:09.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>用<code>1*1</code>或者<code>1*2</code>的小长方形完整覆盖N*M的长方形（不可重叠），问有多少种覆盖方式？</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>行数很少，<code>N &lt;= 8</code>, 列数很多，<code>M &lt;= 10^18</code></p><p>对于每一列，用一个长度为N的二进制串表示它的状态，0表示这一个位置放置着<code>1*1</code>的方块，1表示这一个位置放置着<code>1*2</code>的方块。</p><p>构造这样一个转移矩阵，<code>T[i][j]</code>表示状态i的列右边连着状态j的列的时候，有多少种状态j的列是可行的。</p><p>然后对矩阵求快速幂即可。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch; <span class="keyword">int</span> v,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch=getchar())) <span class="keyword">if</span> (ch==<span class="string">'-'</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">1</span>;<span class="keyword">else</span> v=ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch=getchar())) v=v*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> f?-v:v;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">300</span>;</span><br><span class="line">ll mat[maxn][maxn], M,sz;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trans</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>, dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, bin = <span class="number">1</span>; i &lt;= n; i++, bin &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = ((X &amp; bin) &gt; <span class="number">0</span>), y = ((Y &amp; bin) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + (x==<span class="number">0</span>?dp[i<span class="number">-1</span>][<span class="number">0</span>]:<span class="number">0</span>);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tmp[maxn][maxn],Map[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(ll m[maxn][maxn],ll t,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(Map,m,<span class="keyword">sizeof</span>(Map));</span><br><span class="line">    t--;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) tmp[i][j]=<span class="number">0</span>;<span class="comment">//清空临时数组</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">            <span class="keyword">if</span> (m[i][k])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) tmp[i][j]+=m[i][k]*Map[k][j]%mod,tmp[i][j]%=mod; <span class="comment">//矩阵乘法</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) Map[i][j]=tmp[i][j];      <span class="comment">//赋值到原数组</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) tmp[i][j]=<span class="number">0</span>;<span class="comment">//清空临时数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">            <span class="keyword">if</span> (m[i][k])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) tmp[i][j]+=m[i][k]*m[k][j]%mod,tmp[i][j]%=mod;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) m[i][j]=tmp[i][j];     </span><br><span class="line">        t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) ans=(ans+Map[N][i])%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; M;</span><br><span class="line">    sz = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz; j++) &#123;</span><br><span class="line">        mat[i][j] = trans(i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ksm(mat,M,sz)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;用&lt;code&gt;1*1&lt;/code&gt;或者&lt;code&gt;1*2&lt;/code&gt;的小长方形完整覆盖N*M的长方形（不可重叠），问有多少种覆盖方式？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>codeforces gym 101635J [Frosting on the Cake] 2017-2018 ACM-ICPC, Southwestern European Regional Programming Contest (SWERC 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/8e378f9.html"/>
    <id>http://dafenghh.github.io/post/8e378f9.html</id>
    <published>2018-01-26T06:32:45.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p> 将一块蛋糕，横切n-1刀，竖切n-1刀。使水平方向上，各块宽度分别为B1, B2…Bn；垂直方向上，各块宽度分别为A1, A2…An.</p><p>现在，按从左到右，从上到下的顺序，给每一小块依次循环染色“白 黄 粉”三种颜色。</p><p>求出每一种颜色的方块的总面积。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>其实就是一个简单的取余问题。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch; <span class="keyword">int</span> v,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch=getchar())) <span class="keyword">if</span> (ch==<span class="string">'-'</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">1</span>;<span class="keyword">else</span> v=ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch=getchar())) v=v*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> f?-v:v;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100020</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], b[maxn];</span><br><span class="line">ll am[<span class="number">3</span>],ans[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i], am[i%<span class="number">3</span>] += a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            ans[j] += b[i] * (am[((ll)j-(ll)i*n<span class="number">-2</span>+<span class="number">3</span>*(ll)maxn*maxn)%<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>] &lt;&lt;<span class="string">" "</span> &lt;&lt; ans[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt; 将一块蛋糕，横切n-1刀，竖切n-1刀。使水平方向上，各块宽度分别为B1, B2…Bn；垂直方向上，各块宽度分别为A1, A2…An.&lt;/p&gt;
&lt;p&gt;现在，按从左到右，从上到下的顺序，给每一小块依次循环染色“白 黄 粉”三种颜色。&lt;/p&gt;
&lt;p&gt;求出每一种颜色的方块的总面积。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="implementation" scheme="http://dafenghh.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101620L [Lunar Landscape] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/96671495.html"/>
    <id>http://dafenghh.github.io/post/96671495.html</id>
    <published>2018-01-26T05:40:19.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>卫星拍下了地面的很多照片。每张照片覆盖了平面的一个正方形区域，这个正方形要么边与坐标轴平行，要么对角线与坐标轴平行，保证中心点和顶点都在坐标整点的位置。</p><p>求被覆盖的区域面积。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>如果题目只给出边与坐标轴平行的正方形的话，那这道题很简单，直接二维前缀和就OK。</p><p>但这道题有侧着放的正方形（对角线与坐标轴平行），又该怎么处理呢？</p><p>首先发现，一个正方形小格可以按对角线分成4块小三角形，有多少块小三角形被覆盖，则要看侧正方形的分布情况。</p><p>如果用一下坐标变换，将坐标系向由旋转45度，再将单位长度设置为小三角形的直角边长。可以求出，这个坐标变换的表达式为：<br>$x’=x-y,y’=x+y$</p><p>旋转坐标系后，将每一个小三角形视为一个元素，然后对这些小三角形用二维前缀和即可。</p><p>找出变换后的坐标跟原来坐标的对应关系，本题解答完成。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1600</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span> * N][<span class="number">2</span> * N], g[<span class="number">8</span> * N][<span class="number">4</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> x,y,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d%d"</span>,s, &amp;x,&amp;y,&amp;d);</span><br><span class="line">        d /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'A'</span>) &#123;</span><br><span class="line">            f[x-d+N][y-d+N]++;</span><br><span class="line">            f[x+d+N][y-d+N]--;</span><br><span class="line">            f[x-d+N][y+d+N]--;</span><br><span class="line">            f[x+d+N][y+d+N]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x0 = x - y, y0 = x + y;</span><br><span class="line">            x = x0, y = y0;</span><br><span class="line">            g[<span class="number">2</span>*x<span class="number">-2</span>*d+<span class="number">4</span>*N][y-d+<span class="number">2</span>*N]++;</span><br><span class="line">            g[<span class="number">2</span>*x+<span class="number">2</span>*d+<span class="number">4</span>*N][y-d+<span class="number">2</span>*N]--;</span><br><span class="line">            g[<span class="number">2</span>*x<span class="number">-2</span>*d+<span class="number">4</span>*N][y+d+<span class="number">2</span>*N]--;</span><br><span class="line">            g[<span class="number">2</span>*x+<span class="number">2</span>*d+<span class="number">4</span>*N][y+d+<span class="number">2</span>*N]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * N; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) f[i][j] += f[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) f[i][j] += f[i][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) f[i][j] -= f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> * N; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span> * N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) g[i][j] += g[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) g[i][j] += g[i][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) g[i][j] -= g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">-1510</span>; x &lt; <span class="number">1510</span>; x++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">-1510</span>; y &lt; <span class="number">1510</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x+N][y+N]) ans++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x0 = x - y, y0 = x + y;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">2</span>*x0<span class="number">-1</span>+<span class="number">4</span>*N][y0+<span class="number">1</span>+<span class="number">2</span>*N]) ans += <span class="number">0.25</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">2</span>*x0<span class="number">-1</span>+<span class="number">4</span>*N][y0+<span class="number">2</span>*N]) ans += <span class="number">0.25</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">2</span>*x0+<span class="number">4</span>*N][y0+<span class="number">1</span>+<span class="number">2</span>*N]) ans += <span class="number">0.25</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">2</span>*x0+<span class="number">4</span>*N][y0+<span class="number">2</span>*N])   ans += <span class="number">0.25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;卫星拍下了地面的很多照片。每张照片覆盖了平面的一个正方形区域，这个正方形要么边与坐标轴平行，要么对角线与坐标轴平行，保证中心点和顶点都在坐标整点的位置。&lt;/p&gt;
&lt;p&gt;求被覆盖的区域面积。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101620H [Hidden Hierarchy] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/1dd196f0.html"/>
    <id>http://dafenghh.github.io/post/1dd196f0.html</id>
    <published>2018-01-26T05:39:40.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出n个文件的路径和大小，然后要像Windows资源管理器的侧边栏那样输出文件夹的分层结构。当一个文件夹里的所有子文件夹大小都不超过t时，它会折叠起来。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>模拟题，集训的时候打崩了。关键是建树的过程，将路径拆分成文件夹名的vector，然后利用这个vector创建这个路径上的所有文件夹的结点。</p><p>所有结点按创建次序保存在数组中，每一个结点包含一个map<string, int="">, 存放它的子节点，“文件夹名”到结点位置的映射。</string,></p><p>这样一来，这道题就很好写了。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; subdir;</span><br><span class="line">&#125;a[<span class="number">60000</span>];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFile</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;path, <span class="keyword">int</span> pi, <span class="keyword">int</span> sz, <span class="keyword">int</span> ai)</span> </span>&#123;</span><br><span class="line">    a[ai].sz += sz;</span><br><span class="line">    <span class="keyword">if</span> (pi &gt;= path.size()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!a[ai].subdir.count(path[pi])) &#123;</span><br><span class="line">        a[++tot].name = path[pi];</span><br><span class="line">        a[ai].subdir[path[pi]] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    addFile(path, pi + <span class="number">1</span>, sz, a[ai].subdir[path[pi]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFold</span><span class="params">(<span class="keyword">int</span> ai)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i:a[ai].subdir) <span class="keyword">if</span> (a[i.second].sz &gt;= t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDir</span><span class="params">(<span class="keyword">int</span> ai = <span class="number">0</span>, <span class="built_in">string</span> ps = <span class="string">""</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ps += a[ai].name + <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[ai].subdir.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  %s %d\n"</span>, ps.c_str(), a[ai].sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (canFold(ai)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"+ %s %d\n"</span>, ps.c_str(), a[ai].sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"- %s %d\n"</span>, ps.c_str(), a[ai].sz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i:a[ai].subdir) printDir(i.second,ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1024</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, str, &amp;sz);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">        <span class="built_in">string</span> buf;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'/'</span>) path.push_back(buf),buf.clear();</span><br><span class="line">            <span class="keyword">else</span> buf += <span class="built_in">string</span>(<span class="number">1</span>, str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        addFile(path, <span class="number">0</span>, sz, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    printDir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给出n个文件的路径和大小，然后要像Windows资源管理器的侧边栏那样输出文件夹的分层结构。当一个文件夹里的所有子文件夹大小都不超过t时，它会折叠起来。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="dfs and similar" scheme="http://dafenghh.github.io/tags/dfs-and-similar/"/>
    
      <category term="tree" scheme="http://dafenghh.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>NWERC 2017 H [High Score] (The 2017 Northwestern Europe Regional Contest) 题解</title>
    <link href="http://dafenghh.github.io/post/54cee541.html"/>
    <id>http://dafenghh.github.io/post/54cee541.html</id>
    <published>2018-01-24T02:34:18.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p><a href="https://open.kattis.com/problems/highscore2" target="_blank" rel="noopener">题目链接</a> （可能需要翻墙）</p><p>给定a,b,c, 定义  $score = a^2 + b^2 + c^2+7\cdot \min(a,b,c)$</p><p>现在给出一个d，要将d拆成三份作为a，b，c的增量，即赋值<code>a += d1, b += d2, c += d3</code>, 满足<code>d1, d2, d3 &gt;= 0, d1 + d2 + d3 = d</code></p><p>求score的最大值。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>注意到加上d后，前面平方项的增量是O(d^2)级别，后面min(a,b,c)这项是O(d)级别，所以当d比较大时，把d全部加给a b c中的最大值即可；d比较小时，暴力一一验证即可。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">true<span class="keyword">int</span> n;</span><br><span class="line">true<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">truetruell a,b,c,d;</span><br><span class="line">truetrue<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">truetruell sz0 = <span class="number">4</span>, sz1 = <span class="number">10</span>;</span><br><span class="line">truetrue<span class="keyword">if</span> (a &lt; sz0 &amp;&amp; b &lt; sz0 &amp;&amp; c &lt; sz0 &amp;&amp; d &lt; sz1) &#123;</span><br><span class="line">truetruetruell ans = a*a+b*b+c*c+<span class="number">7</span>*min(a,min(b,c));</span><br><span class="line">truetruetrue<span class="keyword">for</span> (ll d1 = <span class="number">0</span>; d1 &lt;= d; d1++)</span><br><span class="line">truetruetrue<span class="keyword">for</span> (ll d2 = <span class="number">0</span>, d3 = d - d1 - d2; d2 &lt;= d &amp;&amp; d3 &gt;= <span class="number">0</span>; d2++, d3 = d - d1 - d2) &#123;</span><br><span class="line">truetruetruetrueans = max(ans, (a+d1)*(a+d1)+(b+d2)*(b+d2)+(c+d3)*(c+d3)+<span class="number">7</span>*min(a+d1, min(b+d2,c+d3)));</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrue<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">truetruetrue<span class="keyword">continue</span>;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruell mat=max(max(a,b),c);</span><br><span class="line">truetruell t1=ll(a+d)*(a+d)+(ll)b*b+(ll)c*c+ll(<span class="number">7</span>)*min(min(a+d,b),c);</span><br><span class="line">truetruell t2=ll(a)*a+ll(b+d)*(b+d)+(ll)c*c+ll(<span class="number">7</span>)*min(min(a,b+d),c);</span><br><span class="line">truetruell t3=ll(a)*a+ll(b)*b+ll(c+d)*(c+d)+ll(<span class="number">7</span>)*min(min(a,b),c+d);</span><br><span class="line">truetrue<span class="built_in">cout</span>&lt;&lt;max(t1,max(t2,t3))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://open.kattis.com/problems/highscore2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt; （可能需要翻墙）&lt;/p&gt;
&lt;p&gt;给定a,b,c, 定义  $score = a^2 + b^2 + c^2+7\cdot \min(a,b,c)$&lt;/p&gt;
&lt;p&gt;现在给出一个d，要将d拆成三份作为a，b，c的增量，即赋值&lt;code&gt;a += d1, b += d2, c += d3&lt;/code&gt;, 满足&lt;code&gt;d1, d2, d3 &amp;gt;= 0, d1 + d2 + d3 = d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;求score的最大值。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>codeforces gym 101630B [Box] 2017-2018 ACM-ICPC, Northern Eurasia (Northeastern European Regional) Contest (NEERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/5f7aa68.html"/>
    <id>http://dafenghh.github.io/post/5f7aa68.html</id>
    <published>2018-01-23T12:47:49.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一张<code>w*h</code>大小的纸片，要求裁剪出一个<code>a*b*c</code>的长方体的展开图，问是否可行。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>长方体展开图共有11种情况，分别算出每种情况所需要的长宽，然后枚举验证即可。</p><p>P.S. 小学奥数题的升级版。一开始用蛮力想象展开图平起来后的边的情况。但毕竟自己的空间想象能力并不是很强，而且这样很费时，所以并不是好的做法。其实只要在展开图中根据相邻关系标上边的长度即可。</p><p>P.S. opentrain的测试数据很弱，集训时1A。回来交CF，WA了第40个点。改了一个小时后，WA第55个点。原来自己的next_permutation用在了原边长数组上，犯了一个低级错误。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">3</span>],inx[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">true<span class="keyword">int</span> w, h;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">true<span class="keyword">if</span> (a &lt;= w &amp;&amp; b &lt;= h) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">true<span class="keyword">if</span> (b &lt;= w &amp;&amp; a &lt;= h) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">true<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);</span><br><span class="line">true</span><br><span class="line">true<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w, &amp;h);</span><br><span class="line">true<span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">true<span class="keyword">do</span> &#123;</span><br><span class="line">truetrue<span class="keyword">int</span> a = A[inx[<span class="number">0</span>]], b= A[inx[<span class="number">1</span>]], c = A[inx[<span class="number">2</span>]];</span><br><span class="line">truetrue<span class="keyword">if</span> (comp(<span class="number">2</span>*(a+c), b + <span class="number">2</span> * c)||</span><br><span class="line">truetruetruecomp(<span class="number">3</span>*b+a+c,a+c)|| </span><br><span class="line">truetruetruecomp(a+b+c,a+b+<span class="number">2</span>*c)|| </span><br><span class="line">truetruetruecomp(a+b+c,<span class="number">2</span>*b+<span class="number">2</span>*c)||</span><br><span class="line">truetruetruecomp(a+<span class="number">2</span>*b+c,a+<span class="number">2</span>*c)) find = <span class="literal">true</span>;</span><br><span class="line">true&#125;<span class="keyword">while</span> (!find &amp;&amp; next_permutation(inx, inx + <span class="number">3</span>));</span><br><span class="line">true<span class="built_in">puts</span>(find?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一张&lt;code&gt;w*h&lt;/code&gt;大小的纸片，要求裁剪出一个&lt;code&gt;a*b*c&lt;/code&gt;的长方体的展开图，问是否可行。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101630C [Connections] 2017-2018 ACM-ICPC, Northern Eurasia (Northeastern European Regional) Contest (NEERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/a35a5595.html"/>
    <id>http://dafenghh.github.io/post/a35a5595.html</id>
    <published>2018-01-23T11:01:49.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个强连通的有向图，n个点，m条边；要求，去掉m-2n条边，使剩下的图仍然强连通。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>采用DFS，将需要保留下的边打上记号。然后任意输出m-2n条不需要保留的边即可。</p><p>哪些边需要保留呢？</p><p>DFS前进的那些边（即搜索树中的边，“实边”）一定要保留，至于虚边，则保留得越少越好。</p><p>所以优先从搜索树的靠叶子端取虚边。比如DFS依次经过1-&gt;2-&gt;3-&gt;4, 我们就先从4开始取回去的边，回去得越前越好，即如果同时存在(4,3)和(4,2）就取（4，2）,然后回到结点2，再取一条(2,1)就能构成一个环，也即强连通的子图。</p><p>具体实现的话，dfs返回当前访问子树能够回去的最前结点（有点类似tarjan的lowlink）。对一个结点来说，所有虚边只需考虑最优那条（即返回的点index越小越好）。然后拿它跟子树返回结果的最小值（代表子树能够回去的最前结点）比较，如果这条虚边更有，就连上。</p><p>P.S. 1A这题，很开心！</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100020</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="built_in">map</span>&lt;P, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="keyword">bool</span> used[maxn];</span><br><span class="line"><span class="keyword">int</span> index[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    index[v] = cnt++;</span><br><span class="line">    used[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> bv = v, nbi = index[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: G[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">            M[P(v,i)] = <span class="number">1</span>;</span><br><span class="line">            nbi = min(nbi, dfs(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index[i] &lt; index[bv]) bv = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index[bv] &lt; nbi) &#123;</span><br><span class="line">        M[P(v, bv)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(nbi, index[bv]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">      M.clear();</span><br><span class="line">      cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">      <span class="built_in">memset</span>(index, <span class="number">0</span>, <span class="keyword">sizeof</span>(index));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">              <span class="keyword">int</span> x,y;</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">              G[x].push_back(y);</span><br><span class="line">              M[P(x,y)] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      dfs(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i: M) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!i.second) &#123;</span><br><span class="line">              tot++;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i.first.first, i.first.second);</span><br><span class="line">              <span class="keyword">if</span> (tot == m - <span class="number">2</span> * n) <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个强连通的有向图，n个点，m条边；要求，去掉m-2n条边，使剩下的图仍然强连通。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="graphs" scheme="http://dafenghh.github.io/tags/graphs/"/>
    
      <category term="dfs and similar" scheme="http://dafenghh.github.io/tags/dfs-and-similar/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3470 [Walls] 题解</title>
    <link href="http://dafenghh.github.io/post/7d2ff651.html"/>
    <id>http://dafenghh.github.io/post/7d2ff651.html</id>
    <published>2018-01-22T15:11:51.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>平面上有n条与坐标轴平行的互不相交的线段，代表墙；还有m个不在线段上的点，代表鸟。鸟会沿着坐标轴方向，飞向离它最近的墙，并撞上去。求每一面墙会有多少只鸟撞上来。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>先离散化坐标。</p><p>按其中一个坐标（比如y）排好序后，使用扫描线算法，对于另一个坐标（比如x）建一棵支持区间更新和单点查询的线段树，表示每一个点当前会撞向的墙的序号。</p><p>自己写的扫描线啰嗦地惨不忍睹，WA很多次都没过。</p><p>参考了下<a href="http://www.cnblogs.com/forever97/p/poj3470.html" target="_blank" rel="noopener">forever97</a> 的代码，非常简洁优雅，落落大方。真是感激不尽！</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200020</span>;</span><br><span class="line"><span class="keyword">int</span> tr[maxn * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = maxn - <span class="number">20</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[v] != <span class="number">-2</span>) <span class="keyword">return</span> tr[v];</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) <span class="keyword">return</span> tr[v];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; mid) <span class="keyword">return</span> query(x, chl, l, mid);</span><br><span class="line">    <span class="keyword">return</span> query(x,chr,mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> val, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = maxn - <span class="number">20</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= L || R &lt;= l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        tr[v] = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[v] != <span class="number">-2</span>) &#123;</span><br><span class="line">        tr[chl] = tr[chr] = tr[v];</span><br><span class="line">        tr[v] = <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    update(L, R, val, chl, l, mid);</span><br><span class="line">    update(L, R, val, chr, mid, r);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> X[maxn], Y[maxn], X_inx[maxn], Y_inx[maxn],X_comp[maxn], Y_comp[maxn],</span><br><span class="line">    wall_to_fly[maxn], total_for_wall[maxn],dis[maxn];</span><br><span class="line"><span class="keyword">int</span> *arr;</span><br><span class="line"><span class="keyword">int</span> wn,pn; <span class="comment">// wall point</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[a] &lt; arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">int</span> *X, <span class="keyword">int</span> *Comp,<span class="keyword">int</span> *Inx, <span class="keyword">int</span> n=pn)</span> </span>&#123;</span><br><span class="line">    arr = X;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) Inx[i] = i;</span><br><span class="line">    sort(Inx, Inx + n, cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;Comp[Inx[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (X[Inx[i]] != X[Inx[i<span class="number">-1</span>]]) cnt++;</span><br><span class="line">        Comp[Inx[i]] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">(<span class="keyword">int</span> *X, <span class="keyword">int</span> *Y, <span class="keyword">int</span> *X_comp, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; wn) &#123;</span><br><span class="line">        <span class="keyword">int</span> i_ = i^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (X_comp[i_] &gt;= X_comp[i]) &#123;</span><br><span class="line">            update(X_comp[i], X_comp[i_]+<span class="number">1</span>,i/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = query(X_comp[i]);</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = min(<span class="built_in">abs</span>(Y[i] - Y[<span class="number">2</span>*q]), <span class="built_in">abs</span>(Y[i] - Y[<span class="number">2</span>*q+<span class="number">1</span>]));</span><br><span class="line">            i-=wn;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] == <span class="number">-1</span> || d &lt; dis[i]) &#123;</span><br><span class="line">                dis[i] = d;</span><br><span class="line">                wall_to_fly[i] = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span> *X, <span class="keyword">int</span> *Y, <span class="keyword">int</span> *X_comp, <span class="keyword">int</span> *Inx)</span> </span>&#123;</span><br><span class="line">    tr[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pn; i++) scan(X, Y, X_comp, Inx[i]);</span><br><span class="line">    tr[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pn; i &gt;= <span class="number">0</span>; i--) scan(X, Y, X_comp, Inx[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">int</span> n_, m_;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n_, &amp;m_);</span><br><span class="line">    wn = <span class="number">2</span> * n_;</span><br><span class="line">    pn = wn + m_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pn; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, X + i, Y + i);</span><br><span class="line">    compress(X, X_comp, X_inx);</span><br><span class="line">    compress(Y, Y_comp, Y_inx);</span><br><span class="line">    fly(X, Y, X_comp, Y_inx);</span><br><span class="line">    fly(Y, X, Y_comp, X_inx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_; i++) total_for_wall[wall_to_fly[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, total_for_wall[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;平面上有n条与坐标轴平行的互不相交的线段，代表墙；还有m个不在线段上的点，代表鸟。鸟会沿着坐标轴方向，飞向离它最近的墙，并撞上去。求每一面墙会有多少只鸟撞上来。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="scanline" scheme="http://dafenghh.github.io/tags/scanline/"/>
    
  </entry>
  
  <entry>
    <title>NWERC 2017 A [Ascending Photo] (The 2017 Northwestern Europe Regional Contest) 题解</title>
    <link href="http://dafenghh.github.io/post/7c1f2f41.html"/>
    <id>http://dafenghh.github.io/post/7c1f2f41.html</id>
    <published>2018-01-22T15:08:38.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p><a href="https://open.kattis.com/contests/nwerc17open/problems/ascendingphoto" target="_blank" rel="noopener">题目链接</a></p><p>给定一个序列，将它切割成若干段，使得对每一段进行移动之后可以重排成非严格升序。求最少的切割数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>（集训的时候就差DP这步没想出来。）</p><p>首先先将相邻的相同元素合并，并进行离散化（不影响答案）。</p><p>然后现在将数组的每一个元素都切开（即切n-1下），比如1|2|3|0|4</p><p>于是问题可以转化为，这n-1块“挡板”最多有多少块可以去掉，如果为s，那么最终答案就是n-1-s.</p><p>在上面的例子中，唯一能够去掉的挡板是(2,3), 即变成1|2 3|0|4</p><p>很显然，挡板能够去掉首先要满足，左右两个元素相差1.</p><p>另外，假如有多块(2,3)挡板，比如对于1|2|3|4|2|3</p><p>(2,3)的挡板只能去掉其中一块（不然装不回来）。所以，我们可以先将所有值出现的位置保存到vector中，然后从小到大考虑值，每两个相邻的值应该去掉哪一块挡板（有可能去不掉）。</p><p>另外，如果去掉前面的(2,3)挡板，这时候会发现，紧接着后面的(3,4)挡板就去不了了。</p><p>否则会变成：1|2 3 4|2|3</p><p>可以看到最右边的3落下了。</p><p>所以可以看到，去掉一个挡板有可能会产生一个冲突位置。具体地说，如果存在连续序列(a,a+1,a+2), 并且a+1在数组中不唯一，那么去掉(a,a+1)挡板将会导致(a+1,a+2）的挡板无法去除。</p><p>用<code>dp[i]</code>表示去除值(0,1)到值(i,i+1)的所有可去除的挡板数量。</p><p>注意到，<code>dp[i]</code>的值与每一步去除哪一块可选挡板有关，所以要加多一维。<code>dp[i][j]</code>的j表示，去除值(i,i+1)的挡板时，考虑的是位置(j,j+1)</p><p>即首先i和j有条件，<code>h[j] = i, h[j+1] = i+1</code></p><p><code>dp[i][j] = max(dp[i-1][j&#39;] + （j是不是j&#39;产生的冲突位置?0:1）)</code></p><p>“j是不是j’产生的冲突位置” 等价于<code>j = j&#39; + 1 &amp;&amp; h[j]不唯一</code></p><p>从这个条件可以看出，对于一个j’，最多产生一个冲突位置，j’+1(当h[j’+1]唯一就不是冲突位置）。</p><p>对于一个j，只可能是一个位置j’ = j - 1的冲突位置。（条件*）</p><p>如果我们把dp[i]看成一张表，那么最后我们求的就是dp[n]的最大值。</p><p>观察转移方程，从dp[i]向dp[i+1]转移的时候，求max的是dp[i]这张表的所有元素，但其中有些元素加了1（条件j不是j’的冲突位置）。</p><p>所以，我们只需保存这张表最大的那些值就行了。比如某个dp[i]={1,2,3,4,5,5,5}, 我们只需要保存{5,5,5}就行，因为前面的数，比如4，加上1也才是5，并不会更优。</p><p>dp[i+1]的值有可能是5，也有可能是6，要看三个5之中，有没有一个5对应的冲突位置不是j，这个5就能加上1，变成6.</p><p>回顾条件*，当我们保存了两个dp值最大的j’对应的冲突位置时，那么求 <code>dp[i][j]</code> 就能一定找到一个不冲突的位置，然后累计加上1.</p><p>所以，每一步dp求出的表中，只需要保存最大两个值以及它们对应的冲突位置即可，下面代码，用best[0]和best[1]保存最大两个值以及对应的冲突位置。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">true<span class="keyword">char</span> ch; <span class="keyword">int</span> v=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">true<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch=getchar())) <span class="keyword">if</span> (ch==<span class="string">'-'</span>) <span class="keyword">break</span>;</span><br><span class="line">true<span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">1</span>;<span class="keyword">else</span> v=ch<span class="number">-48</span>;</span><br><span class="line">true<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch=getchar())) v=v*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">true<span class="keyword">return</span> f?-v:v;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000020</span>;</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; H;</span><br><span class="line">    <span class="keyword">int</span> n = get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = get();</span><br><span class="line">        <span class="keyword">if</span> (H.empty() || H.back() != x) H.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    n = (<span class="keyword">int</span>)H.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) b[i] = H[i];</span><br><span class="line">    sort(b, b + n);</span><br><span class="line">    <span class="keyword">int</span> sz = unique(b, b + n) - b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; posi(sz);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) H[i] = lower_bound(b, b + sz, H[i]) - b, posi[H[i]].push_back(i);</span><br><span class="line">    P best[<span class="number">2</span>] = &#123;P(<span class="number">0</span>, n), P(<span class="number">0</span>, n)&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; sz - <span class="number">1</span>; h++) &#123;</span><br><span class="line">        P nbest[<span class="number">2</span>] = &#123;best[<span class="number">0</span>], best[<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; posi[h].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = posi[h][i];</span><br><span class="line">            <span class="keyword">if</span> (p == n - <span class="number">1</span> || H[p] + <span class="number">1</span> != H[p + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="function">P <span class="title">s</span><span class="params">(<span class="number">0</span>, n)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (p != best[<span class="number">0</span>].second) s = best[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> s = best[<span class="number">1</span>];</span><br><span class="line">            s.first++, s.second = p + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (posi[h + <span class="number">1</span>].size() == <span class="number">1</span>) s.second = n;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; nbest[<span class="number">0</span>]) nbest[<span class="number">1</span>] = nbest[<span class="number">0</span>], nbest[<span class="number">0</span>] = s;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; nbest[<span class="number">1</span>]) nbest[<span class="number">1</span>] = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        best[<span class="number">0</span>] = nbest[<span class="number">0</span>], best[<span class="number">1</span>] = nbest[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - <span class="number">1</span> - best[<span class="number">0</span>].first);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://open.kattis.com/contests/nwerc17open/problems/ascendingphoto&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个序列，将它切割成若干段，使得对每一段进行移动之后可以重排成非严格升序。求最少的切割数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="dp" scheme="http://dafenghh.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101620D [Donut Drone] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/a74fadaa.html"/>
    <id>http://dafenghh.github.io/post/a74fadaa.html</id>
    <published>2018-01-21T12:41:28.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一个矩形方块，有r*c个格子，水平和垂直方向上都可以将它视为首尾相连的（也即从最右边向右移会回到最左边，从最下边向下移会回来最上边，以此类推）。每个格子上有一个数。每一次移动会往相邻的右边、右上、右下的三个格子中选最大数的格子移动。初始位置在左上角。两种操作：1. 移动k步，输出新位置；2.修改某个格子的数。</p><p>数据范围：r，c $\leq$ 2000, 询问数5000以内。 </p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>移动k步时，列数的增量是确定的（k），行数未知，由二维数组确定。</p><p>可以很自然地想到用线段树解决这个问题。线段树的每一个结点，维护的是一张从第l列到第r列, 即[L,r)，行数y的转移表（本来行数应该用x来表示，但是一开始敲时就弄混了，所以后面只好交换了x和y的定义）。</p><p>这样，当我们从第y行第x列出发时，若k比较小直接模拟。k比较大时，先查询线段树，拿到y在[x, c)的转移值y’。这样就回到了(y’,0) 即第一列。</p><p>然后一次走c步，即采用[0,c)的转移表，意思就是从第一列一直往右走，知道走回第一列。不断重复这个过程，每一次可以使步数+c。</p><p>理论上这么模拟可以使单次询问的复杂度达到O(k/c*log c);</p><p>但考虑到行数只有r个，所以只会产生长度不超过r的环。所以把经过的点记录一下，产生环即跳出。这样复杂度可以优化至O(r*log c).</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1234567890</span>;</span><br><span class="line"><span class="keyword">int</span> dat[<span class="number">4</span> * maxn][maxn], row, col , a[maxn][maxn], NY[maxn][maxn],circle[maxn],posi[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = col)</span> </span>&#123; <span class="comment">// [l, r)</span></span><br><span class="line">     <span class="keyword">if</span> (x2 &lt;= l || r &lt;= x1) <span class="keyword">return</span> y;</span><br><span class="line">     <span class="keyword">if</span> (x1 &lt;= l &amp;&amp; r &lt;= x2) <span class="keyword">return</span> dat[v][y];</span><br><span class="line">     <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span> LAns = query(y, x1, x2, chl, l, mid);</span><br><span class="line">     <span class="keyword">return</span> query(LAns, x1, x2, chr, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = col)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (x &lt; l || x &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">            dat[v][y] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">     update(x, y, val, chl, l, mid);</span><br><span class="line">     update(x, y, val, chr, mid, r);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) dat[v][i] = dat[chr][dat[chl][i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) dat[v][i] = NY[l][i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    build(chl, l, mid);</span><br><span class="line">    build(chr, mid, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        dat[v][i] = dat[chr][dat[chl][i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v; <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch=getchar()));</span><br><span class="line">    v=ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch=getchar())) v=v*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nx = (x + <span class="number">1</span>) % col, Max = -INF, res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt;= <span class="number">1</span>; dy++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ny = (y + dy + row) % row;</span><br><span class="line">        <span class="keyword">if</span> (a[nx][ny] &gt; Max) &#123;</span><br><span class="line">            Max = a[nx][ny];</span><br><span class="line">            res = ny;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    row = read(), col = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) a[j][i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) NY[j][i] = getNY(j, i);</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    build();</span><br><span class="line">    <span class="keyword">int</span> m = read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'m'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = read();</span><br><span class="line">            <span class="keyword">if</span> (k &gt; col) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x != <span class="number">0</span>) k-= col-x, y = query(y,x,col),x=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memset</span>(posi, <span class="number">-1</span>, <span class="keyword">sizeof</span>(posi));</span><br><span class="line">                circle[<span class="number">0</span>] = y;</span><br><span class="line">                posi[y] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> ci = k / col;</span><br><span class="line">                k -= ci * col;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ci; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    circle[i] = y = query(y, <span class="number">0</span>, col);</span><br><span class="line">                    <span class="keyword">if</span> (posi[y] != <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> len = i - posi[y];</span><br><span class="line">                        y = circle[posi[y] + (ci - posi[y]) % len];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    posi[y] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (k &gt; <span class="number">0</span>) y = query(y, <span class="number">0</span>, k);</span><br><span class="line">                x = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                    y = NY[x][y];x = (x + <span class="number">1</span>) % col;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, y + <span class="number">1</span>, x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> cy = read() - <span class="number">1</span>, cx = read() - <span class="number">1</span>, val = read();</span><br><span class="line">            a[cx][cy] = val;</span><br><span class="line">            <span class="keyword">int</span> px = (cx + col - <span class="number">1</span>) % col;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt;= <span class="number">1</span>; dy++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> py = (cy + dy + row) % row;</span><br><span class="line">                <span class="keyword">int</span> temp = getNY(px, py);</span><br><span class="line">                <span class="keyword">if</span> (NY[px][py] != temp) &#123;</span><br><span class="line">                    NY[px][py] = temp;</span><br><span class="line">                    update(px, py, temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;一个矩形方块，有r*c个格子，水平和垂直方向上都可以将它视为首尾相连的（也即从最右边向右移会回到最左边，从最下边向下移会回来最上边，以此类推）。每个格子上有一个数。每一次移动会往相邻的右边、右上、右下的三个格子中选最大数的格子移动。初始位置在左上角。两种操作：1. 移动k步，输出新位置；2.修改某个格子的数。&lt;/p&gt;
&lt;p&gt;数据范围：r，c $\leq$ 2000, 询问数5000以内。 &lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5249 [KPI] 题解</title>
    <link href="http://dafenghh.github.io/post/a54ea176.html"/>
    <id>http://dafenghh.github.io/post/a54ea176.html</id>
    <published>2018-01-17T07:59:57.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>n次操作，有3种操作的类型：入队、出队、查询队列中的中位数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>区间第K大的简单版本。用权值线段树可以轻松解决。这里尝试使用一下树状数组。这里搞明白树状数组的原理后，findK函数可以写得很清晰。</p><p>稍微解释一下findK函数，从x=1&lt;&lt;16（值的上界）开始定位答案，判定bit[]数组的值来定位答案位于权区间的左半部分还是右半部分。反复执行这个过程，逐步缩小区间得到答案。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10020</span>;</span><br><span class="line"><span class="keyword">int</span> tot, bit[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= tot; i += i &amp; -i) bit[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>); x; x &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans + x &lt; tot &amp;&amp; bit[ans + x] &lt; k) &#123;</span><br><span class="line">            k -= bit[ans += x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> Q[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qn, ti = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;qn) != EOF) &#123;</span><br><span class="line">        init();</span><br><span class="line">        ++ti;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ti);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qn; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            Q[i] = s[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Q[i] == <span class="string">'i'</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[n]);</span><br><span class="line">                b[n] = a[n];</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b, b + n);</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = lower_bound(b, b + n, a[i]) - b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ql = <span class="number">0</span>, qr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qn; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q[i] == <span class="string">'i'</span>) &#123;</span><br><span class="line">                update(a[qr++], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Q[i] == <span class="string">'o'</span>) &#123;</span><br><span class="line">                update(a[ql++], <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[findK((qr - ql + <span class="number">2</span>)/ <span class="number">2</span>)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;n次操作，有3种操作的类型：入队、出队、查询队列中的中位数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1201 [Intervals] 题解</title>
    <link href="http://dafenghh.github.io/post/a568ae24.html"/>
    <id>http://dafenghh.github.io/post/a568ae24.html</id>
    <published>2018-01-17T03:18:14.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定n个区间，现在要从每个区间$[a_i, b_i]$中取出$c_i$个数，所有被取出的数组成一个集合。求这个集合的最小size.</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>这种区间覆盖问题，首先考虑贪心法。如果将所有顶点按右端点排序后，依次取数。对每一个区间，尽量取靠右边的数。这是一个挺好的贪心策略，容易证明其正确性。</p><p>那么，对每个区间，需要做的事情有两步：</p><ol><li>（统计）统计这个区间上已经被取过的数的数量，如果已满足要求，则OK；否则进行第二步。</li><li>（取数）从右往左依次取新数，直到满足要求。</li></ol><p>朴素做法，统计这一步就需要O(n)复杂度，总计O(n^2), 显然不可行。</p><p>我们可以采用BIT，把统计这一步优化到O(log n）。</p><p>但第二步，取数的复杂度呢？</p><p>直觉来看，最坏情况下，每次取数要O(n)的时间，那么总体是O（n^2）复杂度。</p><p>但是，考虑到区间长度有限，也是O(n)的级别，所以实际上达到最坏情况的区间很少；换句话说，需要频繁取数的区间是很少的。（如果一个区间取出了很多数，那么相应的，它之后的重叠区间需要取数的区间个数就会少一些。）</p><p>于是，第二步用朴素算法即可。虽然没能估计确切的复杂度，但提交后跑起来很快，94ms就过了。</p><p>第二种做法，转化成差分约束问题。</p><p>如果用d[i]表示做法一中，BIT的前缀和，那么条件(区间[a,b]中有c个数被取出来)<br>可以表示成不等式<code>d[b]-d[a-1]&gt;=c</code></p><p>有了这个不等关系，就可以很方便的转成差分约束问题了，另外还要加上初始约束：<code>d[i]&lt;=d[i+1]&lt;=d[i]+1</code></p><p>很好理解。</p><p>然后求解最短路，即可得到答案。</p><p>这道题我们求的是d[Max] - d[Min]的最小值，但是最短路求出来后对应的是一个最大值。</p><p>于是我们可以加个负号，求出d[Min] - d[Max]的最大值x，那么-x就是答案。如果一开始将d[Max]赋值为0，那么最后答案就是-d[Min].</p><p>采用经队列优化的Bellmen Ford算法，最坏情况下复杂度仍然为O(VE).但考虑到这题中的图对应了一个规则良好的差分约束系统，很难出现一个极端不均匀的图。所以这种做法耗时仅200ms。</p><p>P.S. POJ没有开O2优化，所以用vector表示邻接表，再一次跪了……</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><h2 id="solution-1-贪心-BIT"><a href="#solution-1-贪心-BIT" class="headerlink" title="solution 1 (贪心+BIT)"></a>solution 1 (贪心+BIT)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50050</span>;</span><br><span class="line"><span class="keyword">int</span> bit[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i; i -= lowbit(i)) s+= bit[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; maxn; i += lowbit(i)) bit[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; b.r;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">bool</span> used[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i].l = read() + <span class="number">1</span>, a[i].r = read() + <span class="number">1</span>, a[i].c = read();</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> need = a[i].c - (sum(a[i].r) - sum(a[i].l - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = a[i].r; x &gt;= a[i].l &amp;&amp; need &gt; <span class="number">0</span>; x--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[x]) &#123;</span><br><span class="line">                used[x] = <span class="literal">true</span>;</span><br><span class="line">                add(x, <span class="number">1</span>);</span><br><span class="line">                need--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(maxn - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solution-2-差分约束"><a href="#solution-2-差分约束" class="headerlink" title="solution 2 (差分约束)"></a>solution 2 (差分约束)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50050</span>, INF = <span class="number">12345634</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cost, next;</span><br><span class="line">    edge(<span class="keyword">int</span> to = <span class="number">0</span>, <span class="keyword">int</span> cost = <span class="number">0</span>, <span class="keyword">int</span> next = <span class="number">0</span>):to(to), cost(cost), next(next)&#123;&#125;</span><br><span class="line">&#125;a[<span class="number">4</span> * maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], ei = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    a[ei] = edge(v, c, head[u]);</span><br><span class="line">    head[u] = ei++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> used[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mini</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maxi</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">int</span> n_ = read();</span><br><span class="line">    <span class="keyword">int</span> L = INF, R = -INF; <span class="comment">// [L, R]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = read() + <span class="number">1</span>, b = read() + <span class="number">1</span>, c = read();</span><br><span class="line">        add_edge(b, a - <span class="number">1</span>, -c);</span><br><span class="line">        Mini(L, a - <span class="number">1</span>);</span><br><span class="line">        Maxi(R, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; R; i++) add_edge(i, i + <span class="number">1</span>, <span class="number">1</span>), add_edge(i + <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">    fill(d, d + R + <span class="number">10</span>, INF);</span><br><span class="line">    d[R] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(R);</span><br><span class="line">    used[R] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        used[v] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[v]; i != <span class="number">-1</span>; i = a[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = a[i].to, cost = a[i].cost;</span><br><span class="line">            <span class="keyword">if</span> (d[v] + cost &lt; d[to]) &#123;</span><br><span class="line">                d[to] = d[v] + cost;</span><br><span class="line">                <span class="keyword">if</span> (!used[to]) que.push(to), used[to] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, -d[L]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定n个区间，现在要从每个区间$[a_i, b_i]$中取出$c_i$个数，所有被取出的数组成一个集合。求这个集合的最小size.&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="greedy" scheme="http://dafenghh.github.io/tags/greedy/"/>
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="graphs" scheme="http://dafenghh.github.io/tags/graphs/"/>
    
      <category term="差分约束" scheme="http://dafenghh.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3368 [Frequent Values] 题解</title>
    <link href="http://dafenghh.github.io/post/c9635eac.html"/>
    <id>http://dafenghh.github.io/post/c9635eac.html</id>
    <published>2018-01-11T01:54:21.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个长度为N的单调不下降的数组，M次询问，每次询问原数组区间[i, j]中，出现频数最多的数的频数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>先使用离散化，然后用lower_bound很方便的求出每一个值在原数组中的始点和终点。（终点可以用下一个值的始点表示）</p><p>然后构造一棵值分布的线段树，也就是说这棵线段树的每一个结点维护的是它所对应区间[l, r）中的值的最大的出现频数。</p><p>询问区间[i, j]， 先求出a[i], a[j]在[i,j]中的出现频数（用第一步求出的a[i]、a[j]的始点、终点位置很容易得到结果）。</p><p>然后往线段树中查询[a[i] + 1, a[j])即可。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, n, Q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], lt[maxn], tr[maxn * <span class="number">2</span>];<span class="comment">//left</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123; <span class="comment">// [l, r)</span></span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        tr[v] = lt[r] - lt[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span>, chr = chl + <span class="number">1</span>;</span><br><span class="line">        build(chl, l, mid);</span><br><span class="line">        build(chr, mid, r);</span><br><span class="line">        tr[v] = max(tr[chl], tr[chr]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;<span class="comment">// query [L, R) </span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || R &lt;= l || r &lt;= L) <span class="keyword">return</span> <span class="number">-12344</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[v];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span>, chr = chl + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> max(query(L, R, chl, l, mid), query(L, R, chr, mid, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        N = read();</span><br><span class="line">        <span class="keyword">if</span> (!N) <span class="keyword">break</span>;</span><br><span class="line">        Q = read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) a[i] = b[i] = read();</span><br><span class="line">        n = unique(b, b + N) - b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) a[i] = lower_bound(b, b + n, a[i]) - b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) lt[i] = lower_bound(a, a + N, i) - a;</span><br><span class="line">        lt[n] = N;</span><br><span class="line">        build();</span><br><span class="line">        <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = read(), r = read(); <span class="comment">//[l, r]</span></span><br><span class="line">            l--;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">-1244</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[l] == a[r]) ans = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                update(ans, lt[a[l] + <span class="number">1</span>] - l);</span><br><span class="line">                update(ans, r - lt[a[r]] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> L = a[l] + <span class="number">1</span>, R = a[r]; <span class="comment">// [L, R)</span></span><br><span class="line">                <span class="keyword">if</span> (L &lt; R)</span><br><span class="line">                update(ans, query(L, R));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个长度为N的单调不下降的数组，M次询问，每次询问原数组区间[i, j]中，出现频数最多的数的频数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2104 [K-th Number] 题解</title>
    <link href="http://dafenghh.github.io/post/76b5095a.html"/>
    <id>http://dafenghh.github.io/post/76b5095a.html</id>
    <published>2018-01-11T01:51:08.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个长度为n的数组，m次查询。每次查询给出三个数（i, j, k），表示要求原数组的区间[i, j]升序排列中的第k个数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>求区间第k小的经典题目！来源于《挑战程序设计竞赛》P185例题。然后发现，这道题在4个月之前，我学习主席树的时候就做过一次。</p><p>书上提供了平方分割和归并树的两种做法，下面我也将重现下这两种解法以及主席树的解法，并在最后对这三种优雅的解法作下对比。</p><h2 id="solution-1-分块"><a href="#solution-1-分块" class="headerlink" title="solution 1 (分块)"></a>solution 1 (分块)</h2><p>假如题目提供了一个函数cnt(i, j, x)，返回原数组区间[i, j]中小于x的数的个数。那么我们要求的区间[i,j]第k小的数，也就是要求满足cnt(i, j, x) &lt; k的最大的x。</p><p>于是，对x进行二分搜索，即可得到答案。</p><p>那么，我们怎么样才能自己写出一个类似于cnt(i, j, x)的函数呢？</p><p>假如数组区间[i, j]是有序的，那么我们很容易用lower_bound写出这个函数。</p><p>虽然原数组不是有序的，但这么想能够给我们带来灵感。</p><p>我们不妨把原数组分成若干块区间，然后对每一块区间进行排序。这就是分块算法。这样，数组在每一块区间内都是有序的。</p><p>于是对于要查询的区间[i, j]所包含的那些完整的区间块，我们采用lower_bound算出cnt值。</p><p>而区间[i, j]两端有一些元素是不在一个完整区间块的，对这些元素逐一检查即可。（反正这部分元素的个数不超过两倍块的长度，所以数量较少，逐一检查OK）</p><h2 id="solution-2-归并树"><a href="#solution-2-归并树" class="headerlink" title="solution 2 (归并树)"></a>solution 2 (归并树)</h2><p>除了使用分块算法算出函数cnt(i, j, x)的值外，我们还可以采用归并树的做法。</p><p>这里的归并树是一种特别的线段树，它完整记录下了归并排序的每一步结果。</p><p>也就是，归并树的每一个结点，维护的是一个vector，这个vector就保存着结点对应区间排序后的结果。</p><p>于是，建树的过程也就是归并排序的过程，只不过每一步merge的时候，要把中间的结果保存在线段树的结点的vector里。</p><p>所以我们计算cnt(i, j, x)的值的时候，用线段树的思想求解即可。</p><p>即，若查询区间与当前结点对应区间无交集，返回0；查询区间完整包含当前结点对应区间在内，则对当前结点的vector采用lower_bound返回结果；否则对线段树左右儿子递归查询，求和即可。</p><h2 id="solution-3-主席树"><a href="#solution-3-主席树" class="headerlink" title="solution 3 (主席树)"></a>solution 3 (主席树)</h2><p>前面两种做法都是采用使数组部分有序后统计cnt值的思想。Solution1 中的部分有序指块数组的部分有序，Solution2中部分有序指线段树维护区间的部分有序。</p><p>而主席树的做法采用完全不一样的思路。</p><p>主席树也是一种特殊的线段树。它不是像Solution2或者往常RMQ问题一样，维护原数组的区间；而是像维护值域的区间。</p><p>就是说，假如这个特殊的线段树的一个结点，维护的区间是[l, r), 记录值为dat，那么dat的意义是原数组中有多少个值位于[l, r)的范围内。</p><p>现在考虑，假设我们已经对要查询的区间[i, j]构造了这样一棵线段树，要查询第k小的值，怎么找？</p><p>其实很简单，从根结点找起，其实根结点对应的区间就是整个值域。考察左儿子的dat值，如果它大于等于k，也就是说有大于等于k个数位于左边的值域，于是我们就对左儿子进行递归查找；否则查找右儿子。直到查找的区间长度为1，那么这个就是答案。</p><p>那么，假如我们对所有O(n^2)个区间都建这样一棵关于值分布的线段树，我们就能对任意区间，查询到第k小的答案了。</p><p>显然，O(n^2)棵线段树是不现实的，根本没有这么多空间。</p><p>用一下前缀和的思想，考虑原数组区间[i, j]对应的线段树，其实它可以由[1, j]和[1, i - 1]两棵线段树的值作差而来。（这里的“作差”就是对线段树每一个结点的dat值求一次差）</p><p>所以我们实际上，只需要n棵线段树即可，n指值域长度。</p><p>但是， O(n)棵线段树仍然不现实，没有这么多空间。</p><p>主席树的巧妙之处就在这里。</p><p>考察第i棵线段树和第i+1棵线段树的区别，也就是原数组区间[1, i]和[1, i + 1]分别对应的线段树。我们发现，后一棵线段树，比前一棵线段树，仅仅多更新了原数组中的一个数，即a[i+1].</p><p>这样一来，两棵线段树仅仅只有从根到a[i+1]对应的叶这一条链是不同了（增加了1），其他结点完全相同。于是我们，只给这更新的一条链创建新结点可以，其他结点沿用旧的线段树的结点即可。</p><p>那么，更新的线段树高度为O(log n)，所以会有O(log n)个结点更新，也就是，这棵线段树实际只占用O(log n)的内存空间，但在逻辑上，它依然是棵完整的线段树。</p><p>另外，对于第零棵线段树，即原数组区间[1, 0]对应的线段树，所有结点dat值都为0，所以这整棵线段树用一个零结点来存就可以。</p><p>这样一来，我们就能够实现，只用了O(nlogn)的内存空间，存放下了n + 1棵线段树（包括第零棵）的信息，因为很多结点都被多棵线段树共享了嘛。</p><p>P.S.其实这种做法与第二种归并树的做法，有异曲同工之妙。归并树是把归并排序的中间结果全部记录下来。而主席树，实际上也是，把更新时的中间结果全部记录下来。对这样一棵表示值分布的线段树，我们依次从左往右拿原数组的值去更新线段树，每一次更新会修改O(log n)个结点，而主席树没有直接修改原树上的O(log n)个结点，而是新建了O(log n)个结点。这样，线段树在动态更新的过程中，每一个历史版本都被完整记录。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><h2 id="solution-1-分块-1"><a href="#solution-1-分块-1" class="headerlink" title="solution 1 (分块)"></a>solution 1 (分块)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100002</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> bucket[maxn / B][B];</span><br><span class="line"><span class="keyword">int</span> a[maxn],nums[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read(), m = read();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">        bucket[i/B][i%B] = a[i];</span><br><span class="line">        nums[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums, nums + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / B; i++) sort(bucket[i], bucket[i] + B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read(); </span><br><span class="line">        <span class="keyword">int</span> ul = <span class="number">0</span>, ur = n;</span><br><span class="line">        <span class="keyword">while</span> (ul + <span class="number">1</span> &lt; ur) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (ul + ur) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, tl = l - <span class="number">1</span>, tr = r; <span class="comment">// the number of items less than nums[mid]</span></span><br><span class="line">            <span class="keyword">while</span> (tl &lt; tr &amp;&amp; tl % B) cnt += (a[tl++] &lt; nums[mid]); </span><br><span class="line">            <span class="keyword">while</span> (tl &lt; tr &amp;&amp; tr % B) cnt += (a[--tr] &lt; nums[mid]);</span><br><span class="line">            <span class="keyword">while</span> (tl &lt; tr) &#123;</span><br><span class="line">                <span class="keyword">int</span> bi = tl / B;</span><br><span class="line">                cnt += lower_bound(bucket[bi], bucket[bi] + B, nums[mid]) - bucket[bi];</span><br><span class="line">                tl += B;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= k) ur = mid;</span><br><span class="line">            <span class="keyword">else</span> ul = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nums[ul]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solution-2-归并树-1"><a href="#solution-2-归并树-1" class="headerlink" title="solution 2 (归并树)"></a>solution 2 (归并树)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n,m,nums[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[maxn * <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        vec[v].push_back(a[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span>, chr = v * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        build(chl, l, mid);</span><br><span class="line">        build(chr, mid, r);</span><br><span class="line">        vec[v].resize(vec[chl].size() + vec[chr].size());</span><br><span class="line">        merge(vec[chl].begin(), vec[chl].end(), vec[chr].begin(), vec[chr].end(), vec[v].begin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> v = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || r &lt;= L || R &lt;= l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = lower_bound(vec[v].begin(), vec[v].end(), x) - vec[v].begin();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span>, chr = v * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res= query(L, R, x, chl, l, mid) + query(L, R, x, chr, mid, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(),m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = a[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums, nums + n);</span><br><span class="line">    build();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read();</span><br><span class="line">        l--;</span><br><span class="line">        <span class="keyword">int</span> ul = <span class="number">0</span>, ur = n;</span><br><span class="line">        <span class="keyword">while</span> (ul + <span class="number">1</span> &lt; ur) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (ul + ur) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (query(l, r, nums[mid]) &gt;= k) ur = mid;</span><br><span class="line">            <span class="keyword">else</span> ul = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nums[ul]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solution-3-主席树-1"><a href="#solution-3-主席树-1" class="headerlink" title="solution 3 (主席树)"></a>solution 3 (主席树)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, dat;</span><br><span class="line">    node(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> dat = <span class="number">0</span>):l(l),r(r),dat(dat)&#123;&#125;</span><br><span class="line">&#125;T[maxn * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> rt[maxn], a[maxn], b[maxn], sz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;o, <span class="keyword">int</span> x, <span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// [l, r)</span></span><br><span class="line">    o = ++sz;</span><br><span class="line">    T[o] = T[last];</span><br><span class="line">    T[o].dat++;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; mid) update(T[o].l, x, T[last].l, l, mid);</span><br><span class="line">    <span class="keyword">else</span> update(T[o].r, x, T[last].r, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> t1, <span class="keyword">int</span> t2, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// [l, r)</span></span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> cnt = T[T[t2].l].dat - T[T[t1].l].dat, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= k) <span class="keyword">return</span> query(T[t1].l, T[t2].l, l, mid, k);</span><br><span class="line">    <span class="keyword">return</span> query(T[t1].r, T[t2].r, mid, r, k - cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fill(T, T + maxn * <span class="number">20</span>, node());</span><br><span class="line">    fill(rt, rt + maxn, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> N = read(), Q = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) b[i] = a[i] = read();</span><br><span class="line">    sort(b, b + N);</span><br><span class="line">    <span class="keyword">int</span> n = unique(b, b + N) - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = lower_bound(b, b + n, a[i]) - b;</span><br><span class="line">        update(rt[i + <span class="number">1</span>], a[i], rt[i], <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[query(rt[l - <span class="number">1</span>], rt[r], <span class="number">0</span>, n, k)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th style="text-align:center">Solution</th><th style="text-align:center">Time(ms)</th><th style="text-align:center">Memory(MB)</th><th style="text-align:center">Code Length</th></tr></thead><tbody><tr><td style="text-align:center">分块</td><td style="text-align:center">11516</td><td style="text-align:center">1.5</td><td style="text-align:center">1337</td></tr><tr><td style="text-align:center">归并树</td><td style="text-align:center">6344</td><td style="text-align:center">37.1</td><td style="text-align:center">1662</td></tr><tr><td style="text-align:center">主席树</td><td style="text-align:center">1735</td><td style="text-align:center">25</td><td style="text-align:center">1469</td></tr></tbody></table><p>最后送上三种解法的耗时，内存占用和代码长度的直观对比。</p><p>分块的实现最简单，代码最短，空间开销也最小，但非常慢，濒临超时。实际上，如果不加读入优化的话，那么分块就超时了。可见，非常凶险。</p><p>完美复现归并排序的归并树显然内存消耗是最高的，因为采用的是和分块一样的思路，也要有两层的二分查找，所以即使使用了线段树，但总耗时也只是节省了一半不到。</p><p>最后一种，主席树的做法，从原理上来讲，最复杂，但同时也最优美。从表中可以看出，时间比归并树快很多，空间开销和代码长度都最小，所以毫无疑问是本题的最佳解法。</p><p>P.S. 有同学可以提供比主席树更好的做法吗？感激不禁。（发现自己能在不同解法的对比中学到更多）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个长度为n的数组，m次查询。每次查询给出三个数（i, j, k），表示要求原数组的区间[i, j]升序排列中的第k个数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="sqrt decomposition" scheme="http://dafenghh.github.io/tags/sqrt-decomposition/"/>
    
      <category term="主席树" scheme="http://dafenghh.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2886 [Who gets the Most Candies] 题解</title>
    <link href="http://dafenghh.github.io/post/63c20c7e.html"/>
    <id>http://dafenghh.github.io/post/63c20c7e.html</id>
    <published>2018-01-10T06:46:27.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>N个孩子围一圈玩游戏， 按顺时针从1到N编号，每个孩子手上有张牌，牌上有个非零数字。给定数字K，一开始第K个孩子走出圈。每个出圈的孩子的牌上的数字将决定下一个出圈孩子是谁。若此时出圈孩子的牌的数字为x，正则往顺时针方向数到第x个孩子，负则逆时针方向数到第|x|个孩子，即为下一个要走出圈的孩子。</p><p>第i个出圈的孩子将获得F[i]个糖果。F[i]定义为正整数i的因数个数。输出获得糖果最多的孩子的名字和糖果数。若有多个答案，则输取出圈最早的孩子作为答案。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>采用取模的方法很容易算出当前需要出圈的是序列中第几个孩子。但这题难在，如果动态、快速地将一个序列中的一项删除呢？</p><p>不妨不存储实际的序列，而只是用一个BIT（树状数组）来表示每个孩子是否在场。</p><p>初始时，1-N的每个点的值都为1，表示每一个孩子都在场。若有一个孩子离场，则将它赋值为0即可。</p><p>很容易想到，若编号为i的孩子在场，那么前缀和sum(i)就表示他现在在队伍中的实际位置。</p><p>所以采用二分法，就可以快速确定队伍中排在第k位的孩子是谁。</p><p>时间复杂度为$O(n\log^2 n)$ n最大为500000，担心超时。但BIT采用lowbit来算的话，时间节省一半，即带上一个1/2的系数。</p><p>那么$0.5\times 500000 \times log_2^2 500000 = 8.96 \times 10^7 $</p><p>所以时间复杂度在可接受的范围内。</p><p>另外，算F[i]时直接用素数筛的方法做一遍预处理即可， O(n log n)的复杂度。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> F[maxn];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i * j &lt; maxn; j++) F[i * j]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bit[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i; i -= lowbit(i)) s += bit[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += lowbit(i)) bit[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kid</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, id;</span><br><span class="line">    kid(<span class="keyword">int</span> p = <span class="number">0</span>, <span class="keyword">int</span> id = <span class="number">0</span>):p(p), id(id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> kid &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (F[p] != F[b.p]) <span class="keyword">return</span> F[p] &lt; F[b.p];</span><br><span class="line">        <span class="keyword">return</span> p &gt; b.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;kid&gt; que;</span><br><span class="line"><span class="keyword">int</span> cards[maxn];</span><br><span class="line"><span class="keyword">char</span> names[maxn][<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">tr</span><span class="params">(ll x, ll n)</span> </span>&#123;</span><br><span class="line">    x += n * <span class="number">100000000L</span>L;</span><br><span class="line">    <span class="keyword">return</span> x % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getP</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum(mid) &lt; k) l = mid; <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> step, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ni = getP(k);</span><br><span class="line">    add(ni, <span class="number">-1</span>);</span><br><span class="line">    que.push(kid(step, ni));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    k += <span class="number">-1</span> + cards[ni];</span><br><span class="line">    <span class="keyword">if</span> (cards[ni] &gt; <span class="number">0</span>) k--;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) k = (<span class="keyword">int</span>)tr(k, n);</span><br><span class="line">    k %= n;</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(priority_queue&lt;kid&gt; &amp;que)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;kid&gt; q1;</span><br><span class="line">    swap(q1, que);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initF();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k) != EOF) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)   <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, names[i], cards + i);</span><br><span class="line">        Clear(que);</span><br><span class="line">        <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) add(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            k = solve(k, i, n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        kid ans = que.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, names[ans.id], F[ans.p]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;N个孩子围一圈玩游戏， 按顺时针从1到N编号，每个孩子手上有张牌，牌上有个非零数字。给定数字K，一开始第K个孩子走出圈。每个出圈的孩子的牌上的数字将决定下一个出圈孩子是谁。若此时出圈孩子的牌的数字为x，正则往顺时针方向数到第x个孩子，负则逆时针方向数到第|x|个孩子，即为下一个要走出圈的孩子。&lt;/p&gt;
&lt;p&gt;第i个出圈的孩子将获得F[i]个糖果。F[i]定义为正整数i的因数个数。输出获得糖果最多的孩子的名字和糖果数。若有多个答案，则输取出圈最早的孩子作为答案。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2155 [Matrix] 题解</title>
    <link href="http://dafenghh.github.io/post/5eb8db9.html"/>
    <id>http://dafenghh.github.io/post/5eb8db9.html</id>
    <published>2018-01-09T14:15:40.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一个N*N的布尔矩阵，初始值全为0，T次询问，两种操作：</p><ol><li>查询某个点的值</li><li>将一个矩形方块的布尔值全部翻转。</li></ol><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>二维BIT的简单题目。一维BIT很容易扩展成二维，直接加多一层循环即可，单次操作复杂度由$O(\log n)$变成$O(\log^2 n)$</p><p>区间更新转化为4个端点的更新即可。</p><p>由于每个点只有两种状态，所以用异或处理非常方便。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1020</span>;</span><br><span class="line"><span class="keyword">int</span> bit[maxn][maxn], n, q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// [1..x, 1..y]</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i))</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &gt; <span class="number">0</span>; j -= lowbit(j))</span><br><span class="line">        res ^= bit[i][j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= n; j += lowbit(j))</span><br><span class="line">        bit[i][j] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    add(x1, y1);</span><br><span class="line">    add(x1, y2 + <span class="number">1</span>);</span><br><span class="line">    add(x2 + <span class="number">1</span>, y1);</span><br><span class="line">    add(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x,y;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(x, y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">                update(x1, y1, x2, y2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;一个N*N的布尔矩阵，初始值全为0，T次询问，两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查询某个点的值&lt;/li&gt;
&lt;li&gt;将一个矩形方块的布尔值全部翻转。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3468 [A Simple Problem with Integers] 题解</title>
    <link href="http://dafenghh.github.io/post/8b465320.html"/>
    <id>http://dafenghh.github.io/post/8b465320.html</id>
    <published>2018-01-09T09:30:31.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出长度为N的数组，Q次询问，每次询问有两种操作：</p><ol><li>查询某个区间的和。</li><li>将某个区间的数全部加上x。</li></ol><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>要同时支持区间更新和区间查询（求和）两种操作，考虑树状数组。</p><p>但我们知道，树状数组只支持区间查询和点更新，或者区间更新和点查询。怎么样才能做到同时更新区间以及对区间求和呢？</p><p>我们先来考察区间更新后，前缀和的增量。记前缀和为S(i)，更新区间[l,r]后前缀和为S’(i).</p><p>$$\begin{eqnarray}S’(i)= \begin{cases} S(i), &amp;i<l\cr s(i)="" +="" x(i-l+1),="" &l\leqslant="" i\leqslant="" r="" \cr="" s(i)+x(r-l+1),="" &i="">r\end{cases} \end{eqnarray} $$</l\cr></p><p>留意到i<l时，增量为0，无需处理；i>r时，增量为常数，像普通BIT那样进行一次点更新即可。</l时，增量为0，无需处理；i></p><p>难就难在， $l\leqslant i\leqslant r$时，增量是一个关于i的一次函数。</p><p>如前面所说，普通BIT进行一次点更新只能导致前缀和增加一个常数。既然如此，我们把上面这个一次函数的增量拆成两项，用两个BIT维护：</p><p>$$\Delta S(i)=xi + x(1-l) $$<br>一次项系数为x，常数项为x(1-l)，分别对应BIT1和BIT0的增量值。</p><p>这样，记BIT0前缀和为s0，BIT1前缀和为s1，则总的前缀和就是<code>s0 + s1 * x</code></p><p>用前缀和来表示原数组的每一个值，然后区间求和就可转化为左右端点的前缀和差值，即点查询+区间更新的模式。</p><p>然后，更新的时候，分别对BIT0和BIT1进行区间更新即可（实质上是更新两个端点）。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line">ll bit[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll s0 = <span class="number">0</span>, s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) s0 += bit[<span class="number">0</span>][i], s1 += bit[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">return</span> s0 + s1 * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> x, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) bit[ti][i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll val)</span> </span>&#123; <span class="comment">// [l, r]</span></span><br><span class="line">    add(<span class="number">0</span>, l, val * (<span class="number">1</span> - l));</span><br><span class="line">    add(<span class="number">1</span>, l, val);</span><br><span class="line">    add(<span class="number">0</span>, r + <span class="number">1</span>, val * r);</span><br><span class="line">    add(<span class="number">1</span>, r + <span class="number">1</span>, -val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        update(i, i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> l, r, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, s, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum(r) - sum(l - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            update(l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给出长度为N的数组，Q次询问，每次询问有两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查询某个区间的和。&lt;/li&gt;
&lt;li&gt;将某个区间的数全部加上x。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>ZOJ 4003 [Distance] 题解</title>
    <link href="http://dafenghh.github.io/post/6c754de8.html"/>
    <id>http://dafenghh.github.io/post/6c754de8.html</id>
    <published>2018-01-09T05:05:12.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>定义两个维度为n的向量 $(a_1,a_2,a_3\dots a_n)$ 和 $(b_1,b_2,b_3\dots b<em>n)$ 间的距离为 $\sum </em>{i=1} ^n \left | a_i - b_i \right |^p$</p><p>现在给出向量$X = (x_1, x_2, x_3 \dots x_n)$ 和 $Y = (y_1, y_2, y_3 \dots y_n)$</p><p>定义子向量（subvector）为原向量的项中连续的一段。从X中取出一个子向量x, 从Y中取出一个子向量y，使得x和y长度相同，x和y的<br>距离小于给定值V。求这样的子向量对(x, y)的个数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>作一个n*n的矩阵<code>diff[][]</code>，记录X中的每一项到Y中的每一项的距离，</p><p>即 <code>diff[i][j] = |X[i] - Y[j]| ^ p</code></p><p>取出这个矩阵的每一条斜线的值，用尺取法统计结果即可。</p><p>P.S. 写这题时犯了很多智障错误。如%d写成%p，return res写成return x。</p><p>诸如此类。</p><p>如何避免这类typo的发生呢？</p><p>这是一个问题。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y--) res *= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(ll a[], <span class="keyword">int</span> n, ll V)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) &#123;</span><br><span class="line">        r = max(r, l);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; sum + a[r] &lt;= V) &#123;</span><br><span class="line">            sum += a[r];</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += r - l;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; l) sum -= a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1003</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn];</span><br><span class="line">ll diff[maxn][maxn],diag[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs_</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, p;</span><br><span class="line">        ll V;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld%d"</span>, &amp;n, &amp;V, &amp;p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, x + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, y + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            diff[i][j] = Pow(abs_(x[i] - y[j]), p);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> di = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> xi = <span class="number">0</span>, yi = i; xi &lt; n &amp;&amp; yi &lt; n; xi++, yi++)</span><br><span class="line">                diag[di++] = diff[xi][yi];</span><br><span class="line">           </span><br><span class="line">            ans += count(diag, di, V);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> di = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> xi = i, yi = <span class="number">0</span>; xi &lt; n &amp;&amp; yi &lt; n; xi++, yi++)</span><br><span class="line">                diag[di++] = diff[xi][yi];</span><br><span class="line">           </span><br><span class="line">            ans += count(diag, di, V);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;定义两个维度为n的向量 $(a_1,a_2,a_3\dots a_n)$ 和 $(b_1,b_2,b_3\dots b&lt;em&gt;n)$ 间的距离为 $\sum &lt;/em&gt;{i=1} ^n \left | a_i - b_i \right |^p$&lt;/p&gt;
&lt;p&gt;现在给出向量$X = (x_1, x_2, x_3 \dots x_n)$ 和 $Y = (y_1, y_2, y_3 \dots y_n)$&lt;/p&gt;
&lt;p&gt;定义子向量（subvector）为原向量的项中连续的一段。从X中取出一个子向量x, 从Y中取出一个子向量y，使得x和y长度相同，x和y的&lt;br&gt;距离小于给定值V。求这样的子向量对(x, y)的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="尺取法" scheme="http://dafenghh.github.io/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3109 [Inner Vertices] 题解</title>
    <link href="http://dafenghh.github.io/post/c38b5f65.html"/>
    <id>http://dafenghh.github.io/post/c38b5f65.html</id>
    <published>2018-01-05T08:17:54.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一个无限大的棋盘，给出N个点的坐标，初始时这些点上都放置着黑棋。其他所有点放置着白棋。若一个白棋的上下左右方向上都有黑棋，那么它会被替换成黑棋。求最终黑棋的数量。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>与cf 911G如出一辙的扫描线算法。</p><p>将所有点按y坐标排序后（y相同时按x排序），我们可以依次统计，相邻的两个y坐标相同的点之间的白点对答案的贡献。</p><p>假设这两个点为(x1, y0) (x2, y0) 那么我们要算的就是${(x, y) | x \in [x1 + 1, x2 - 1], y = y0}$的范围内有多少个<br>白棋变成了黑棋。</p><p>对于此范围中的一个点(xx, yy)，这一个点变成黑棋的充要条件是，(xx, yy)的上方和下方还有别的黑棋。</p><p>假设在原黑棋的点集合中，当x = xx时，y的最大、最小值分别为Max, Min。那么上面这个充要条件就可以表示为Min &lt; y &lt; Max.</p><p>我们很容易想到，当访问到y = yy的最低点也即(xx, Min)时，给x加上标记（表示此条线x == xx上的点将可能变黑）, 当访问到最高点即(xx, Max)时，给x消除标记（表示此条线x == xx上的点将不再会变黑）。</p><p>用BIT快速统计出区间[x1 + 1, x2 - 1]上会变黑的点的数量, 本题完成。</p><p>P.S. 这题做得也挺尴尬的，一开始写的扫描线算法还要统计出对每个x、y对应的y、x的极值，然后用很累赘的方法打标记，用了很多次vector，导致TLE。后来把vector全部去掉，全部换成数组才过。</p><p>感谢此篇博文<a href="http://blog.csdn.net/lolicon480/article/details/44183397" target="_blank" rel="noopener">by lolicon480</a> 提供的思路！</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">200010</span>;</span><br><span class="line">ll cnt = <span class="number">200020</span>;</span><br><span class="line">ll bit[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maxi</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lowbit</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll i)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i -= lowbit(i)) res += bit[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll i, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= cnt; i += lowbit(i)) bit[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    P(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>):x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(<span class="keyword">const</span> P&amp;a, <span class="keyword">const</span> P&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x != b.x) <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(<span class="keyword">const</span> P&amp;a, <span class="keyword">const</span> P&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.y != b.y) <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mx[maxn];</span><br><span class="line"><span class="keyword">bool</span> sc[maxn]; <span class="comment">// scope</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    sort(a, a + n, cmpx);</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i].x;</span><br><span class="line">        a[i].x = val;</span><br><span class="line">        <span class="keyword">if</span> (temp != a[i + <span class="number">1</span>].x) val++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + n, cmpy);</span><br><span class="line">    val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i].y;</span><br><span class="line">        a[i].y = val;</span><br><span class="line">        <span class="keyword">if</span> (temp != a[i + <span class="number">1</span>].y) val++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        Maxi(mx[a[i].x], a[i].y);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[i].x, y = a[i].y, nx = a[i + <span class="number">1</span>].x, ny = a[i + <span class="number">1</span>].y;</span><br><span class="line">        <span class="keyword">if</span> (!sc[x] &amp;&amp; y &lt; mx[x]) &#123;</span><br><span class="line">            sc[x] = <span class="literal">true</span>;</span><br><span class="line">            add(x, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y == ny &amp;&amp; nx &gt; x + <span class="number">1</span>) &#123;</span><br><span class="line">            ans += sum(nx - <span class="number">1</span>) - sum(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sc[x] &amp;&amp; y == mx[x]) &#123;</span><br><span class="line">            sc[x] = <span class="literal">false</span>;</span><br><span class="line">            add(x, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;一个无限大的棋盘，给出N个点的坐标，初始时这些点上都放置着黑棋。其他所有点放置着白棋。若一个白棋的上下左右方向上都有黑棋，那么它会被替换成黑棋。求最终黑棋的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="scanline" scheme="http://dafenghh.github.io/tags/scanline/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1990 [MooFest] 题解</title>
    <link href="http://dafenghh.github.io/post/a0a6f15.html"/>
    <id>http://dafenghh.github.io/post/a0a6f15.html</id>
    <published>2017-12-30T16:23:57.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>N头牛排成一排，现在给出它们的坐标x[i]和听觉阈值v[i]. 两头牛i和j之间谈话的音量为<code>max(v[i], v[j]) * dist(i, j)</code> dist表示两者距离。求所有N*(N-1)对牛谈话音量的总和。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>按v[i]降序排序。然后用BIT求出每一头牛和后面的牛的距离的和即可。（我用了两个BIT，一个维护累计和，一个维护个数）</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20200</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll bit[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i; i -= lowbit(i)) &#123;</span><br><span class="line">        res += bit[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">        bit[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll bit2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i; i -= lowbit(i)) &#123;</span><br><span class="line">        res += bit2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> i, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">        bit2[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cow</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, x;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> cow &amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; b.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].v, &amp;a[i].x), add(a[i].x, a[i].x), add2(a[i].x, <span class="number">1</span>);</span><br><span class="line">    sort(a, a + N);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        add(a[i].x, -a[i].x);</span><br><span class="line">        add2(a[i].x, <span class="number">-1</span>);</span><br><span class="line">        ll dist_tot = sum2(a[i].x) * a[i].x - sum(a[i].x) + sum(n) - sum(a[i].x) - (sum2(n) - sum2(a[i].x)) * a[i].x;</span><br><span class="line">        ans += dist_tot * a[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;N头牛排成一排，现在给出它们的坐标x[i]和听觉阈值v[i]. 两头牛i和j之间谈话的音量为&lt;code&gt;max(v[i], v[j]) * dist(i, j)&lt;/code&gt; dist表示两者距离。求所有N*(N-1)对牛谈话音量的总和。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 911G [Mass Change Queries] # educational round 35 题解</title>
    <link href="http://dafenghh.github.io/post/360e2773.html"/>
    <id>http://dafenghh.github.io/post/360e2773.html</id>
    <published>2017-12-30T13:20:40.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个数组a，长度为n，q次操作，每次操作给定四个整数，l,r,x,y表示将[l, r]区间中的值为x元素全部变成y，输出最终数组。</p><p>数据范围：<code>n, q &lt;= 200000, a[i], x, y &lt;= 100</code> </p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>educational round的最后一题，本来以为非常难，看了<a href="http://codeforces.com/contest/911/submission/33740346" target="_blank" rel="noopener">pannibal</a> 的代码后，非常惊奇。这道题竟能如此简洁优美地解决。于是关掉网页，用自己的代码习惯重打一遍（当然大部分雷同哈哈，毕竟这个解法真的太简洁了）。</p><p>总结一下思路：</p><ol><li><p>本题的难点在于每次操作，需要更新[l, r]的整段区间。如果直接更新，复杂度将是<code>O(nq)</code> ，不可接受。</p><p> 我们采用类似于用前缀和快速查询区间和的思想，讲区间转化为两个端点处理，即在区间开始处l打上一个标记，表示从这里开始，x将被视作y ，再在区间结束后的r+1处打上标记，表示还原x的状态（将x重新视为x）。</p><p> 或者说，这个修改操作包含两个修改，(1) [l, +inf)区间的x变成y; (2) [r+1, +inf)区间的x变回x.</p></li><li><p>另外，修改的顺序也是很重要的。我们将所有修改按照点的标记位置存在vector里。见main函数代码: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec[l].push_back(Change(t, x, y));</span><br><span class="line">vec[r + 1].push_back(Change(t, x, x));</span><br></pre></td></tr></table></figure><p> 其中t表示修改的顺序。这样一来，我们相当于将所有修改按点的位置重新排序。这么做有什么好处吗？其实，这就是这道题的关键转化步骤。</p><p> 作为一个经验尚浅的ACM选手，我对这题的直觉思路是依次考虑每次修改操作，寻找一种快速的更新区间方法。但注意到这道题只需要一个最终的结果，对中间结果并不关心。所以我们可以采用离线做法，不必完全跟从修改的次序来求解。</p><p> 那么我们采用怎样的求解次序呢？</p><p> 按数组下标依次求解最终结果。这也是很自然的思路，假如我们要求a[x]的最终结果，那么所有在x之后的点的更新对a[x]的值毫无影响。所以我们在输入完成后，依次拿出vec[i]的修改操作，来修改[i, +inf)这个区间. 这样在i后移的同时，我们就能依次得到a[i]的最终结果。</p></li><li><p>下面讨论如果实现每次修改操作。</p><p> 比如现在我们要把x的值变成y，是不是要找出数组中所有的x，然后依次赋值成y呢？显然时间不允许这么做。</p><p> 我们只需要存一份转移表（transition table）即可。一开始所有数字无变化，对所有的i， 有<code>T[i] = i</code>。 当我们将x修改成y时，修改T[x] = y;</p><p> 如果这样一份转移表被构造出来，那么我们要求<code>a[i]</code>的最终结果就很简单了，那就是<code>T[a[i]]</code></p><p> 但转移表既随时间（修改次序）变化，也随区间变化，即受两个维度影响，t维度（修改次序）和i维度（数组下标）。留意到，刚刚第2点说到，我们沿着i维度来提交修改。那么不妨，我们固定t维度，或称，保留下t维度的所有状态，即对每一个修改的时刻构造一张转移表。这道题最多200000次查询，也就是200000张转移表。</p><p> 比如我们在时刻t = 5和t = 6分别做了一次修改，得到两个转移表T_5, T_6, 很明显将T_5, T_6的转移表合并（合并的过程非常简单，相当于函数的组合）,就是这两次修改的最终效果。</p><p> 我们将所有转移表合并后得到的就是最终结果需要的转移表。而在i维度（数组下标）更新的过程中，我们需要快速地修改某些转移表，并将修改结果合并起来，得到a[i]的最终值。</p><p> 于是，线段树呼之欲出！线段树的每个叶子结点就代表一个时刻的转移表，它们的父结点就是合并后的转移表。对特定的x，所有修改合并操作都能在<code>O(log n)</code>时间内完成了。合并也只需要一条代码： <code>seg[t][i] = seg[chr][seg[chl][i]]</code></p><p> 解法非常简洁优美！</p></li></ol><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, x, y;</span><br><span class="line">    Change(<span class="keyword">int</span> t, <span class="keyword">int</span> x, <span class="keyword">int</span> y):t(t),x(x),y(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Change&gt; vec[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn], seg[maxn * <span class="number">2</span> + <span class="number">20</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAll</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, seg[<span class="number">1</span>][i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    seg[t += maxn][x] = y;</span><br><span class="line">    <span class="keyword">for</span> (t &gt;&gt;= <span class="number">1</span>; t; t &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> chl = t &lt;&lt; <span class="number">1</span>, chr = chl | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            seg[t][i] = seg[chr][seg[chl][i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt; maxn * <span class="number">2</span> + <span class="number">20</span>; t++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        seg[t][i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'-'</span>) flag=<span class="number">-1</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        ans=ans*<span class="number">10</span>+(<span class="keyword">int</span>)(c-<span class="string">'0'</span>);</span><br><span class="line">        c=getchar(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans*flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = get(), q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = get();</span><br><span class="line">    q = get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= q; t++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = get(), r = get(), x = get(), y = get();</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            vec[l].push_back(Change(t, x, y));</span><br><span class="line">            vec[r + <span class="number">1</span>].push_back(Change(t, x, x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cg: vec[i]) update(cg.t, cg.x, cg.y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, seg[<span class="number">1</span>][a[i]], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个数组a，长度为n，q次操作，每次操作给定四个整数，l,r,x,y表示将[l, r]区间中的值为x元素全部变成y，输出最终数组。&lt;/p&gt;
&lt;p&gt;数据范围：&lt;code&gt;n, q &amp;lt;= 200000, a[i], x, y &amp;lt;= 100&lt;/code&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="scanline" scheme="http://dafenghh.github.io/tags/scanline/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 908F [New Year and Rainbow Roads] (good bye 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/8234636.html"/>
    <id>http://dafenghh.github.io/post/8234636.html</id>
    <published>2017-12-30T07:05:48.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一维直线上的N个点，每个点有一个颜色标记（红、绿、蓝），现在要连边，一条边的代价为两点距离。现求最小总代价，使红、绿点连通，并且蓝、绿点连通。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>考虑到，红、蓝点连线并无意义，所以可忽略；另外考虑假如出现了连续三个点，颜色分别为红绿红，那么红和红之间连线一定不必红-绿-红这样连线优。所以，以绿点为分割点，分成若干个区间单独考虑即可。</p><p>对于两个连续的绿点之间的区间，有两种连线方式：（1）连接两个绿点，再以从这两个绿点为端点，连出两条线，分别连接中间的红点和蓝点，接着分别去掉这两条线的最长一个区间；（2）直接从这两个绿点为端点，连出两条线，分别连接中间的红点和蓝点。</p><p>分别统计两种连线方式的代价，选最优即可。</p><p>代码写得很丑，要看漂亮代码请戳这：<a href="http://codeforces.com/contest/908/submission/33789715" target="_blank" rel="noopener">by aaaaajack</a></p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; v0, v1, v2;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v.empty()) <span class="keyword">return</span>;</span><br><span class="line">    ans += max(<span class="number">0L</span>L, v0.front() - v.front()) + max(<span class="number">0L</span>L, v.back() - v0.back());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt;::<span class="function">iterator <span class="title">LB</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;v, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(v.begin(), v.end(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll l, ll r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LB(v1, l) == LB(v1, r) &amp;&amp; LB(v2, l) == LB(v2, r)) <span class="keyword">return</span> r - l;</span><br><span class="line">    ll x = l, max_interval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = LB(v1, l); it != v1.end() &amp;&amp; (*it) &lt; r; it++) &#123;</span><br><span class="line">        max_interval = max(max_interval, (*it) - x);</span><br><span class="line">        x = *it;</span><br><span class="line">    &#125;</span><br><span class="line">    max_interval = max(max_interval, r - x);</span><br><span class="line">    ll ans1 = <span class="number">3</span> * (r - l) - max_interval;</span><br><span class="line">    x = l; max_interval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = LB(v2, l); it != v2.end() &amp;&amp; (*it) &lt; r; it++) &#123;</span><br><span class="line">        max_interval = max(max_interval, (*it) - x);</span><br><span class="line">        x = *it;</span><br><span class="line">    &#125;</span><br><span class="line">    max_interval = max(max_interval, r - x);</span><br><span class="line">    ans1 -= max_interval;</span><br><span class="line">    <span class="keyword">return</span> min(ans1, <span class="number">2</span> * (r - l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'G'</span>) v0.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'B'</span>) v1.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> v2.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (v0.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v1.empty()) ans += v1.back() - v1.front();</span><br><span class="line">        <span class="keyword">if</span> (!v2.empty()) ans += v2.back() - v2.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        add(v1);</span><br><span class="line">        add(v2);</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; v0.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans += calc(v0[i], v0[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一维直线上的N个点，每个点有一个颜色标记（红、绿、蓝），现在要连边，一条边的代价为两点距离。现求最小总代价，使红、绿点连通，并且蓝、绿点连通。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="greedy" scheme="http://dafenghh.github.io/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 343D [Water Tree] 题解</title>
    <link href="http://dafenghh.github.io/post/a28d78f2.html"/>
    <id>http://dafenghh.github.io/post/a28d78f2.html</id>
    <published>2017-12-30T06:26:56.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一棵树，可以进行以下三种操作：</p><ol><li>选择一个结点v，使v对应的子树全部充满水。</li><li>选择一个结点v，除去v和v所有的祖先的水。</li><li>选择一个结点v，查询v是否有水。</li></ol><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>看完《挑战程序设计竞赛》的线段树章节后，搜了下codeforces的线段树题目来做，然后就搜到这题。这题做了很长时间哎，而且犯了不少很囧的错误。</p><p>首先看错了题，以为第二种操作是除去子树的水，所以很轻巧的敲了个BIT，跑起来不对才发现自己弄错了题意……</p><p>于是删掉代码重写。想到要更新所有祖先结点，岂不是要用树链剖分？参考了下cf的Tutorial，原来使用一个很巧妙的转化，就能变成普通的线段树问题。</p><p>我思考这题的时候，总是想着加水就是染成1，去水就是染成0，所以这两个操作分别对应子树的更新和路径的更新，这么做起来就很麻烦。Tutorial将思路倒转一下，便是去水只需要在v（最末端结点）上打个标记，加水是将子树上的所有标记去掉，查询某点是否有水是看这个点对应子树是否有标记，只要有一个标记，说明这点没水；没标记才表示有水。</p><p>而初始状态，我们将所有叶子结点打上标记，就可表示全没水的状态。</p><p>这样一来，确定dfs序之后，找出每个结点对应子树区间[L,R], 然后使用std::set即可实现这个算法，还很简单，都不需要线段树了。</p><p>cf上的前排代码求dfs时，将<code>R[v] = cnt + 1</code>写成<code>R[v] = ++cnt</code></p><p>我一开始很疑惑，这样写有什么区别，因为++后，就相当于对每个子树在末端新建了个虚拟的占位位置。</p><p>其实没区别。只是前排代码这么写，那么这一句<code>S.erase(S.lower_bound(L[v]), S.lower_bound(R[v]))</code> 的后半部分<code>S.lower_bound(R[v])</code>既可以用<code>lower_bound</code>, 又可以用<code>upper_bound</code>, 我的代码就只能用<code>lower_bound</code></p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> L[maxn], R[maxn], fa[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt,n ,q;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> par = <span class="number">-1</span>)</span> </span>&#123;</span><br><span class="line">    L[v] = ++cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i:G[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != par) &#123;</span><br><span class="line">            fa[i] = v;dfs(i, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    R[v] = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (R[v] == L[v] + <span class="number">1</span>) S.insert(L[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = S.lower_bound(L[v]);</span><br><span class="line">    <span class="keyword">return</span> it != S.end() &amp;&amp; (*it) &lt; R[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        G[x].push_back(y);</span><br><span class="line">        G[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;c, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">3</span>) <span class="built_in">puts</span>((empty(v) ? <span class="string">"0"</span> : <span class="string">"1"</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[v] &amp;&amp; empty(fa[v])) S.insert(L[fa[v]]);</span><br><span class="line">            S.erase(S.lower_bound(L[v]), S.lower_bound(R[v]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> S.insert(L[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一棵树，可以进行以下三种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择一个结点v，使v对应的子树全部充满水。&lt;/li&gt;
&lt;li&gt;选择一个结点v，除去v和v所有的祖先的水。&lt;/li&gt;
&lt;li&gt;选择一个结点v，查询v是否有水。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="trees" scheme="http://dafenghh.github.io/tags/trees/"/>
    
      <category term="dfs and similar" scheme="http://dafenghh.github.io/tags/dfs-and-similar/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3264 [Balance Lineup] 题解</title>
    <link href="http://dafenghh.github.io/post/de36ffa1.html"/>
    <id>http://dafenghh.github.io/post/de36ffa1.html</id>
    <published>2017-12-29T12:56:34.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>长度为N的数组，Q次查询，查询区间[A, B]的最大值与最小值之差。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>线段树模板题。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1234567</span>;</span><br><span class="line"><span class="keyword">int</span> mx[<span class="number">2</span> * maxn], lx[<span class="number">2</span> * maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123; <span class="comment">// a[x] = y;</span></span><br><span class="line">   <span class="comment">// printf("v = %d, l = %d, r = %d\n", v, l, r);</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || x &lt; l || x &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        mx[v] = lx[v] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        update(x, y, chl, l, mid);</span><br><span class="line">        update(x, y, chr, mid, r);</span><br><span class="line">        mx[v] = max(mx[chl], mx[chr]);</span><br><span class="line">        lx[v] = min(lx[chl], lx[chr]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || R &lt;= l || L &gt;= r) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> mx[v];</span><br><span class="line">    <span class="keyword">int</span> chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> max(queryMax(L, R, chl, l, mid), queryMax(L, R, chr, mid, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || R &lt;= l || L &gt;= r) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> lx[v];</span><br><span class="line">    <span class="keyword">int</span> chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> min(queryMin(L, R, chl, l, mid), queryMin(L, R, chr, mid, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    fill(mx, mx + <span class="number">2</span> * maxn, -INF);</span><br><span class="line">    fill(lx, lx + <span class="number">2</span> * maxn, INF);</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y);</span><br><span class="line">        update(i, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> A, B;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B);</span><br><span class="line">        <span class="keyword">int</span> L = A - <span class="number">1</span>, R = B;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, queryMax(L, R) - queryMin(L, R));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;长度为N的数组，Q次查询，查询区间[A, B]的最大值与最小值之差。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="trees" scheme="http://dafenghh.github.io/tags/trees/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2991 [Crane] 题解</title>
    <link href="http://dafenghh.github.io/post/a9a98564.html"/>
    <id>http://dafenghh.github.io/post/a9a98564.html</id>
    <published>2017-12-29T11:03:22.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>N条线段首尾相连，初始时全都垂直于x轴呈一直线。标号从下往上，1到N。C次询问，每次询问给出S和A，将第S条线段和第S+1条线段的角度修改成A，角度指的是从S开始沿逆时针方向旋转到S+1经过的角度。求每次询问时第N条线段的末端点坐标。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>《挑战程序设计竞赛》P170 例题，线段树的经典应用，很启发思维！</p><p>如何转化成线段树问题呢？</p><p>其实也是一种分治的思想。用v(i,j)表示第i条线段的始点到第j条线段的终点的向量，那么题目要求的就是每次更新后的v(1, n)<br>如何求得v(1, n)呢？分而治之，将区间折半，v(1, n) = v(1, n / 2) + v(n / 2 + 1, n),。</p><p>如果我们旋转第i条线段，那么显然i到n的线段坐标都要变化。这样一来，我们就需要对这所有的点更新坐标一次，很明显效率是不足够的。</p><p>我们需要将旋转的特征提取出来，在上面这个例子中，(i..n)的点的相对位置是不变的，只是整体发生了旋转。</p><p>所以，我们可以只记录一个整体旋转的角度$\alpha$ （相对于竖直方向的角度增量，逆时针为正），外加修改原来v(i, j)的定义，变成将第i条线段旋转至与地面垂直的时候，第i条线段的始点到第j条线段的终点的向量。</p><p>这样一来，我们求v(i,j)的实际值时，乘上$\alpha$对应的旋转变换矩阵即可：<br>\begin{bmatrix} \cos \alpha &amp; -\sin \alpha\\ \sin \alpha &amp; \cos \alpha \end{bmatrix}</p><p>所以构造这样一棵线段树，每个结点表示一段连续的线段区间，维护这两个值：</p><p>将线段区间的第一条线段旋转至垂直方向后，第一条线段的起点到最后一条线段的终点的向量 (v[i])<br>两个儿子连接后，右儿子需要旋转的角度 (ang[i])<br>记第i个结点的左右儿子结点为chl,chr，那么<br>v[i] = v[chl] + M(ang[i]) * v[chr]</p><p>P.S. WA了几发，原因是：当更新角度的线段s在当前区间mid之前时，我没有更新当前区间的ang值。后来发现，区间ang值的增量跟线段s角度增量一致。其实这个也很好理解（理解不了在图上画个三角形来旋转也能证明出来），因为旋转变换其实是对整个坐标系旋转，所以点旋转的是相同角度，向量旋转也是相同角度（注意平移变换不改变角度）。</p><p>P.S. 这题POJ有坑，输出格式是假的，样例中间不用加空行。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">double</span> vx[<span class="number">2</span> * maxn], vy[<span class="number">2</span> * maxn], ang[<span class="number">2</span> * maxn], prv[maxn];</span><br><span class="line"><span class="keyword">int</span> len[maxn];</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">// [l, r]</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    ang[v] = <span class="number">0</span>;</span><br><span class="line">    vx[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        vy[v] = len[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> chl = <span class="number">2</span> * v + <span class="number">1</span>, chr = <span class="number">2</span> * v + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    init(chl, l, mid);</span><br><span class="line">    init(chr, mid, r);</span><br><span class="line">    vy[v] = vy[chl] + vy[chr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">double</span> a, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// angle changes a</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= l ||s &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> chl = <span class="number">2</span> * v + <span class="number">1</span>, chr = <span class="number">2</span> * v + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    update(s, a, chl, l, mid);</span><br><span class="line">    update(s, a, chr, mid, r);</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= mid) ang[v] += a;</span><br><span class="line">    <span class="keyword">double</span> Co = <span class="built_in">cos</span>(ang[v]), Si = <span class="built_in">sin</span>(ang[v]);</span><br><span class="line">    vx[v] = vx[chl] + Co * vx[chr] - Si * vy[chr];</span><br><span class="line">    vy[v] = vy[chl] + Si * vx[chr] + Co * vy[chr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q)!=EOF) &#123;</span><br><span class="line">        testcnt++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, len + i);</span><br><span class="line">        init(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) prv[i] = PI;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="keyword">int</span> s, angle_360;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;angle_360);</span><br><span class="line">            <span class="keyword">double</span> a = (<span class="keyword">double</span>)angle_360 / <span class="number">180</span> * PI;</span><br><span class="line">            update(s, a - prv[s], <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">            prv[s] = a;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf %.2lf\n"</span>, vx[<span class="number">0</span>], vy[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;N条线段首尾相连，初始时全都垂直于x轴呈一直线。标号从下往上，1到N。C次询问，每次询问给出S和A，将第S条线段和第S+1条线段的角度修改成A，角度指的是从S开始沿逆时针方向旋转到S+1经过的角度。求每次询问时第N条线段的末端点坐标。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="geometry" scheme="http://dafenghh.github.io/tags/geometry/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2785 [4 Values whose Sum is 0] 题解</title>
    <link href="http://dafenghh.github.io/post/5396864a.html"/>
    <id>http://dafenghh.github.io/post/5396864a.html</id>
    <published>2017-11-30T14:45:20.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>大小都为N的四个数组<code>A[], B[], C[], D[]</code>, 从每个数组中分别选出一个数，<code>a, b, c, d</code> , 使得 <code>a + b + c + d = 0</code>，问有多少种选择方式。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>《挑战程序设计竞赛》P160例题。《挑战》通过这道题介绍了重要的思想方法，即“折半枚举”的方法，将问题一拆为二进行枚举。</p><p>枚举出<code>A[i]+B[j]</code>的所有可能值和<code>C[i]+D[j]</code>的所有可能值, 之后用二分查找互为相反数的两个值的组数即可。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4200</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn], d[maxn];</span><br><span class="line"><span class="keyword">int</span> ab[maxn * maxn], cd[maxn * maxn];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i] &gt;&gt; d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        ab[i * n + j] = a[i] + b[j], cd[i * n + j] = c[i] + d[j];</span><br><span class="line">    sort(cd, cd + n * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * n; i++)</span><br><span class="line">        ans += upper_bound(cd, cd + n * n, -ab[i]) - lower_bound(cd, cd + n * n, -ab[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;大小都为N的四个数组&lt;code&gt;A[], B[], C[], D[]&lt;/code&gt;, 从每个数组中分别选出一个数，&lt;code&gt;a, b, c, d&lt;/code&gt; , 使得 &lt;code&gt;a + b + c + d = 0&lt;/code&gt;，问有多少种选择方式。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3684 [Physics Experiment] 题解</title>
    <link href="http://dafenghh.github.io/post/d839a1f6.html"/>
    <id>http://dafenghh.github.io/post/d839a1f6.html</id>
    <published>2017-11-30T07:30:55.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>N个半径为R厘米的球竖直叠放在H米的高度上。实验开始时释放最下面的第一个球，1s后释放最下面的第二个球，1s后释放第三个球……一次类推。求T秒时每个球底端的高度。所有碰撞都是弹性碰撞， g取10 m/s^2</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这题的转化非常巧妙。</p><p>首先观察到很重要的一点，所有球的顺序在碰撞过程中都是不变的。很明显最下面一个球永远会在最下面，最上面一个球永远在最上面……这个很显然的结论将会给我们下面的转化过程带来帮助。</p><p>考虑两个球碰撞时的情形，根据物理知识，我们知道碰撞时的两个球的速度一定大小相同，方向相反。碰撞后交换速度。</p><p>这时候我们可以将两个球互相弹回的过程视作两个球“穿过了对方”而继续运动。在穿过的这个瞬间，球的速度没有变化，但下面的球高度获得2R的增量，上面的球高度获得-2R的增量。</p><p>然后，最关键的一步转化来了。</p><p>如果我们修改每个球的高度的定义，将每个球的高度h[i]定义为<code>实际高度-2*i*R</code> （球的坐标分别为0..N-1, 从下往上），这样会发生什么？</p><p>首先在初始时刻，所有的球的高度h[i]都是H。</p><p>然后我们再来看两个球碰撞的过程，碰撞时“穿过了对方”也就是“带着自己的速度到了对方的位置”。</p><p>这样想的话，我们就相当于交换了两个相邻的球的顺序，与一开始我们的结论“所有球的顺序一直不变有点矛盾”。</p><p>我们加多一层转化，就是将碰撞过程视作“带着自己的速度到了对方的位置，并变成了对方”。比如i和i+1碰撞，我们看作，i保持着自己的速度瞬间跳转i+1的位置，并变成了i+1；i+1同理。</p><p>i变成i+1的话，高度的定义也发生了改变，从<code>实际高度-2*i*R</code> 变成 <code>实际高度-2*(i+1)*R]</code>， 与实际高度的差值加多了一个2R, 另外这个过程里，i也会获得2R高度的增量，所以两部分抵消，h高度值完全没有变化。</p><p>这么一来，问题就变成，N个球相隔1s依次从高度H开始下落，求T秒后各球高度。另外我们要还原成实际高度，将高度排序后从下往上依次加上<code>2*i*R</code>即可.</p><p>就这样完美转化成一道简单物理题。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> g = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> h, <span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t0 = <span class="built_in">sqrt</span>(<span class="number">2</span> * h / g);</span><br><span class="line">    t -= <span class="number">2</span> * t0 * ((<span class="keyword">int</span>)(t / (<span class="number">2</span> * t0)));</span><br><span class="line">    <span class="keyword">if</span> (t &gt; t0) t = <span class="number">2</span> * t0 - t;</span><br><span class="line">    <span class="keyword">return</span> h - <span class="number">0.5</span> * g * t * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">double</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Test;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Test);</span><br><span class="line">    <span class="keyword">while</span> (Test--)&#123;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> H, R, T;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lf%lf%lf"</span>, &amp;N, &amp;H, &amp;R, &amp;T);</span><br><span class="line">        R /= <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            a[i] = H;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min((<span class="keyword">int</span>)T,N); i++) &#123;</span><br><span class="line">            a[i] = solve(a[i], T - i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf%c"</span>, a[i] + <span class="number">2</span> * i * R, (i == N - <span class="number">1</span> ? <span class="number">10</span>:<span class="number">32</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;N个半径为R厘米的球竖直叠放在H米的高度上。实验开始时释放最下面的第一个球，1s后释放最下面的第二个球，1s后释放第三个球……一次类推。求T秒时每个球底端的高度。所有碰撞都是弹性碰撞， g取10 m/s^2&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
      <category term="巧妙的转化" scheme="http://dafenghh.github.io/tags/%E5%B7%A7%E5%A6%99%E7%9A%84%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3279 [Fliptile] 题解</title>
    <link href="http://dafenghh.github.io/post/bdca6a8a.html"/>
    <id>http://dafenghh.github.io/post/bdca6a8a.html</id>
    <published>2017-11-29T14:39:42.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个游戏，M*N的方格，每个格子可以翻转正反面，一面白色，一面黑色。当翻转一个格子时，它的相邻格子都会被翻转。用最小的翻转次数使所有格子变成白色。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>考虑(1,1)这个格子，翻转(1,1) (1,2) (2,1)三个格子都能改变它的状态。<br>但当我们确定第一行的操作后，就只有翻转(2,1)能够改变(1,1)的状态。</p><p>所以，如果我们指定第一行的操作，就能根据(1,1)的状态来确定(2,1)是否需要翻转。同样的，也能确定余下所有方格是否需要翻转。最后确定一下最下一行是否全部变成白色即可。</p><p>所以这道题，就枚举第一行的所有操作即可。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn], flip[maxn][maxn], ans_flip[maxn][maxn], stat[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forij \</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)\</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    stat[x][y] = <span class="number">1</span> - stat[x][y];</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; <span class="number">4</span>; di++)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + d[di][<span class="number">0</span>], ny = y + d[di][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n) stat[nx][ny] = <span class="number">1</span> - stat[nx][ny];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    Forij <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        Forij stat[i][j] = a[i][j], flip[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> xi = <span class="number">0</span>; xi &lt; n; xi++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; xi)) &#123;</span><br><span class="line">                F(<span class="number">0</span>, xi);</span><br><span class="line">                flip[<span class="number">0</span>][xi] = <span class="number">1</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Forij</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == m - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (stat[i][j])&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stat[i][j])&#123;</span><br><span class="line">                    F(i + <span class="number">1</span>, j);</span><br><span class="line">                    flip[i + <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; (cnt &lt; ans)) &#123;</span><br><span class="line">            ans = cnt;</span><br><span class="line">            Forij ans_flip[i][j] = flip[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">1000</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"IMPOSSIBLE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Forij <span class="built_in">cout</span> &lt;&lt; ans_flip[i][j] &lt;&lt; (j == n - <span class="number">1</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;一个游戏，M*N的方格，每个格子可以翻转正反面，一面白色，一面黑色。当翻转一个格子时，它的相邻格子都会被翻转。用最小的翻转次数使所有格子变成白色。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="brute force" scheme="http://dafenghh.github.io/tags/brute-force/"/>
    
      <category term="位运算" scheme="http://dafenghh.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="反转" scheme="http://dafenghh.github.io/tags/%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 H [Hidden Supervisors] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/2cb42504.html"/>
    <id>http://dafenghh.github.io/post/2cb42504.html</id>
    <published>2017-11-29T14:38:43.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 H题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>给定若干棵树，其中一棵的根结点为1，现在把这所有的树合并成一棵根结点为1的树，并且要使这棵树中能够组成的(a,b)(a是b的父结点)的组数最大。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>先对每棵树做下DFS，用贪心的方式分好组。这棵树的根结点要么分好组，要么没分好。对所有不等于1的根结点，如果它已经分好组，就直接连到1上面；如果没分好组，就连到结点1的树未分组的一个结点上。对没分好组的根结点，用下贪心策略，对应的树的未分组结点越多的根结点越优先连接。</p><p>就这样简单的贪心策略，完成此题……想复杂了，并且细节上犯了弱智错误，debug很久。（根结点的分组居然写在了countUnmatchedNodesForAllTrees函数之前）。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[maxn], rt[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">bool</span> matched[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unmatched_nodes[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUnmatchedNodes</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = rt[v];</span><br><span class="line">    unmatched_nodes[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUnmatchedNodesToRoot</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: unmatched_nodes[v])&#123;</span><br><span class="line">        S.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//unmatched_nodes[v].clear();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    rt[v] = root;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: G[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Match(i, root))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!res)&#123;</span><br><span class="line">                matched[v] = <span class="literal">true</span>;</span><br><span class="line">                matched[i] = <span class="literal">true</span>;</span><br><span class="line">                res = <span class="literal">true</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countUnmatchedNodesForAllTrees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!matched[i]) &#123;</span><br><span class="line">            addUnmatchedNodes(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"hidden.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"hidden.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p + i);</span><br><span class="line">        G[p[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Match(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que0;</span><br><span class="line">    priority_queue&lt;P&gt; que1;<span class="comment">//que0: matched que1: unmatched</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: G[<span class="number">0</span>]) &#123;</span><br><span class="line">        Match(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    countUnmatchedNodesForAllTrees();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: G[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matched[i]) &#123;</span><br><span class="line">            que0.push(i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> que1.push(P(unmatched_nodes[i].size(),i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    addUnmatchedNodesToRoot(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!que0.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que0.front(); que0.pop();</span><br><span class="line">        p[u] = <span class="number">1</span>;</span><br><span class="line">        addUnmatchedNodesToRoot(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que1.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que1.top().second; que1.pop();</span><br><span class="line">        <span class="keyword">if</span> (!S.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> v = *S.begin();</span><br><span class="line">            p[u] = v;</span><br><span class="line">            cnt++;</span><br><span class="line">            addUnmatchedNodesToRoot(u);</span><br><span class="line">            S.erase(u);</span><br><span class="line">            S.erase(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p[u] = <span class="number">1</span>;</span><br><span class="line">            addUnmatchedNodesToRoot(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, p[i], (i == n?<span class="number">10</span>:<span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 H题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定若干棵树，其中一棵的根结点为1，现在把这所有的树合并成一棵根结点为1的树，并且要使这棵树中能够组成的(a,b)(a是b的父结点)的组数最大。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="greedy" scheme="http://dafenghh.github.io/tags/greedy/"/>
    
      <category term="trees" scheme="http://dafenghh.github.io/tags/trees/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 I [Intelligence in Perpendicularia] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/7ec55acf.html"/>
    <id>http://dafenghh.github.io/post/7ec55acf.html</id>
    <published>2017-11-29T14:38:10.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 I题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>给出一个多边形（只包含水平边和垂直边），求所有边中不能从外面看见的部分的长度。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>注意到能被外面看到的边经过平移后刚好能组成一个矩形，所以这题就简单了。先统计出周长，然后减去外接矩形的周长就得到答案了。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">cin</span><span class="params">(<span class="string">"intel.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">cout</span><span class="params">(<span class="string">"intel.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll x[maxn], y[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">abs_</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getL</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x[i] == x[j]) <span class="keyword">return</span> abs_(y[i] - y[j]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> abs_(x[i] - x[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ll len = <span class="number">0</span>;</span><br><span class="line">    ll minX, maxX, minY, maxY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">       len += getL(i , (i + <span class="number">1</span>) % n);</span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">0</span>) minX = maxX = x[i], minY = maxY = y[i];</span><br><span class="line">       <span class="keyword">else</span> minX = min(minX, x[i]), maxX = max(maxX, x[i]),</span><br><span class="line">            minY = min(minY, y[i]), maxY = max(maxY, y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// cout &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; maxX &lt;&lt; " " &lt;&lt; minX &lt;&lt; " " &lt;&lt; maxY &lt;&lt; " " &lt;&lt; minY &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; len - <span class="number">2</span> * (maxX - minX + maxY - minY) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 I题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给出一个多边形（只包含水平边和垂直边），求所有边中不能从外面看见的部分的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 K [Kotlin Island] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/f48dff26.html"/>
    <id>http://dafenghh.github.io/post/f48dff26.html</id>
    <published>2017-11-29T14:36:06.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 K题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>一个岛可以看成一个h*w的网格，现在可以在任意的行或者任意的类挖水渠，目标是将网格剩下没被挖水渠的点划分成k个连通块。给出一种方案即可。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>显然最后分成的连通块数目 = 行的分块数 * 列的分块数。比如有5行，那么我们最多可以分成3块。</p><p>枚举一遍就出答案了。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">bool</span> row[maxn], col[maxn];</span><br><span class="line"><span class="keyword">int</span> h, w, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"kotlin.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"kotlin.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;h, &amp;w, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hi = <span class="number">1</span>; hi &lt;= (h + <span class="number">1</span>) / <span class="number">2</span>; hi++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> wi = <span class="number">1</span>; wi &lt;= (w + <span class="number">1</span>) / <span class="number">2</span>; wi++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi * wi == n)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hi - <span class="number">1</span>; i++) row[<span class="number">1</span> + i * <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wi - <span class="number">1</span>; i++) col[<span class="number">1</span> + i * <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (row[i] || col[j]) <span class="built_in">printf</span>(<span class="string">"#"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 K题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个岛可以看成一个h*w的网格，现在可以在任意的行或者任意的类挖水渠，目标是将网格剩下没被挖水渠的点划分成k个连通块。给出一种方案即可。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="brute force" scheme="http://dafenghh.github.io/tags/brute-force/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 C [Consonant Fencity] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/9c682bc0.html"/>
    <id>http://dafenghh.github.io/post/9c682bc0.html</id>
    <published>2017-11-29T14:35:36.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 C题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>定义辅音字母为除了{a,e,i,o,u,w,y}之外的19个字母。<br>然后定义一个字符串的fencity为串中有多少对相邻的辅音字母，且它们一个大写一个小写。<br>给出一个只包含小写字母的字符串，现在你要指定19个辅音字母中的若干个字母，将字符串中的这些字母全部转换为大写。求fencity最大的串。</p><a id="more"></a> <h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>一共有19个字母要考虑。将这19个字母想象成图中的点。我们先扫一遍字符串，当遇到辅音字母相邻时，就将这两个辅音字母的边权+1.</p><p>然后这题就是说，往19个点染两种颜色（大写或者非大写），当一条边的两个端点颜色不一样时，这条边的边权生效。求边权和最大值。</p><p>由于对称性，我们可以固定一个点的颜色，然后只有18个点需要考虑，那么就是<code>2^18</code>中情况需要枚举。每个情况扫一遍所有的边，那么就是<code>2^18 * 19 * 18 / 2</code>的复杂度，大概为4500万，所以暴力方式能够解决此题。</p><p>P.S.有个小插曲，<code>(1 &lt;&lt; M[s[i]])) &gt; 0</code> 忘了加前面的括号，debug了好长时间。<br>下次打比赛时要先打印一份C/C++运算符优先级列表，然后将它压在台面上。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> fencity[(<span class="number">1</span> &lt;&lt; <span class="number">18</span>)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xn = (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; xn; x++) &#123;</span><br><span class="line"></span><br><span class="line">        fencity[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = (x &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            <span class="keyword">int</span> q = (x &amp; (<span class="number">1</span> &lt;&lt; j));</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">0</span> &amp;&amp; q &gt; <span class="number">0</span> || p &gt; <span class="number">0</span> &amp;&amp; q == <span class="number">0</span>)&#123;</span><br><span class="line">               </span><br><span class="line">                fencity[x] += w[i][j];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">char</span> voewls[] = <span class="string">"aeiouwy"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"consonant.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"consonant.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; S(voewls, voewls+ <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'b'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!S.count(ch)) M[ch] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (M.count(s[i]) &amp;&amp; M.count(s[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            w[M[s[i]]][M[s[i + <span class="number">1</span>]]]++;</span><br><span class="line">            w[M[s[i + <span class="number">1</span>]]][M[s[i]]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, xn = (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xn; x++) <span class="keyword">if</span> (fencity[ans] &lt; fencity[x]) ans = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!S.count(s[i]) &amp;&amp; ((ans &amp; (<span class="number">1</span> &lt;&lt; M[s[i]])) &gt; <span class="number">0</span>)) <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[i] + <span class="string">'A'</span> - <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 C题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定义辅音字母为除了{a,e,i,o,u,w,y}之外的19个字母。&lt;br&gt;然后定义一个字符串的fencity为串中有多少对相邻的辅音字母，且它们一个大写一个小写。&lt;br&gt;给出一个只包含小写字母的字符串，现在你要指定19个辅音字母中的若干个字母，将字符串中的这些字母全部转换为大写。求fencity最大的串。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="brute force" scheme="http://dafenghh.github.io/tags/brute-force/"/>
    
      <category term="位运算" scheme="http://dafenghh.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 E [Equal Numbers] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/79e97c8b.html"/>
    <id>http://dafenghh.github.io/post/79e97c8b.html</id>
    <published>2017-11-29T14:30:09.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 E题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>给定一个大小为n的正整数的数组，每次操作可以选取数组中一个数，将它乘上若干倍。求经过k次操作后，数组中最少有多少个不同的数？输出所有0&lt;=k&lt;=n的k的结果。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>样例输入是<code>n = 4, a[] = {1, 1, 2, 2, 3, 4}</code></p><p>我们先将相同的数合并成一堆，比如这里<code>a[]</code>可以看作<code>{1(2), 2(2), 3(1), 4(1)}</code></p><p>括号里的数表示这个数字的出现次数。</p><p>假定初始状态有<code>vn</code>堆数，这个样例里<code>vn = 4</code></p><p>题目要求的就是经过若干次操作后，最少剩下多少堆。</p><p>不妨换个思路，我们来求把<code>vn</code>堆数合并成<code>vn - k</code>堆至少需要多少次操作。如果能求出这个结果，我们将数组逆一下，并且空白处的值用前面的值填充好就得到题目要求的答案。</p><p>下面思考把<code>vn</code>堆数合并成<code>vn - k</code>堆， 也就是减少k堆，至少需要多少次操作。</p><p>我们把原来的数分成两类，一类是它的倍数也存在于数组中，另一类是它没有一个倍数存在与数组中，分别记为A类，B类。</p><p>样例中A类为： <code>1(2), 2(2)</code><br>样例中B类为： <code>3(1), 4(1)</code></p><p>为了减少k堆，我们有两种决策方法：</p><ol><li>直接在A类中选取大小最小的k堆，将这些数全部提升为它们的倍数。</li><li>在B类中选取大小最小的两堆，将这两堆数提升为所有数的最小公倍数，这时候减少了原有的2堆，但新增了1堆（所有数的最小公倍数），并且因为出现了所有数的最小公倍数，所以原有的所有数都变成A类，再按方法1选取(k-1)堆即可。</li></ol><p>两种方法分别求出来比较一下，取最优就得到答案了。</p><p>源代码中用x表示第一种决策方式需要的操作数，y表示第二种决策方式需要的操作数。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source_code"></a>source_code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000060</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[maxn], ops[maxn], ans[maxn], bucket[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v0, v1, v2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(bucket, <span class="number">0</span>, <span class="keyword">sizeof</span>(bucket));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) bucket[v[i]]++;</span><br><span class="line">    v.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket[i]; j++) </span><br><span class="line">        v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"equal.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"equal.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i])&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt; maxn; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[i * j]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) v0.push_back(cnt[i]);</span><br><span class="line">            <span class="keyword">else</span> v1.push_back(cnt[i]);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vn = v0.size() + v1.size();</span><br><span class="line">    bucket_sort(v0);</span><br><span class="line">    bucket_sort(v1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v0.size(); i++) v2.push_back(v0[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; v1.size(); i++) v2.push_back(v1[i]);</span><br><span class="line">    bucket_sort(v2);</span><br><span class="line"></span><br><span class="line">    ops[vn] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v1.size() &gt;= <span class="number">2</span>)   y+=v1[<span class="number">0</span>] + v1[<span class="number">1</span>]; <span class="keyword">else</span> y = <span class="number">2</span> * n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; vn; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= v0.size()) x += v0[k - <span class="number">1</span>]; <span class="keyword">else</span> x = <span class="number">2</span> * n;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">1</span>) y+=v2[k - <span class="number">2</span>];</span><br><span class="line">       <span class="comment">// printf("x = %d, y = %d, k = %d\n", x, y, k);</span></span><br><span class="line">        ops[vn - k] = min(x, y);           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vn; i++)&#123;</span><br><span class="line">        ans[ops[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">0</span>) ans[i] = ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], (i == n?<span class="number">10</span>:<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 E题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个大小为n的正整数的数组，每次操作可以选取数组中一个数，将它乘上若干倍。求经过k次操作后，数组中最少有多少个不同的数？输出所有0&amp;lt;=k&amp;lt;=n的k的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3484 [Showstopper] 题解</title>
    <link href="http://dafenghh.github.io/post/b9568341.html"/>
    <id>http://dafenghh.github.io/post/b9568341.html</id>
    <published>2017-11-28T14:44:04.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定若干等差数列，初项x，公差z，末项不大于y（均为正整数）。在所有数列有，有且仅有一个数的出现次数是奇数，求这个数以及它出现的次数。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>初看此题，真的毫无思路。虽然知道实在《挑战程序设计竞赛》的二分专题中，肯定使用二分算法，但怎么联系到二分上去呢？</p><p>有且只有一个奇数，这就是突破口。对解空间中的所有数，统计它们在数列中的出现次数，记为c[i]，然后对c[i]求个前缀和，那么在答案点x前，前缀和均为偶，答案点x及之后，前缀和均为奇。由此得到二分的单调性，得解。</p><p>有点小插曲，这道题的输入方式很麻烦……最讨厌按行输入了。WA几次后以为是输入有问题，其实是算法部分写错了细节。统计区间的数在数列的出现次数时，左端应该向上取整……</p><p>代码比较累赘，特别是统计的时候，可以写精简些。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tuple</span> &#123;</span></span><br><span class="line">    ll x, y, z;</span><br><span class="line">    Tuple(ll x = <span class="number">0</span>, ll y = <span class="number">0</span>, ll z = <span class="number">0</span>):x(x), y(y), z(z)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Tuple&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">count_</span><span class="params">(ll L, ll R, Tuple t)</span> </span>&#123; <span class="comment">//[L, R]</span></span><br><span class="line">    ll x = t.x, y = t.y, z = t.z;</span><br><span class="line">    <span class="keyword">if</span> (R &lt; x || L &gt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; x) L = x;</span><br><span class="line">    <span class="keyword">if</span> (R &gt; y) R = y;</span><br><span class="line">    ll res =  (R - x ) / z - (L - x) / z + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((L - x) % z) res--;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*printf("-------------\n");</span></span><br><span class="line"><span class="comment">    for (ll i = 0; i &lt; vec.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">        printf("%lld %lld %lld\n", vec[i].x, vec[i].y, vec[i].z);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf("-------------\n");*/</span></span><br><span class="line">    <span class="keyword">if</span> (vec.empty()) <span class="keyword">return</span>;</span><br><span class="line">    ll L = vec[<span class="number">0</span>].x, R = vec[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">        L = min(L, vec[i].x);</span><br><span class="line">        R = max(R, vec[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    L--;</span><br><span class="line"></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">        sum += count_(L, R, vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no corruption\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (L + <span class="number">1</span> &lt; R) &#123;</span><br><span class="line">        ll mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">           sum += count_(L, mid, vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) L = mid;</span><br><span class="line">        <span class="keyword">else</span> R = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">        sum += count_(R, R, vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = (ll)R;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d %I64d\n"</span>, ans, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(s, <span class="string">"%I64d %I64d %I64d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    vec.clear();</span><br><span class="line">    vec.push_back(Tuple(x, y, z));</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="keyword">while</span> (gets(s), *s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(s, <span class="string">"%I64d %I64d %I64d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        vec.push_back(Tuple(x, y, z));</span><br><span class="line">        <span class="built_in">memset</span>(s , <span class="number">0</span> , <span class="keyword">sizeof</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (gets(s)) work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给定若干等差数列，初项x，公差z，末项不大于y（均为正整数）。在所有数列有，有且仅有一个数的出现次数是奇数，求这个数以及它出现的次数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
      <category term="按行输入" scheme="http://dafenghh.github.io/tags/%E6%8C%89%E8%A1%8C%E8%BE%93%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3276 [Face The Right Way] 题解</title>
    <link href="http://dafenghh.github.io/post/49886522.html"/>
    <id>http://dafenghh.github.io/post/49886522.html</id>
    <published>2017-11-28T12:22:37.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>n头牛排成一行，有的牛面朝前，有的牛面朝后，每一次操作可以使连续的K头牛改变方向；求一个K，使得操作次数最少。输出K以及最少的操作次数。当有多个K满足条件时，输出最小的K。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>对一个区间来说，多次进行反转操作是没有意义的；另外反转的顺序对结果是没有影响的。所以这道题只需要对所有的可操作区间（即长度为K的区间）考虑是否需要反转。</p><p>考虑最左边的牛，当它面朝前时无需反转，当它面朝后时，就反转[1, K]区间一次。然后继续考虑第二头牛即可。</p><p>反转的时候不必每头牛都操作一次，只需用一个turns来记录当前区间的反转次数，考虑的下一头牛的状态就由它本身状态+turns的值来决定。随着区间往右移动，我们用区间左右更改的地方来更新turns即可。复杂度为<code>O(n ^ 2)</code></p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100243535</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], f[maxn], cnt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        a[i] = (s[<span class="number">0</span>] == <span class="string">'F'</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">int</span> turns = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> ((a[i] + turns) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + k &gt; n) &#123;</span><br><span class="line">                    cnt[k] = INF;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                f[i] = <span class="number">1</span>;</span><br><span class="line">                cnt[k]++;</span><br><span class="line">                turns++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) turns -= f[i - k + <span class="number">1</span>];</span><br><span class="line">           </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ansK = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n; k++) <span class="keyword">if</span> (cnt[k] &lt; cnt[ansK]) ansK = k;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ansK, cnt[ansK]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;n头牛排成一行，有的牛面朝前，有的牛面朝后，每一次操作可以使连续的K头牛改变方向；求一个K，使得操作次数最少。输出K以及最少的操作次数。当有多个K满足条件时，输出最小的K。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="反转" scheme="http://dafenghh.github.io/tags/%E5%8F%8D%E8%BD%AC/"/>
    
      <category term="区间处理" scheme="http://dafenghh.github.io/tags/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3320 [Jessica&#39;s Reading Problem] 题解</title>
    <link href="http://dafenghh.github.io/post/6f199fb1.html"/>
    <id>http://dafenghh.github.io/post/6f199fb1.html</id>
    <published>2017-11-28T04:51:03.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个大小为P的数组，取出一个子区间，要求这个子区间上的数能覆盖整个数组的数，求满足条件的子区间的最小长度。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>《挑战程序设计竞赛》P149例题，采用“尺取法”可以很快地做出这道题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/POJ3320_solution.jpg" alt="挑战程序设计竞赛" title="">                </div>                <div class="image-caption">挑战程序设计竞赛</div>            </figure><p>使用map来记录的时间复杂度为<code>O(P log P)</code>。</p><p>由于P最大为10e6，所以我提交的时候很担心超时。结果真的超时了，但并不是复杂度的锅，而是我用了cin cout，改成scanf printf就过了。</p><p>后来查了下，在windows下不开<code>ios::sync_with_stdio(false)</code>的优化时，cin比scanf慢差不多十倍;开了后，慢三倍。只有在linux下g++编译，并且写上这一句优化的情况下，cin才达到和scanf差不多的效率。</p><p>之后，将map改成hash，将时间复杂度降到线性，并且采用快速读入，这样才能47ms通过。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="solution-1-454ms"><a href="#solution-1-454ms" class="headerlink" title="solution 1 (454ms)"></a>solution 1 (454ms)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000100</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        S.insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sn = S.size();</span><br><span class="line">    S.clear();</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, cnt = <span class="number">0</span>, ans = n;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; n &amp;&amp; cnt &lt; sn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[a[t]] == <span class="number">0</span>) cnt++;</span><br><span class="line">            M[a[t]]++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; sn) <span class="keyword">break</span>;</span><br><span class="line">        ans = min(ans, t - s);</span><br><span class="line">        <span class="keyword">if</span> (M[a[s]] == <span class="number">1</span>) cnt--;</span><br><span class="line">        M[a[s]]--;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-47ms"><a href="#solution-2-47ms" class="headerlink" title="solution 2 (47ms)"></a>solution 2 (47ms)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000100</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> hash_n = <span class="number">535442</span>;</span><br><span class="line"><span class="keyword">int</span> M0[hash_n], M[hash_n];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=getchar() )</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">            f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=getchar() )</span><br><span class="line">        k=k*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = get();</span><br><span class="line">        a[i] %= hash_n;</span><br><span class="line">        M0[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash_n; i++) <span class="keyword">if</span> (M0[i]) sn++;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, cnt = <span class="number">0</span>, ans = n;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; n &amp;&amp; cnt &lt; sn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[a[t]] == <span class="number">0</span>) cnt++;</span><br><span class="line">            M[a[t]]++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; sn) <span class="keyword">break</span>;</span><br><span class="line">        ans = min(ans, t - s);</span><br><span class="line">        <span class="keyword">if</span> (M[a[s]] == <span class="number">1</span>) cnt--;</span><br><span class="line">        M[a[s]]--;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给定一个大小为P的数组，取出一个子区间，要求这个子区间上的数能覆盖整个数组的数，求满足条件的子区间的最小长度。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="尺取法" scheme="http://dafenghh.github.io/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
      <category term="hash" scheme="http://dafenghh.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1759 [Garland] 题解</title>
    <link href="http://dafenghh.github.io/post/68c8caf8.html"/>
    <id>http://dafenghh.github.io/post/68c8caf8.html</id>
    <published>2017-11-28T02:08:39.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个数列H[]，满足下面的关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">H[1] = A</span><br><span class="line">H[i] = (H[i-1] + H[i+1])/2 - 1, for all 1 &lt; i &lt; N </span><br><span class="line">H[N] = B </span><br><span class="line">H[i] &gt;= 0, for all 1 &lt;= i &lt;= N</span><br></pre></td></tr></table></figure></p><p>已知A，求B的最小值。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>化成递推式， 有<code>H[i+1] = 2 * H[i] - H[i-1] + 2</code></p><p>作下变形，有<code>H[i+1] - H[i] = H[i] - H[i-1] + 2</code> </p><p>所以H[i+1] - H[i]是一个等差数列，公差为2，那么：<code>H[i+1] - H[i] = H[2] - H[1] + 2 * (i - 1)</code> </p><p>做累加求和即得H[i]通项公式： <code>H[i] = (i - 1) * H[2] + (2 - i) * H[1] + (i - 1) * (i - 2)</code> </p><p>题目要求B，即<code>H[N] = (N - 1) * H[2] + (2 - N) * H[1] + (N - 1) * (N - 2)</code> </p><p>这个式子中，仅有H[2]为未知项，其他均已知。而且H[2]项前的系数N-1为正，H[N]与H[2]线性正相关，所以H[N]取最小值当且仅当H[2]取最小值。</p><p>于是我们将问题转化为求H[2]最小值即可。对H[2]进行二分，每次验证数列里的所有项是否全部大于零即可。</p><p>P.S. 交了几发WA，因为一不小心交了G++编译器，POJ的G++编译器有点老，浮点支持得不好。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source_code"></a>source_code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> A,B;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = A, b = mid,x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        x = <span class="number">2</span> * b - a + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = x;</span><br><span class="line">    &#125;</span><br><span class="line">    B = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;n, &amp;A);</span><br><span class="line">    <span class="keyword">double</span> L = <span class="number">-1</span>, R = <span class="number">1060</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (judge(mid)) R = mid;</span><br><span class="line">        <span class="keyword">else</span> L = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给定一个数列H[]，满足下面的关系：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;H[1] = A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H[i] = (H[i-1] + H[i+1])/2 - 1, for all 1 &amp;lt; i &amp;lt; N &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H[N] = B &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H[i] &amp;gt;= 0, for all 1 &amp;lt;= i &amp;lt;= N&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;已知A，求B的最小值。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 894E [Ralph and Mushrooms] #round 447 div2E 题解</title>
    <link href="http://dafenghh.github.io/post/2fde12e8.html"/>
    <id>http://dafenghh.github.io/post/2fde12e8.html</id>
    <published>2017-11-27T11:39:47.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个有向图，n个点，m条边，每条边初始有w[i]个蘑菇。有可能存在自环或重边。从点s出发，任意移动，当第一次经过一条边时，能采集w[i]个蘑菇；第二次经过这条边时，能采集w[i] - 1个蘑菇；第三次经过时，能采集w[i] - 1 - 2个；第四次则为w[i] - 1 - 2 - 3个，依次类推。当可采集蘑菇数变成0或负数后，仍能从这条边经过，但不会获得蘑菇。求能采集到的蘑菇的最大数量。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>经过强连通分量(scc)分解后，并缩成一个DAG。显然每个scc上，可以任意次数遍历这个scc包含的边，直至无蘑菇可采。然后scc之间的边，最多只能经过一次。<br>对那些可以无限遍历的边，我们先用二分求出总蘑菇数，然后汇总到所在的scc中。<br>最后应用DAG上的动态规划，算出从点s出发, 能采集到的最大蘑菇数。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source_code"></a>source_code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv= <span class="number">1000010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxv], rG[maxv], vs;</span><br><span class="line"><span class="keyword">bool</span> used[maxv];</span><br><span class="line"><span class="keyword">int</span> cmp[maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    G[from].push_back(to);</span><br><span class="line">    rG[to].push_back(from); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    used[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[G[v][i]]) dfs(G[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vs.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    used[v] = <span class="literal">true</span>;</span><br><span class="line">    cmp[v] = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rG[v].size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[rG[v][i]]) rdfs(rG[v][i], k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">    vs.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= V; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[v]) dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(used, <span class="number">0</span> , <span class="keyword">sizeof</span>(used));</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vs.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[vs[i]]) rdfs(vs[i], k++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sn = <span class="number">22000</span>;</span><br><span class="line">ll sum[sn], accSum[sn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sum[<span class="number">0</span>] = accSum[sn] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sn; i++) sum[i] = sum[i - <span class="number">1</span>] + i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sn; i++) accSum[i] = accSum[i - <span class="number">1</span>] + sum[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calWeight</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> k = upper_bound(sum, sum + sn, x) - sum - <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> (ll)(k+<span class="number">1</span>) * x - accSum[k]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">ll shrink_vertex_weight[maxv], dp[maxv];</span><br><span class="line"><span class="keyword">int</span> sV;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shrink_graph[maxv];</span><br><span class="line"><span class="built_in">map</span>&lt;P, ll&gt; shrink_edge_weight;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> from, to, weight;&#125;;</span><br><span class="line">edge edges[maxv];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[v] &gt; <span class="number">-1</span>) <span class="keyword">return</span> dp[v];</span><br><span class="line">    ll reward = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: shrink_graph[v]) &#123;</span><br><span class="line">        update(reward, shrink_edge_weight[P(v, i)] + f(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[v] = shrink_vertex_weight[v] + reward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init_sum();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    V = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, weight;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; weight;</span><br><span class="line">        add_edge(from, to);</span><br><span class="line">        edges[i] = edge&#123;from, to, weight&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; start;</span><br><span class="line">    sV = scc();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = edges[i].from, v2 = edges[i].to;</span><br><span class="line">        <span class="keyword">if</span> (cmp[v1] == cmp[v2]) &#123;</span><br><span class="line">            shrink_vertex_weight[cmp[v1]] += calWeight(edges[i].weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            update(shrink_edge_weight[P(cmp[v1], cmp[v2])], edges[i].weight);</span><br><span class="line">            shrink_graph[cmp[v1]].push_back(cmp[v2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(cmp[start]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;一个有向图，n个点，m条边，每条边初始有w[i]个蘑菇。有可能存在自环或重边。从点s出发，任意移动，当第一次经过一条边时，能采集w[i]个蘑菇；第二次经过这条边时，能采集w[i] - 1个蘑菇；第三次经过时，能采集w[i] - 1 - 2个；第四次则为w[i] - 1 - 2 - 3个，依次类推。当可采集蘑菇数变成0或负数后，仍能从这条边经过，但不会获得蘑菇。求能采集到的蘑菇的最大数量。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="dp" scheme="http://dafenghh.github.io/tags/dp/"/>
    
      <category term="graphs" scheme="http://dafenghh.github.io/tags/graphs/"/>
    
      <category term="scc" scheme="http://dafenghh.github.io/tags/scc/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3061 [Subsequence] 题解</title>
    <link href="http://dafenghh.github.io/post/acca6816.html"/>
    <id>http://dafenghh.github.io/post/acca6816.html</id>
    <published>2017-11-27T07:43:53.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长度为N的数列，以及整数S。求出和不小于S的连续子序列的长度的最小值。如果解不存在，则输出0.</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>先求前缀和，然后就能用O(1)的时间, 求出一个区间的和。</p><p>之后用二分就能解决这道题。</p><p>但《挑战程序设计竞赛》(P146)中提供了一种更高效和简单的解法，叫“尺取法”。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1"></a>solution 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], sum[maxn];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum[i + len] - sum[i] &gt;= S) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">       sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum[i + <span class="number">1</span>] = sum[i] + a[i];</span><br><span class="line">       <span class="keyword">if</span> (sum[N] &lt; S) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">int</span> L = <span class="number">0</span>, R = N;</span><br><span class="line">       <span class="keyword">while</span> (L + <span class="number">1</span> &lt; R) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (judge(mid)) R = mid;</span><br><span class="line">           <span class="keyword">else</span> L = mid;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; R &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2"></a>solution 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll S;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">       <span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">       ll sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> ans = N + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">while</span> (t &lt; N &amp;&amp; sum &lt; S) sum += a[t++];</span><br><span class="line">           <span class="keyword">if</span> (sum &lt; S) <span class="keyword">break</span>;</span><br><span class="line">           ans = min(ans, t - s);</span><br><span class="line">           sum -= a[s++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (ans &gt; N) ans = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给定一个长度为N的数列，以及整数S。求出和不小于S的连续子序列的长度的最小值。如果解不存在，则输出0.&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
      <category term="尺取法" scheme="http://dafenghh.github.io/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1064 [Cable master] 题解</title>
    <link href="http://dafenghh.github.io/post/52b6f961.html"/>
    <id>http://dafenghh.github.io/post/52b6f961.html</id>
    <published>2017-11-27T07:13:40.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>N条绳子，长度分别为Li，从它们之中切割出K条长度相同的绳子，求这K条绳子每条最长的长度，答案保留至小数点后二位。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>二分搜索的经典应用，“假定一个解并判断是否可行”。现在我们假定要切割出长度为x的绳子，然后判断能否切割成K条即可。</p><p>这道题卡在最后输出答案上了，不能四舍五入，一定要向下取。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">12000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">double</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        cnt += a[i] / k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &gt;= K;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, a + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> L = <span class="number">0.0001</span>, R = <span class="number">110000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (judge(mid)) L = mid;</span><br><span class="line">        <span class="keyword">else</span> R = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, <span class="built_in">floor</span>(L * <span class="number">100</span>) / <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;N条绳子，长度分别为Li，从它们之中切割出K条长度相同的绳子，求这K条绳子每条最长的长度，答案保留至小数点后二位。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3662 [Telephone Lines] 题解</title>
    <link href="http://dafenghh.github.io/post/e84ff597.html"/>
    <id>http://dafenghh.github.io/post/e84ff597.html</id>
    <published>2017-11-27T06:21:30.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个无向图，N的点，P条边，给出每条边的长度，定义一条路径的代价为省略路径上的K条边后剩余边的边长最大值。求点1到点N代价最小的路径的代价。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>“最小化最大值”的题目，考虑二分。<br>二分时，设当前设定代价为k，然后考虑在代价为k的约束下能否找到一条可行路径。在寻找路径时，碰到一条边长大于k的边，那么连上这条边需要省略它。显然，一条可行路径就是指路径上所有被省略的边数量不超过K。</p><p>那么就可以转化一下，边长大于k的边权值为1，边长小于等于k的边权值为0.然后用dijkstra计算1到n的最短路，如果答案不大于K，说明被省略的边数量不超过K.</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">20344</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">1500</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cost;</span><br><span class="line">    edge(<span class="keyword">int</span> to, <span class="keyword">int</span> cost):to(to),cost(cost)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> d[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class="line">    fill(d + <span class="number">1</span>, d + V + <span class="number">1</span>, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    que.push(P(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        P p = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">int</span> v = p.second;</span><br><span class="line">        <span class="keyword">if</span> (d[v] &lt; p.first) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span> (d[e.to] &gt; d[v] + (e.cost &gt; k ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">                d[e.to] = d[v] + (e.cost &gt; k ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                que.push(P(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> N, P, K;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; P &gt;&gt; K;</span><br><span class="line">    V = N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, cost;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; cost;</span><br><span class="line">        G[from].push_back(edge(to, cost));</span><br><span class="line">        G[to].push_back(edge(from, cost));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">-1</span>, R = <span class="number">1000010</span>;</span><br><span class="line">    <span class="keyword">if</span> (dijkstra(<span class="number">1</span>, N, R) == INF) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (L + <span class="number">1</span> &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dijkstra(<span class="number">1</span>, N, mid) &lt;= K) R = mid;</span><br><span class="line">        <span class="keyword">else</span> L = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; R &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;一个无向图，N的点，P条边，给出每条边的长度，定义一条路径的代价为省略路径上的K条边后剩余边的边长最大值。求点1到点N代价最小的路径的代价。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
      <category term="graphs" scheme="http://dafenghh.github.io/tags/graphs/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 894D [Ralph And His Tour in Binary Country] round 447 div2D 题解</title>
    <link href="http://dafenghh.github.io/post/2d71363f.html"/>
    <id>http://dafenghh.github.io/post/2d71363f.html</id>
    <published>2017-11-26T01:56:29.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一棵结点数为n的完全二叉树以及所有边的长度，m次查询，每次查询输入两个正整数A和H，A为起始点，任选树上一个结点（可以选择A本身）作为终点来构成一段旅程，定义这段旅程的快乐值为H-起点到终点的路径长度。求所有快乐值为正的旅程的快乐值的和。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>完全二叉树的性质在这道题要好好利用一下。因为是完全二叉树，所以树的高度为O(log n)级别。这样，我们对每一个结点，建一个数组（vector），记录从这个结点出发往它的子树上所有结点的路径长度，并且排好序。</p><p>因为一个结点最多在O(log n)个数组中出现，所以这些数组的总空间为O(n log n).另外每一个结点的数组显然可以由0（到自己的长度）+左儿子数组+右儿子数组 merge而来，那么每次合并使用归并排序，时间复杂度也是O(n log n)</p><p>做好这一步预处理后，我们怎么回答每一次询问呢？其实已经很简单了。对结点A，先统计A的子树上的路径，然后A的父节点上移动，统计A的兄弟子树上的路径；接着不断往上移动，直到根节点即可。因为树高为O(log n), 然后每一次统计时采用二分，所以每次查询的复杂度为O(log^2 n)</p><p>总复杂度为O(n<em>log n + m</em>log^2 n)<br>实现起来还是比较容易的。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> L[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; dist[maxn], accDist[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calDist</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i &lt;= n &amp;&amp; <span class="number">2</span> * i + <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">        calDist(<span class="number">2</span> * i);</span><br><span class="line">        calDist(<span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">        dist[i].push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; dist[<span class="number">2</span> * i].size(); di++) &#123;</span><br><span class="line">            dist[i].push_back(dist[<span class="number">2</span> * i][di] + L[<span class="number">2</span> * i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; dist[<span class="number">2</span> * i + <span class="number">1</span>].size(); di++) &#123;</span><br><span class="line">            dist[i].push_back(dist[<span class="number">2</span> * i + <span class="number">1</span>][di] + L[<span class="number">2</span> * i]);</span><br><span class="line">        &#125;</span><br><span class="line">        inplace_merge(dist[i].begin() + <span class="number">1</span>, dist[i].begin() + <span class="number">1</span> + dist[<span class="number">2</span> * i].size(), dist[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> * i &lt;= n &amp;&amp; <span class="number">2</span> * i + <span class="number">1</span> &gt; n) &#123;</span><br><span class="line">        calDist(<span class="number">2</span> * i);</span><br><span class="line">        dist[i].push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; dist[<span class="number">2</span> * i].size(); di++) &#123;</span><br><span class="line">            dist[i].push_back(dist[<span class="number">2</span> * i][di] + L[<span class="number">2</span> * i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dist[i].push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll acc_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; dist[i].size(); di++)&#123;</span><br><span class="line">        accDist[i].push_back((acc_ += dist[i][di]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">forSubtree</span><span class="params">(<span class="keyword">int</span> v, ll H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (H &lt; <span class="number">0</span> || v &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = upper_bound(dist[v].begin(), dist[v].end(), H) - dist[v].begin();</span><br><span class="line">    <span class="keyword">return</span> H * pos - accDist[v][pos - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">forPar</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> p, ll H)</span> </span>&#123; <span class="comment">// calculate happiness</span></span><br><span class="line">    <span class="keyword">int</span> v_ = (v == <span class="number">2</span> * p ? <span class="number">2</span> * p + <span class="number">1</span> : <span class="number">2</span> * p);</span><br><span class="line">    <span class="keyword">return</span> forSubtree(v_, H - L[v_ - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; L[i];</span><br><span class="line">    calDist(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mi = <span class="number">0</span>; mi &lt; m; mi++) &#123;</span><br><span class="line">        <span class="keyword">int</span> A, H;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; H;</span><br><span class="line">        ll ans = forSubtree(A, H);</span><br><span class="line">        <span class="keyword">while</span> (A &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            H -= L[A - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (H &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            ans += H;</span><br><span class="line">            ans += forPar(A, A / <span class="number">2</span>, H);</span><br><span class="line">            A /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给出一棵结点数为n的完全二叉树以及所有边的长度，m次查询，每次查询输入两个正整数A和H，A为起始点，任选树上一个结点（可以选择A本身）作为终点来构成一段旅程，定义这段旅程的快乐值为H-起点到终点的路径长度。求所有快乐值为正的旅程的快乐值的和。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="trees" scheme="http://dafenghh.github.io/tags/trees/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 894C [Marco and GCD Sequence] #round 447 div2C 题解</title>
    <link href="http://dafenghh.github.io/post/d93115b9.html"/>
    <id>http://dafenghh.github.io/post/d93115b9.html</id>
    <published>2017-11-25T14:04:20.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>将输入的数组求一次gcd, 设求出来的值为s，然后判断s是否在原来的数组中。如果不在，那么无解；否则可以构造出一组解，往输入数组的每两个相邻的数中插入一个s，然后就得到一组解。</p><a id="more"></a><p>简单证明这组解是正确的：</p><p>设输入数组为a[]，依照上面的方式构造出来的数组为b[]，下面证明：b数组中任意一个区间的gcd值恰好构成集合a。</p><p>若i==j，即区间长度为1，那么gcd(b[i]) = b[i]， 而b[i]构成的集合与集合a等价，即表明a[]中的值都是b数组一个区间的gcd值；<br>若i!=j，那么gcd(b[i..j]) = s, s属于集合a。<br>以上两点说明b[]就是答案。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>?a:gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        S.insert(a[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> g = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) g = gcd(g, a[i]);</span><br><span class="line">    <span class="keyword">if</span> (S.count(g))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>, <span class="number">2</span> * m - <span class="number">1</span>, a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">1</span>; i &lt; m; i++) <span class="built_in">printf</span>(<span class="string">" %d %d"</span>, g, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;将输入的数组求一次gcd, 设求出来的值为s，然后判断s是否在原来的数组中。如果不在，那么无解；否则可以构造出一组解，往输入数组的每两个相邻的数中插入一个s，然后就得到一组解。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="constructive algorithms" scheme="http://dafenghh.github.io/tags/constructive-algorithms/"/>
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>ACM训练计划</title>
    <link href="http://dafenghh.github.io/post/3c0e0710.html"/>
    <id>http://dafenghh.github.io/post/3c0e0710.html</id>
    <published>2017-11-24T12:49:10.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>从2017年11月25日开始，每天3题的日常任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从2017年11月25日开始，每天3题的日常任务。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
