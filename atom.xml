<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dafenghh&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/a7b4d3cfc66b429f7c4de28226cdb1a4</icon>
  <subtitle>To Be Top Coder</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dafenghh.github.io/"/>
  <updated>2018-05-09T13:47:08.000Z</updated>
  <id>http://dafenghh.github.io/</id>
  
  <author>
    <name>Dafenghh</name>
    <email>xudafeng88@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeChef - SCIENCEF Science Fair 题解</title>
    <link href="http://dafenghh.github.io/post/a5930d20.html"/>
    <id>http://dafenghh.github.io/post/a5930d20.html</id>
    <published>2018-05-09T13:43:01.000Z</published>
    <updated>2018-05-09T13:47:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。</p><p>大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下：</p><p> cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）)</p><p> 司机会选择一条使cost最小的路线行驶。问cost的期望。</p><a id="more"></a><h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>扩展版旅行商问题。<br>关键是先重构图。压缩至只有S，F跟学生所在点。而这些点间的边权应该定义为原图中不经过别的学生的最短路长度。用$n^2$次dijkstra重构图完成后，就是一个旅行商问题了。之后状态压缩DP解决。</p><p><code>dp1[x][i]</code>表示当前走到第i个点，访问过的点集为x的最小cost。<br><code>dp2[x]</code>表示访问学生集合为x以及x的超集的最小cost。这就是最终答案了。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll Mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll&amp; <span class="title">Add</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a = sum(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">product</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll&amp; <span class="title">Mul</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a = product(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ll iv = <span class="number">570000004L</span>L;</span><br><span class="line"></span><br><span class="line">ll talkative[<span class="number">1</span> &lt;&lt; <span class="number">17</span>], ti[<span class="number">17</span>], pi[<span class="number">20</span>], mi[<span class="number">17</span>];</span><br><span class="line"><span class="keyword">int</span> V, E, S, F, n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1020</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">253432145421354L</span>L;</span><br><span class="line">ll sp[<span class="number">20</span>][<span class="number">20</span>], d[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    ll cost;</span><br><span class="line">    edge(<span class="keyword">int</span> to = <span class="number">0</span>, ll cost = <span class="number">0</span>):to(to), cost(cost)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> studentOnVertex[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mini</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, P&gt; Tuple;</span><br><span class="line">ll dp[<span class="number">1</span>&lt;&lt;<span class="number">17</span>][<span class="number">20</span>], dp2[<span class="number">1</span>&lt;&lt;<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;V, &amp;E, &amp;S, &amp;F, &amp;n);</span><br><span class="line">    S--, F--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, pi + i, ti + i, mi + i);</span><br><span class="line">        pi[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        --x,--y;</span><br><span class="line">        G[x].push_back(edge(y, w));</span><br><span class="line">        G[y].push_back(edge(x, w));</span><br><span class="line">    &#125;</span><br><span class="line">    talkative[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">                talkative[x|(<span class="number">1</span>&lt;&lt;i)] = product(talkative[x], ti[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(studentOnVertex, <span class="number">-1</span>, <span class="keyword">sizeof</span> studentOnVertex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        studentOnVertex[pi[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    pi[n] = S;</span><br><span class="line">    pi[n + <span class="number">1</span>] = F;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= n + <span class="number">1</span>; s++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = s + <span class="number">1</span>; t &lt;= n + <span class="number">1</span>; t++) &#123;</span><br><span class="line">        fill(d, d + V, INF);</span><br><span class="line">        d[pi[s]] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class="line">        que.push(P(<span class="number">0</span>, pi[s]));</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            P p = que.top(); que.pop();</span><br><span class="line">            <span class="keyword">int</span> v = p.second;</span><br><span class="line">            <span class="keyword">if</span> (p.first &gt; d[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> e: G[v]) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = e.to;</span><br><span class="line">                ll cost = e.cost;</span><br><span class="line">                <span class="keyword">int</span> stui = studentOnVertex[u];</span><br><span class="line">                <span class="keyword">if</span> (stui != <span class="number">-1</span> &amp;&amp; stui != s &amp;&amp; stui != t) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (d[u] &gt; d[v] + cost) &#123;</span><br><span class="line">                    d[u] = d[v] + cost;</span><br><span class="line">                    que.push(P(d[u], u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sp[s][t] = sp[t][s] = d[pi[t]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[x][i] = INF;</span><br><span class="line">        </span><br><span class="line">    dp[<span class="number">0</span>][n] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Tuple, <span class="built_in">vector</span>&lt;Tuple&gt;, greater&lt;Tuple&gt; &gt; que;</span><br><span class="line">    que.push(Tuple(<span class="number">0</span>, P(<span class="number">0</span>,n)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        Tuple tup = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">int</span> x = tup.second.first, i = tup.second.second;</span><br><span class="line">        <span class="keyword">if</span> (tup.first &gt; dp[x][i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> nx = x | (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">if</span> (dp[nx][j] &gt; dp[x][i] + sp[i][j]) &#123;</span><br><span class="line">                dp[nx][j] = dp[x][i] + sp[i][j];</span><br><span class="line">                que.push(Tuple(dp[nx][j], P(nx,j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++) &#123;</span><br><span class="line">        dp2[x] = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i))  Mini(dp2[x], dp[x][i] + sp[i][n+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp2[x] += talkative[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; x &gt; <span class="number">0</span>; x--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            Mini(dp2[x], dp2[x|(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++) &#123;</span><br><span class="line">        ll temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                Mul(temp, mi[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Mul(temp, <span class="number">100</span> - mi[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Mul(temp, iv);</span><br><span class="line">        &#125;</span><br><span class="line">        Mul(temp, dp2[x]);</span><br><span class="line">        Add(ans, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。&lt;/p&gt;
&lt;p&gt;大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下：&lt;/p&gt;
&lt;p&gt; cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）)&lt;/p&gt;
&lt;p&gt; 司机会选择一条使cost最小的路线行驶。问cost的期望。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="DP" scheme="http://dafenghh.github.io/tags/DP/"/>
    
      <category term="shortest path" scheme="http://dafenghh.github.io/tags/shortest-path/"/>
    
      <category term="graph" scheme="http://dafenghh.github.io/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef - GENPERM Generating A Permutation 题解</title>
    <link href="http://dafenghh.github.io/post/75299267.html"/>
    <id>http://dafenghh.github.io/post/75299267.html</id>
    <published>2018-05-09T13:15:57.000Z</published>
    <updated>2018-05-09T13:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, p3) + … + max(pN-1, pN)</p><p>给出N，K。构造排列P， 使f(P) = K. 如果不存在，就输出-1.</p><h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>f(P)的值是N-1个数的和。而原排列中的数，最多贡献两次答案。</p><p>考虑排列是正序时，f(P)取到最小值，为2+3+…+N。也即2到N的数，每个数贡献1次。<br>最大值应该是在最大的那些数都贡献2次时取到。</p><p>怎么让最大那个数贡献2次？只需要不把它放两端就可以了。</p><p>另外注意到，一个大的数a多贡献一次的同时，就会剥夺另外一个较小的数b的贡献机会，这时候就会使答案增加a-b.</p><p>所以这道题的构造方法就是，设a为下一个贡献多一次的数，b为下一个被剥夺贡献机会的数。考虑当前的和，如果加上b-a比答案大，我们就让b大一些，直到满足条件。然后把刚刚考虑过的b依次append到答案数组，再append a就行。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll k;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) x += i;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; x) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + r - l - <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">                x += r - l - <span class="number">1</span>;</span><br><span class="line">                vec.push_back(l++);</span><br><span class="line">                vec.push_back(r--);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                vec.push_back(l++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) vec.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (x != k || vec.size() != n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, vec[i], <span class="string">" \n"</span>[i==n<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, 
      
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="constructive algorithms" scheme="http://dafenghh.github.io/tags/constructive-algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://dafenghh.github.io/post/4a17b156.html"/>
    <id>http://dafenghh.github.io/post/4a17b156.html</id>
    <published>2018-05-02T06:38:13.860Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Educational Codeforces Round 43 Summary</title>
    <link href="http://dafenghh.github.io/post/af1c4a82.html"/>
    <id>http://dafenghh.github.io/post/af1c4a82.html</id>
    <published>2018-05-01T01:57:28.000Z</published>
    <updated>2018-05-09T13:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>比赛中仅仅做出3道水题。</p><p>卡E。E一直想不出。曾有猜测“所有1st type spells全部用于一个creature”，但无法证明，也不敢下定论。没想到这就是正解。</p><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="E-Well-played"><a href="#E-Well-played" class="headerlink" title="E. Well played!"></a>E. Well played!</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有n个物品，每个物品有两个值hp和dmg. 现有a个第一类道具和b个第二类道具。第一类道具可以使某个物品的hp翻倍，第二类道具可以将某个物品的hp赋值给dmg.</p><p>问使用了这些道具后，所有物品dmg和的最大值。</p><p>数据范围: $1\leq n\leq2\cdot10^5,0\leq b\leq2\cdot10^5,0\leq a\leq 20$</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>下面先证明，最优解一定是全部第一类道具用于同一个物品。分别用x和y表示物品的hp和dmg.</p><p>那么如果两个物品同时用了第一类道具，分别用了$a_1$和$a_2$个，它们的总dmg就是$d_1 = {x_1}2^{a_1}+{x_2}2^{a_2}$.</p><p>如果将第一类道具全部用于第1个物品，总dmg为$d_2={x_1}2^{a_1+a_2}+\max(x_2, y_2)$</p><p>假设d1更优，则有$${x_1}2^{a_1}+{x_2}2^{a_2} &gt; {x_1}2^{a_1+a_2}+\max(x_2, y_2)$$</p><p>移项，有$${x_1}2^{a_1}(2^{a_2}-1) &lt; {x_2}2^{a_2} - \max(x_2, y_2)$$</p><p>考虑到$\max(x_2, y_2) \geq x_2$,则有$${x_1}2^{a_1}(2^{a_2}-1) &lt; {x_2}(2^{a_2}-1)$$</p><p>即$${x_1}2^{a_1}&lt; {x_2}$$</p><p>同理，为了让$d_1$比第一类道具全部用于第2个物品的情况更优，有<br>$${x_2}2^{a_2}&lt; {x_1}$$</p><p>两个不等式矛盾，证毕。</p><p>这样一来，就可以O(n)枚举每个物品使用第一类道具的情况。</p><h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    ll h, d;</span><br><span class="line">    <span class="keyword">bool</span> used;</span><br><span class="line">    P(ll h = <span class="number">0</span>, ll d = <span class="number">0</span>): h(h), d(d), used(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> P &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> h - d &gt; b.h - b.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maxi</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, A, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;A, &amp;b);</span><br><span class="line">    ll k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; i++) k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> h,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;h, &amp;d);</span><br><span class="line">        a[i] = P(h, d);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    ll tot = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].h &gt; a[i].d &amp;&amp; cnt &lt; b) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                tot += a[i].h;</span><br><span class="line">                a[i].used = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tot += a[i].d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ll h = a[i].h * k;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= a[i].d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i].used) &#123;</span><br><span class="line">            Maxi(ans, tot - a[i].h + h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ll temp = tot - a[i].d + h;</span><br><span class="line">            <span class="keyword">if</span> (cnt == b) &#123;</span><br><span class="line">                temp = temp - a[b - <span class="number">1</span>].h + a[b - <span class="number">1</span>].d;</span><br><span class="line">            &#125;</span><br><span class="line">            Maxi(ans, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;&lt;p&gt;比赛中仅仅做出3道水题。&lt;/p&gt;
&lt;p&gt;卡E。E一直想不出。曾有猜测“所有1st type spel
      
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="summary" scheme="http://dafenghh.github.io/tags/summary/"/>
    
      <category term="codeforces" scheme="http://dafenghh.github.io/tags/codeforces/"/>
    
      <category term="greedy" scheme="http://dafenghh.github.io/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>2018.04.22 Kharagpur Regional 2017 集训总结</title>
    <link href="http://dafenghh.github.io/post/9ffddd26.html"/>
    <id>http://dafenghh.github.io/post/9ffddd26.html</id>
    <published>2018-04-29T12:13:01.000Z</published>
    <updated>2018-05-09T13:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>赛中通过3题，FDK.  F是暴力水题，D和K一共7记罚时，做得不好。D的错误是考虑错了复杂度，所以超时，加上输出%lld写成%d（经典错误）。K的错误是思考不谨慎，连边时加了一个多余的判断条件。</p><p>赛后没把H想出来。已经想得差不多，不过看错数据范围。一直以为要O(n^2)算法，其实是O(n^3). 要是看仔细点说不定就能想出来。（经典DP套路，请把训练指南的DP章节刷一遍，锻炼思维！）</p><p>赛后补了AHJ。还差EIB。加油，补完！</p><ul><li style="list-style: none"><input type="checkbox" checked> A</li><li style="list-style: none"><input type="checkbox" checked> J</li><li style="list-style: none"><input type="checkbox"> B</li><li style="list-style: none"><input type="checkbox"> E</li><li style="list-style: none"><input type="checkbox"> I</li></ul><a id="more"></a><h2 id="A-Science-Fair"><a href="#A-Science-Fair" class="headerlink" title="A Science Fair"></a>A Science Fair</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有N个学生，住在不同的地方。现在学校要选学生去参加科技节活动。每个学生被选去的概率的百分数等于他们的百分制成绩。</p><p>大巴在S处出发，先去接送学校选去的学生，然后开到终点F。由于学生太过活跃，当大巴经过了他们家时，他们就算没被学校选中也会强行上车。每个学生有一个talkativeness，一次旅途的talkativeness等于所有上了车的学生的talkativeness的乘积。一次旅途的cost定义如下：</p><p> cost(Trip) = Length(Trip) + (Talkativeness(Trip) % (1e9+7）)</p><p> 司机会选择一条使cost最小的路线行驶。问cost的期望。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>扩展版旅行商问题。<br>关键是先重构图。压缩至只有S，F跟学生所在点。而这些点间的边权应该定义为原图中不经过别的学生的最短路长度。用$n^2$次dijkstra重构图完成后，就是一个旅行商问题了。之后状态压缩DP解决。</p><p><code>dp1[x][i]</code>表示当前走到第i个点，访问过的点集为x的最小cost。<br><code>dp2[x]</code>表示访问学生集合为x以及x的超集的最小cost。这就是最终答案了。</p><p>见<a href="a5930d20.html">Science Fair题解</a></p><h2 id="B-Black-Discs"><a href="#B-Black-Discs" class="headerlink" title="B Black Discs"></a>B Black Discs</h2><h2 id="C-Uniform-Strings"><a href="#C-Uniform-Strings" class="headerlink" title="C Uniform Strings"></a>C Uniform Strings</h2><h2 id="D-SAD-Queries"><a href="#D-SAD-Queries" class="headerlink" title="D SAD Queries"></a>D SAD Queries</h2><h2 id="E-Chef-and-XOR-Queries"><a href="#E-Chef-and-XOR-Queries" class="headerlink" title="E Chef and XOR Queries"></a>E Chef and XOR Queries</h2><h2 id="F-Taxi-Making-Sharp-Turns"><a href="#F-Taxi-Making-Sharp-Turns" class="headerlink" title="F Taxi Making Sharp Turns"></a>F Taxi Making Sharp Turns</h2><h2 id="G-Spam-Classification-Using-Neural-Net"><a href="#G-Spam-Classification-Using-Neural-Net" class="headerlink" title="G Spam Classification Using Neural Net"></a>G Spam Classification Using Neural Net</h2><h2 id="H-Non-Overlapping-Segments"><a href="#H-Non-Overlapping-Segments" class="headerlink" title="H Non Overlapping Segments"></a>H Non Overlapping Segments</h2><h2 id="I-Spanning-Tree"><a href="#I-Spanning-Tree" class="headerlink" title="I Spanning Tree"></a>I Spanning Tree</h2><h2 id="J-Generating-A-Permutation"><a href="#J-Generating-A-Permutation" class="headerlink" title="J Generating A Permutation"></a>J Generating A Permutation</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>对一个排列P，[p1, p2, …, pN-1, pN], 定义 f(P) = max(p1, p2) + max(p2, p3) + … + max(pN-1, pN)</p><p>给出N，K。构造排列P， 使f(P) = K. 如果不存在，就输出-1.</p><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h3><p>f(P)的值是N-1个数的和。而原排列中的数，最多贡献两次答案。</p><p>考虑排列是正序时，f(P)取到最小值，为2+3+…+N。也即2到N的数，每个数贡献1次。<br>最大值应该是在最大的那些数都贡献2次时取到。</p><p>怎么让最大那个数贡献2次？只需要不把它放两端就可以了。</p><p>另外注意到，一个大的数a多贡献一次的同时，就会剥夺另外一个较小的数b的贡献机会，这时候就会使答案增加a-b.</p><p>所以这道题的构造方法就是，设a为下一个贡献多一次的数，b为下一个被剥夺贡献机会的数。考虑当前的和，如果加上b-a比答案大，我们就让b大一些，直到满足条件。然后把刚刚考虑过的b依次append到答案数组，再append a就行。</p><p>见<a href="75299267.html">Generating A Permutation题解</a></p><h2 id="K-Number-Game"><a href="#K-Number-Game" class="headerlink" title="K Number Game"></a>K Number Game</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;&lt;p&gt;赛中通过3题，FDK.  F是暴力水题，D和K一共7记罚时，做得不好。D的错误是考虑错了复杂度，所以超时，加上输出%lld写成%d（经典错误）。K的错误是思考不谨慎，连边时加了一个多余的判断条件。&lt;/p&gt;
&lt;p&gt;赛后没把H想出来。已经想得差不多，不过看错数据范围。一直以为要O(n^2)算法，其实是O(n^3). 要是看仔细点说不定就能想出来。（经典DP套路，请把训练指南的DP章节刷一遍，锻炼思维！）&lt;/p&gt;
&lt;p&gt;赛后补了AHJ。还差EIB。加油，补完！&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; A&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; J&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; B&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; E&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; I&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="Summary" scheme="http://dafenghh.github.io/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101635C [Macarons] 2017-2018 ACM-ICPC, Southwestern European Regional Programming Contest (SWERC 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/9049154c.html"/>
    <id>http://dafenghh.github.io/post/9049154c.html</id>
    <published>2018-01-26T07:22:09.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>用<code>1*1</code>或者<code>1*2</code>的小长方形完整覆盖N*M的长方形（不可重叠），问有多少种覆盖方式？</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>行数很少，<code>N &lt;= 8</code>, 列数很多，<code>M &lt;= 10^18</code></p><p>对于每一列，用一个长度为N的二进制串表示它的状态，0表示这一个位置放置着<code>1*1</code>的方块，1表示这一个位置放置着<code>1*2</code>的方块。</p><p>构造这样一个转移矩阵，<code>T[i][j]</code>表示状态i的列右边连着状态j的列的时候，有多少种状态j的列是可行的。</p><p>然后对矩阵求快速幂即可。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch; <span class="keyword">int</span> v,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch=getchar())) <span class="keyword">if</span> (ch==<span class="string">'-'</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">1</span>;<span class="keyword">else</span> v=ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch=getchar())) v=v*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> f?-v:v;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">300</span>;</span><br><span class="line">ll mat[maxn][maxn], M,sz;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trans</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>, dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, bin = <span class="number">1</span>; i &lt;= n; i++, bin &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = ((X &amp; bin) &gt; <span class="number">0</span>), y = ((Y &amp; bin) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + (x==<span class="number">0</span>?dp[i<span class="number">-1</span>][<span class="number">0</span>]:<span class="number">0</span>);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tmp[maxn][maxn],Map[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(ll m[maxn][maxn],ll t,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(Map,m,<span class="keyword">sizeof</span>(Map));</span><br><span class="line">    t--;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) tmp[i][j]=<span class="number">0</span>;<span class="comment">//清空临时数组</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">            <span class="keyword">if</span> (m[i][k])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) tmp[i][j]+=m[i][k]*Map[k][j]%mod,tmp[i][j]%=mod; <span class="comment">//矩阵乘法</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) Map[i][j]=tmp[i][j];      <span class="comment">//赋值到原数组</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) tmp[i][j]=<span class="number">0</span>;<span class="comment">//清空临时数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">            <span class="keyword">if</span> (m[i][k])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) tmp[i][j]+=m[i][k]*m[k][j]%mod,tmp[i][j]%=mod;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++) m[i][j]=tmp[i][j];     </span><br><span class="line">        t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) ans=(ans+Map[N][i])%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; M;</span><br><span class="line">    sz = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz; j++) &#123;</span><br><span class="line">        mat[i][j] = trans(i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ksm(mat,M,sz)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;用&lt;code&gt;1*1&lt;/code&gt;或者&lt;code&gt;1*2&lt;/code&gt;的小长方形完整覆盖N*M的长方形（不可重叠），问有多少种覆盖方式？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>codeforces gym 101635J [Frosting on the Cake] 2017-2018 ACM-ICPC, Southwestern European Regional Programming Contest (SWERC 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/8e378f9.html"/>
    <id>http://dafenghh.github.io/post/8e378f9.html</id>
    <published>2018-01-26T06:32:45.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p> 将一块蛋糕，横切n-1刀，竖切n-1刀。使水平方向上，各块宽度分别为B1, B2…Bn；垂直方向上，各块宽度分别为A1, A2…An.</p><p>现在，按从左到右，从上到下的顺序，给每一小块依次循环染色“白 黄 粉”三种颜色。</p><p>求出每一种颜色的方块的总面积。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>其实就是一个简单的取余问题。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch; <span class="keyword">int</span> v,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch=getchar())) <span class="keyword">if</span> (ch==<span class="string">'-'</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">1</span>;<span class="keyword">else</span> v=ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch=getchar())) v=v*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> f?-v:v;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100020</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], b[maxn];</span><br><span class="line">ll am[<span class="number">3</span>],ans[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i], am[i%<span class="number">3</span>] += a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            ans[j] += b[i] * (am[((ll)j-(ll)i*n<span class="number">-2</span>+<span class="number">3</span>*(ll)maxn*maxn)%<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>] &lt;&lt;<span class="string">" "</span> &lt;&lt; ans[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt; 将一块蛋糕，横切n-1刀，竖切n-1刀。使水平方向上，各块宽度分别为B1, B2…Bn；垂直方向上，各块宽度分别为A1, A2…An.&lt;/p&gt;
&lt;p&gt;现在，按从左到右，从上到下的顺序，给每一小块依次循环染色“白 黄 粉”三种颜色。&lt;/p&gt;
&lt;p&gt;求出每一种颜色的方块的总面积。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="implementation" scheme="http://dafenghh.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101620L [Lunar Landscape] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/96671495.html"/>
    <id>http://dafenghh.github.io/post/96671495.html</id>
    <published>2018-01-26T05:40:19.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>卫星拍下了地面的很多照片。每张照片覆盖了平面的一个正方形区域，这个正方形要么边与坐标轴平行，要么对角线与坐标轴平行，保证中心点和顶点都在坐标整点的位置。</p><p>求被覆盖的区域面积。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>如果题目只给出边与坐标轴平行的正方形的话，那这道题很简单，直接二维前缀和就OK。</p><p>但这道题有侧着放的正方形（对角线与坐标轴平行），又该怎么处理呢？</p><p>首先发现，一个正方形小格可以按对角线分成4块小三角形，有多少块小三角形被覆盖，则要看侧正方形的分布情况。</p><p>如果用一下坐标变换，将坐标系向由旋转45度，再将单位长度设置为小三角形的直角边长。可以求出，这个坐标变换的表达式为：<br>$x’=x-y,y’=x+y$</p><p>旋转坐标系后，将每一个小三角形视为一个元素，然后对这些小三角形用二维前缀和即可。</p><p>找出变换后的坐标跟原来坐标的对应关系，本题解答完成。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1600</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span> * N][<span class="number">2</span> * N], g[<span class="number">8</span> * N][<span class="number">4</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> x,y,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d%d"</span>,s, &amp;x,&amp;y,&amp;d);</span><br><span class="line">        d /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'A'</span>) &#123;</span><br><span class="line">            f[x-d+N][y-d+N]++;</span><br><span class="line">            f[x+d+N][y-d+N]--;</span><br><span class="line">            f[x-d+N][y+d+N]--;</span><br><span class="line">            f[x+d+N][y+d+N]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x0 = x - y, y0 = x + y;</span><br><span class="line">            x = x0, y = y0;</span><br><span class="line">            g[<span class="number">2</span>*x<span class="number">-2</span>*d+<span class="number">4</span>*N][y-d+<span class="number">2</span>*N]++;</span><br><span class="line">            g[<span class="number">2</span>*x+<span class="number">2</span>*d+<span class="number">4</span>*N][y-d+<span class="number">2</span>*N]--;</span><br><span class="line">            g[<span class="number">2</span>*x<span class="number">-2</span>*d+<span class="number">4</span>*N][y+d+<span class="number">2</span>*N]--;</span><br><span class="line">            g[<span class="number">2</span>*x+<span class="number">2</span>*d+<span class="number">4</span>*N][y+d+<span class="number">2</span>*N]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * N; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) f[i][j] += f[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) f[i][j] += f[i][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) f[i][j] -= f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> * N; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span> * N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) g[i][j] += g[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) g[i][j] += g[i][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) g[i][j] -= g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">-1510</span>; x &lt; <span class="number">1510</span>; x++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">-1510</span>; y &lt; <span class="number">1510</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x+N][y+N]) ans++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x0 = x - y, y0 = x + y;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">2</span>*x0<span class="number">-1</span>+<span class="number">4</span>*N][y0+<span class="number">1</span>+<span class="number">2</span>*N]) ans += <span class="number">0.25</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">2</span>*x0<span class="number">-1</span>+<span class="number">4</span>*N][y0+<span class="number">2</span>*N]) ans += <span class="number">0.25</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">2</span>*x0+<span class="number">4</span>*N][y0+<span class="number">1</span>+<span class="number">2</span>*N]) ans += <span class="number">0.25</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">2</span>*x0+<span class="number">4</span>*N][y0+<span class="number">2</span>*N])   ans += <span class="number">0.25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;卫星拍下了地面的很多照片。每张照片覆盖了平面的一个正方形区域，这个正方形要么边与坐标轴平行，要么对角线与坐标轴平行，保证中心点和顶点都在坐标整点的位置。&lt;/p&gt;
&lt;p&gt;求被覆盖的区域面积。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101620H [Hidden Hierarchy] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/1dd196f0.html"/>
    <id>http://dafenghh.github.io/post/1dd196f0.html</id>
    <published>2018-01-26T05:39:40.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出n个文件的路径和大小，然后要像Windows资源管理器的侧边栏那样输出文件夹的分层结构。当一个文件夹里的所有子文件夹大小都不超过t时，它会折叠起来。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>模拟题，集训的时候打崩了。关键是建树的过程，将路径拆分成文件夹名的vector，然后利用这个vector创建这个路径上的所有文件夹的结点。</p><p>所有结点按创建次序保存在数组中，每一个结点包含一个map<string, int="">, 存放它的子节点，“文件夹名”到结点位置的映射。</string,></p><p>这样一来，这道题就很好写了。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; subdir;</span><br><span class="line">&#125;a[<span class="number">60000</span>];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFile</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;path, <span class="keyword">int</span> pi, <span class="keyword">int</span> sz, <span class="keyword">int</span> ai)</span> </span>&#123;</span><br><span class="line">    a[ai].sz += sz;</span><br><span class="line">    <span class="keyword">if</span> (pi &gt;= path.size()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!a[ai].subdir.count(path[pi])) &#123;</span><br><span class="line">        a[++tot].name = path[pi];</span><br><span class="line">        a[ai].subdir[path[pi]] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    addFile(path, pi + <span class="number">1</span>, sz, a[ai].subdir[path[pi]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFold</span><span class="params">(<span class="keyword">int</span> ai)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i:a[ai].subdir) <span class="keyword">if</span> (a[i.second].sz &gt;= t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDir</span><span class="params">(<span class="keyword">int</span> ai = <span class="number">0</span>, <span class="built_in">string</span> ps = <span class="string">""</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ps += a[ai].name + <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[ai].subdir.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  %s %d\n"</span>, ps.c_str(), a[ai].sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (canFold(ai)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"+ %s %d\n"</span>, ps.c_str(), a[ai].sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"- %s %d\n"</span>, ps.c_str(), a[ai].sz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i:a[ai].subdir) printDir(i.second,ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1024</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, str, &amp;sz);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">        <span class="built_in">string</span> buf;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'/'</span>) path.push_back(buf),buf.clear();</span><br><span class="line">            <span class="keyword">else</span> buf += <span class="built_in">string</span>(<span class="number">1</span>, str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        addFile(path, <span class="number">0</span>, sz, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    printDir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给出n个文件的路径和大小，然后要像Windows资源管理器的侧边栏那样输出文件夹的分层结构。当一个文件夹里的所有子文件夹大小都不超过t时，它会折叠起来。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="dfs and similar" scheme="http://dafenghh.github.io/tags/dfs-and-similar/"/>
    
      <category term="tree" scheme="http://dafenghh.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>NWERC 2017 H [High Score] (The 2017 Northwestern Europe Regional Contest) 题解</title>
    <link href="http://dafenghh.github.io/post/54cee541.html"/>
    <id>http://dafenghh.github.io/post/54cee541.html</id>
    <published>2018-01-24T02:34:18.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p><a href="https://open.kattis.com/problems/highscore2" target="_blank" rel="noopener">题目链接</a> （可能需要翻墙）</p><p>给定a,b,c, 定义  $score = a^2 + b^2 + c^2+7\cdot \min(a,b,c)$</p><p>现在给出一个d，要将d拆成三份作为a，b，c的增量，即赋值<code>a += d1, b += d2, c += d3</code>, 满足<code>d1, d2, d3 &gt;= 0, d1 + d2 + d3 = d</code></p><p>求score的最大值。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>注意到加上d后，前面平方项的增量是O(d^2)级别，后面min(a,b,c)这项是O(d)级别，所以当d比较大时，把d全部加给a b c中的最大值即可；d比较小时，暴力一一验证即可。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">true<span class="keyword">int</span> n;</span><br><span class="line">true<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">truetruell a,b,c,d;</span><br><span class="line">truetrue<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">truetruell sz0 = <span class="number">4</span>, sz1 = <span class="number">10</span>;</span><br><span class="line">truetrue<span class="keyword">if</span> (a &lt; sz0 &amp;&amp; b &lt; sz0 &amp;&amp; c &lt; sz0 &amp;&amp; d &lt; sz1) &#123;</span><br><span class="line">truetruetruell ans = a*a+b*b+c*c+<span class="number">7</span>*min(a,min(b,c));</span><br><span class="line">truetruetrue<span class="keyword">for</span> (ll d1 = <span class="number">0</span>; d1 &lt;= d; d1++)</span><br><span class="line">truetruetrue<span class="keyword">for</span> (ll d2 = <span class="number">0</span>, d3 = d - d1 - d2; d2 &lt;= d &amp;&amp; d3 &gt;= <span class="number">0</span>; d2++, d3 = d - d1 - d2) &#123;</span><br><span class="line">truetruetruetrueans = max(ans, (a+d1)*(a+d1)+(b+d2)*(b+d2)+(c+d3)*(c+d3)+<span class="number">7</span>*min(a+d1, min(b+d2,c+d3)));</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrue<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">truetruetrue<span class="keyword">continue</span>;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruell mat=max(max(a,b),c);</span><br><span class="line">truetruell t1=ll(a+d)*(a+d)+(ll)b*b+(ll)c*c+ll(<span class="number">7</span>)*min(min(a+d,b),c);</span><br><span class="line">truetruell t2=ll(a)*a+ll(b+d)*(b+d)+(ll)c*c+ll(<span class="number">7</span>)*min(min(a,b+d),c);</span><br><span class="line">truetruell t3=ll(a)*a+ll(b)*b+ll(c+d)*(c+d)+ll(<span class="number">7</span>)*min(min(a,b),c+d);</span><br><span class="line">truetrue<span class="built_in">cout</span>&lt;&lt;max(t1,max(t2,t3))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://open.kattis.com/problems/highscore2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt; （可能需要翻墙）&lt;/p&gt;
&lt;p&gt;给定a,b,c, 定义  $score = a^2 + b^2 + c^2+7\cdot \min(a,b,c)$&lt;/p&gt;
&lt;p&gt;现在给出一个d，要将d拆成三份作为a，b，c的增量，即赋值&lt;code&gt;a += d1, b += d2, c += d3&lt;/code&gt;, 满足&lt;code&gt;d1, d2, d3 &amp;gt;= 0, d1 + d2 + d3 = d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;求score的最大值。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>codeforces gym 101630B [Box] 2017-2018 ACM-ICPC, Northern Eurasia (Northeastern European Regional) Contest (NEERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/5f7aa68.html"/>
    <id>http://dafenghh.github.io/post/5f7aa68.html</id>
    <published>2018-01-23T12:47:49.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一张<code>w*h</code>大小的纸片，要求裁剪出一个<code>a*b*c</code>的长方体的展开图，问是否可行。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>长方体展开图共有11种情况，分别算出每种情况所需要的长宽，然后枚举验证即可。</p><p>P.S. 小学奥数题的升级版。一开始用蛮力想象展开图平起来后的边的情况。但毕竟自己的空间想象能力并不是很强，而且这样很费时，所以并不是好的做法。其实只要在展开图中根据相邻关系标上边的长度即可。</p><p>P.S. opentrain的测试数据很弱，集训时1A。回来交CF，WA了第40个点。改了一个小时后，WA第55个点。原来自己的next_permutation用在了原边长数组上，犯了一个低级错误。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">3</span>],inx[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">true<span class="keyword">int</span> w, h;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">true<span class="keyword">if</span> (a &lt;= w &amp;&amp; b &lt;= h) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">true<span class="keyword">if</span> (b &lt;= w &amp;&amp; a &lt;= h) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">true<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);</span><br><span class="line">true</span><br><span class="line">true<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w, &amp;h);</span><br><span class="line">true<span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">true<span class="keyword">do</span> &#123;</span><br><span class="line">truetrue<span class="keyword">int</span> a = A[inx[<span class="number">0</span>]], b= A[inx[<span class="number">1</span>]], c = A[inx[<span class="number">2</span>]];</span><br><span class="line">truetrue<span class="keyword">if</span> (comp(<span class="number">2</span>*(a+c), b + <span class="number">2</span> * c)||</span><br><span class="line">truetruetruecomp(<span class="number">3</span>*b+a+c,a+c)|| </span><br><span class="line">truetruetruecomp(a+b+c,a+b+<span class="number">2</span>*c)|| </span><br><span class="line">truetruetruecomp(a+b+c,<span class="number">2</span>*b+<span class="number">2</span>*c)||</span><br><span class="line">truetruetruecomp(a+<span class="number">2</span>*b+c,a+<span class="number">2</span>*c)) find = <span class="literal">true</span>;</span><br><span class="line">true&#125;<span class="keyword">while</span> (!find &amp;&amp; next_permutation(inx, inx + <span class="number">3</span>));</span><br><span class="line">true<span class="built_in">puts</span>(find?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一张&lt;code&gt;w*h&lt;/code&gt;大小的纸片，要求裁剪出一个&lt;code&gt;a*b*c&lt;/code&gt;的长方体的展开图，问是否可行。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101630C [Connections] 2017-2018 ACM-ICPC, Northern Eurasia (Northeastern European Regional) Contest (NEERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/a35a5595.html"/>
    <id>http://dafenghh.github.io/post/a35a5595.html</id>
    <published>2018-01-23T11:01:49.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个强连通的有向图，n个点，m条边；要求，去掉m-2n条边，使剩下的图仍然强连通。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>采用DFS，将需要保留下的边打上记号。然后任意输出m-2n条不需要保留的边即可。</p><p>哪些边需要保留呢？</p><p>DFS前进的那些边（即搜索树中的边，“实边”）一定要保留，至于虚边，则保留得越少越好。</p><p>所以优先从搜索树的靠叶子端取虚边。比如DFS依次经过1-&gt;2-&gt;3-&gt;4, 我们就先从4开始取回去的边，回去得越前越好，即如果同时存在(4,3)和(4,2）就取（4，2）,然后回到结点2，再取一条(2,1)就能构成一个环，也即强连通的子图。</p><p>具体实现的话，dfs返回当前访问子树能够回去的最前结点（有点类似tarjan的lowlink）。对一个结点来说，所有虚边只需考虑最优那条（即返回的点index越小越好）。然后拿它跟子树返回结果的最小值（代表子树能够回去的最前结点）比较，如果这条虚边更有，就连上。</p><p>P.S. 1A这题，很开心！</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100020</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="built_in">map</span>&lt;P, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="keyword">bool</span> used[maxn];</span><br><span class="line"><span class="keyword">int</span> index[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    index[v] = cnt++;</span><br><span class="line">    used[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> bv = v, nbi = index[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: G[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">            M[P(v,i)] = <span class="number">1</span>;</span><br><span class="line">            nbi = min(nbi, dfs(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index[i] &lt; index[bv]) bv = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index[bv] &lt; nbi) &#123;</span><br><span class="line">        M[P(v, bv)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(nbi, index[bv]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">      M.clear();</span><br><span class="line">      cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">      <span class="built_in">memset</span>(index, <span class="number">0</span>, <span class="keyword">sizeof</span>(index));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">              <span class="keyword">int</span> x,y;</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">              G[x].push_back(y);</span><br><span class="line">              M[P(x,y)] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      dfs(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i: M) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!i.second) &#123;</span><br><span class="line">              tot++;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i.first.first, i.first.second);</span><br><span class="line">              <span class="keyword">if</span> (tot == m - <span class="number">2</span> * n) <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个强连通的有向图，n个点，m条边；要求，去掉m-2n条边，使剩下的图仍然强连通。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="graphs" scheme="http://dafenghh.github.io/tags/graphs/"/>
    
      <category term="dfs and similar" scheme="http://dafenghh.github.io/tags/dfs-and-similar/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3470 [Walls] 题解</title>
    <link href="http://dafenghh.github.io/post/7d2ff651.html"/>
    <id>http://dafenghh.github.io/post/7d2ff651.html</id>
    <published>2018-01-22T15:11:51.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>平面上有n条与坐标轴平行的互不相交的线段，代表墙；还有m个不在线段上的点，代表鸟。鸟会沿着坐标轴方向，飞向离它最近的墙，并撞上去。求每一面墙会有多少只鸟撞上来。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>先离散化坐标。</p><p>按其中一个坐标（比如y）排好序后，使用扫描线算法，对于另一个坐标（比如x）建一棵支持区间更新和单点查询的线段树，表示每一个点当前会撞向的墙的序号。</p><p>自己写的扫描线啰嗦地惨不忍睹，WA很多次都没过。</p><p>参考了下<a href="http://www.cnblogs.com/forever97/p/poj3470.html" target="_blank" rel="noopener">forever97</a> 的代码，非常简洁优雅，落落大方。真是感激不尽！</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200020</span>;</span><br><span class="line"><span class="keyword">int</span> tr[maxn * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = maxn - <span class="number">20</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[v] != <span class="number">-2</span>) <span class="keyword">return</span> tr[v];</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) <span class="keyword">return</span> tr[v];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; mid) <span class="keyword">return</span> query(x, chl, l, mid);</span><br><span class="line">    <span class="keyword">return</span> query(x,chr,mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> val, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = maxn - <span class="number">20</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= L || R &lt;= l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        tr[v] = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[v] != <span class="number">-2</span>) &#123;</span><br><span class="line">        tr[chl] = tr[chr] = tr[v];</span><br><span class="line">        tr[v] = <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    update(L, R, val, chl, l, mid);</span><br><span class="line">    update(L, R, val, chr, mid, r);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> X[maxn], Y[maxn], X_inx[maxn], Y_inx[maxn],X_comp[maxn], Y_comp[maxn],</span><br><span class="line">    wall_to_fly[maxn], total_for_wall[maxn],dis[maxn];</span><br><span class="line"><span class="keyword">int</span> *arr;</span><br><span class="line"><span class="keyword">int</span> wn,pn; <span class="comment">// wall point</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[a] &lt; arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">int</span> *X, <span class="keyword">int</span> *Comp,<span class="keyword">int</span> *Inx, <span class="keyword">int</span> n=pn)</span> </span>&#123;</span><br><span class="line">    arr = X;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) Inx[i] = i;</span><br><span class="line">    sort(Inx, Inx + n, cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;Comp[Inx[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (X[Inx[i]] != X[Inx[i<span class="number">-1</span>]]) cnt++;</span><br><span class="line">        Comp[Inx[i]] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">(<span class="keyword">int</span> *X, <span class="keyword">int</span> *Y, <span class="keyword">int</span> *X_comp, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; wn) &#123;</span><br><span class="line">        <span class="keyword">int</span> i_ = i^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (X_comp[i_] &gt;= X_comp[i]) &#123;</span><br><span class="line">            update(X_comp[i], X_comp[i_]+<span class="number">1</span>,i/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = query(X_comp[i]);</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = min(<span class="built_in">abs</span>(Y[i] - Y[<span class="number">2</span>*q]), <span class="built_in">abs</span>(Y[i] - Y[<span class="number">2</span>*q+<span class="number">1</span>]));</span><br><span class="line">            i-=wn;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] == <span class="number">-1</span> || d &lt; dis[i]) &#123;</span><br><span class="line">                dis[i] = d;</span><br><span class="line">                wall_to_fly[i] = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span> *X, <span class="keyword">int</span> *Y, <span class="keyword">int</span> *X_comp, <span class="keyword">int</span> *Inx)</span> </span>&#123;</span><br><span class="line">    tr[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pn; i++) scan(X, Y, X_comp, Inx[i]);</span><br><span class="line">    tr[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pn; i &gt;= <span class="number">0</span>; i--) scan(X, Y, X_comp, Inx[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">int</span> n_, m_;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n_, &amp;m_);</span><br><span class="line">    wn = <span class="number">2</span> * n_;</span><br><span class="line">    pn = wn + m_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pn; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, X + i, Y + i);</span><br><span class="line">    compress(X, X_comp, X_inx);</span><br><span class="line">    compress(Y, Y_comp, Y_inx);</span><br><span class="line">    fly(X, Y, X_comp, Y_inx);</span><br><span class="line">    fly(Y, X, Y_comp, X_inx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_; i++) total_for_wall[wall_to_fly[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, total_for_wall[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;平面上有n条与坐标轴平行的互不相交的线段，代表墙；还有m个不在线段上的点，代表鸟。鸟会沿着坐标轴方向，飞向离它最近的墙，并撞上去。求每一面墙会有多少只鸟撞上来。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="scanline" scheme="http://dafenghh.github.io/tags/scanline/"/>
    
  </entry>
  
  <entry>
    <title>NWERC 2017 A [Ascending Photo] (The 2017 Northwestern Europe Regional Contest) 题解</title>
    <link href="http://dafenghh.github.io/post/7c1f2f41.html"/>
    <id>http://dafenghh.github.io/post/7c1f2f41.html</id>
    <published>2018-01-22T15:08:38.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p><a href="https://open.kattis.com/contests/nwerc17open/problems/ascendingphoto" target="_blank" rel="noopener">题目链接</a></p><p>给定一个序列，将它切割成若干段，使得对每一段进行移动之后可以重排成非严格升序。求最少的切割数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>（集训的时候就差DP这步没想出来。）</p><p>首先先将相邻的相同元素合并，并进行离散化（不影响答案）。</p><p>然后现在将数组的每一个元素都切开（即切n-1下），比如1|2|3|0|4</p><p>于是问题可以转化为，这n-1块“挡板”最多有多少块可以去掉，如果为s，那么最终答案就是n-1-s.</p><p>在上面的例子中，唯一能够去掉的挡板是(2,3), 即变成1|2 3|0|4</p><p>很显然，挡板能够去掉首先要满足，左右两个元素相差1.</p><p>另外，假如有多块(2,3)挡板，比如对于1|2|3|4|2|3</p><p>(2,3)的挡板只能去掉其中一块（不然装不回来）。所以，我们可以先将所有值出现的位置保存到vector中，然后从小到大考虑值，每两个相邻的值应该去掉哪一块挡板（有可能去不掉）。</p><p>另外，如果去掉前面的(2,3)挡板，这时候会发现，紧接着后面的(3,4)挡板就去不了了。</p><p>否则会变成：1|2 3 4|2|3</p><p>可以看到最右边的3落下了。</p><p>所以可以看到，去掉一个挡板有可能会产生一个冲突位置。具体地说，如果存在连续序列(a,a+1,a+2), 并且a+1在数组中不唯一，那么去掉(a,a+1)挡板将会导致(a+1,a+2）的挡板无法去除。</p><p>用<code>dp[i]</code>表示去除值(0,1)到值(i,i+1)的所有可去除的挡板数量。</p><p>注意到，<code>dp[i]</code>的值与每一步去除哪一块可选挡板有关，所以要加多一维。<code>dp[i][j]</code>的j表示，去除值(i,i+1)的挡板时，考虑的是位置(j,j+1)</p><p>即首先i和j有条件，<code>h[j] = i, h[j+1] = i+1</code></p><p><code>dp[i][j] = max(dp[i-1][j&#39;] + （j是不是j&#39;产生的冲突位置?0:1）)</code></p><p>“j是不是j’产生的冲突位置” 等价于<code>j = j&#39; + 1 &amp;&amp; h[j]不唯一</code></p><p>从这个条件可以看出，对于一个j’，最多产生一个冲突位置，j’+1(当h[j’+1]唯一就不是冲突位置）。</p><p>对于一个j，只可能是一个位置j’ = j - 1的冲突位置。（条件*）</p><p>如果我们把dp[i]看成一张表，那么最后我们求的就是dp[n]的最大值。</p><p>观察转移方程，从dp[i]向dp[i+1]转移的时候，求max的是dp[i]这张表的所有元素，但其中有些元素加了1（条件j不是j’的冲突位置）。</p><p>所以，我们只需保存这张表最大的那些值就行了。比如某个dp[i]={1,2,3,4,5,5,5}, 我们只需要保存{5,5,5}就行，因为前面的数，比如4，加上1也才是5，并不会更优。</p><p>dp[i+1]的值有可能是5，也有可能是6，要看三个5之中，有没有一个5对应的冲突位置不是j，这个5就能加上1，变成6.</p><p>回顾条件*，当我们保存了两个dp值最大的j’对应的冲突位置时，那么求 <code>dp[i][j]</code> 就能一定找到一个不冲突的位置，然后累计加上1.</p><p>所以，每一步dp求出的表中，只需要保存最大两个值以及它们对应的冲突位置即可，下面代码，用best[0]和best[1]保存最大两个值以及对应的冲突位置。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">true<span class="keyword">char</span> ch; <span class="keyword">int</span> v=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">true<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch=getchar())) <span class="keyword">if</span> (ch==<span class="string">'-'</span>) <span class="keyword">break</span>;</span><br><span class="line">true<span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">1</span>;<span class="keyword">else</span> v=ch<span class="number">-48</span>;</span><br><span class="line">true<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch=getchar())) v=v*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">true<span class="keyword">return</span> f?-v:v;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000020</span>;</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; H;</span><br><span class="line">    <span class="keyword">int</span> n = get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = get();</span><br><span class="line">        <span class="keyword">if</span> (H.empty() || H.back() != x) H.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    n = (<span class="keyword">int</span>)H.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) b[i] = H[i];</span><br><span class="line">    sort(b, b + n);</span><br><span class="line">    <span class="keyword">int</span> sz = unique(b, b + n) - b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; posi(sz);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) H[i] = lower_bound(b, b + sz, H[i]) - b, posi[H[i]].push_back(i);</span><br><span class="line">    P best[<span class="number">2</span>] = &#123;P(<span class="number">0</span>, n), P(<span class="number">0</span>, n)&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; sz - <span class="number">1</span>; h++) &#123;</span><br><span class="line">        P nbest[<span class="number">2</span>] = &#123;best[<span class="number">0</span>], best[<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; posi[h].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = posi[h][i];</span><br><span class="line">            <span class="keyword">if</span> (p == n - <span class="number">1</span> || H[p] + <span class="number">1</span> != H[p + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="function">P <span class="title">s</span><span class="params">(<span class="number">0</span>, n)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (p != best[<span class="number">0</span>].second) s = best[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> s = best[<span class="number">1</span>];</span><br><span class="line">            s.first++, s.second = p + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (posi[h + <span class="number">1</span>].size() == <span class="number">1</span>) s.second = n;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; nbest[<span class="number">0</span>]) nbest[<span class="number">1</span>] = nbest[<span class="number">0</span>], nbest[<span class="number">0</span>] = s;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; nbest[<span class="number">1</span>]) nbest[<span class="number">1</span>] = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        best[<span class="number">0</span>] = nbest[<span class="number">0</span>], best[<span class="number">1</span>] = nbest[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - <span class="number">1</span> - best[<span class="number">0</span>].first);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://open.kattis.com/contests/nwerc17open/problems/ascendingphoto&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个序列，将它切割成若干段，使得对每一段进行移动之后可以重排成非严格升序。求最少的切割数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="dp" scheme="http://dafenghh.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101620D [Donut Drone] 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) 题解</title>
    <link href="http://dafenghh.github.io/post/a74fadaa.html"/>
    <id>http://dafenghh.github.io/post/a74fadaa.html</id>
    <published>2018-01-21T12:41:28.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一个矩形方块，有r*c个格子，水平和垂直方向上都可以将它视为首尾相连的（也即从最右边向右移会回到最左边，从最下边向下移会回来最上边，以此类推）。每个格子上有一个数。每一次移动会往相邻的右边、右上、右下的三个格子中选最大数的格子移动。初始位置在左上角。两种操作：1. 移动k步，输出新位置；2.修改某个格子的数。</p><p>数据范围：r，c $\leq$ 2000, 询问数5000以内。 </p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>移动k步时，列数的增量是确定的（k），行数未知，由二维数组确定。</p><p>可以很自然地想到用线段树解决这个问题。线段树的每一个结点，维护的是一张从第l列到第r列, 即[L,r)，行数y的转移表（本来行数应该用x来表示，但是一开始敲时就弄混了，所以后面只好交换了x和y的定义）。</p><p>这样，当我们从第y行第x列出发时，若k比较小直接模拟。k比较大时，先查询线段树，拿到y在[x, c)的转移值y’。这样就回到了(y’,0) 即第一列。</p><p>然后一次走c步，即采用[0,c)的转移表，意思就是从第一列一直往右走，知道走回第一列。不断重复这个过程，每一次可以使步数+c。</p><p>理论上这么模拟可以使单次询问的复杂度达到O(k/c*log c);</p><p>但考虑到行数只有r个，所以只会产生长度不超过r的环。所以把经过的点记录一下，产生环即跳出。这样复杂度可以优化至O(r*log c).</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1234567890</span>;</span><br><span class="line"><span class="keyword">int</span> dat[<span class="number">4</span> * maxn][maxn], row, col , a[maxn][maxn], NY[maxn][maxn],circle[maxn],posi[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = col)</span> </span>&#123; <span class="comment">// [l, r)</span></span><br><span class="line">     <span class="keyword">if</span> (x2 &lt;= l || r &lt;= x1) <span class="keyword">return</span> y;</span><br><span class="line">     <span class="keyword">if</span> (x1 &lt;= l &amp;&amp; r &lt;= x2) <span class="keyword">return</span> dat[v][y];</span><br><span class="line">     <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span> LAns = query(y, x1, x2, chl, l, mid);</span><br><span class="line">     <span class="keyword">return</span> query(LAns, x1, x2, chr, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = col)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (x &lt; l || x &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">            dat[v][y] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">     update(x, y, val, chl, l, mid);</span><br><span class="line">     update(x, y, val, chr, mid, r);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) dat[v][i] = dat[chr][dat[chl][i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) dat[v][i] = NY[l][i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    build(chl, l, mid);</span><br><span class="line">    build(chr, mid, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        dat[v][i] = dat[chr][dat[chl][i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v; <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch=getchar()));</span><br><span class="line">    v=ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch=getchar())) v=v*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nx = (x + <span class="number">1</span>) % col, Max = -INF, res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt;= <span class="number">1</span>; dy++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ny = (y + dy + row) % row;</span><br><span class="line">        <span class="keyword">if</span> (a[nx][ny] &gt; Max) &#123;</span><br><span class="line">            Max = a[nx][ny];</span><br><span class="line">            res = ny;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    row = read(), col = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) a[j][i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) NY[j][i] = getNY(j, i);</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    build();</span><br><span class="line">    <span class="keyword">int</span> m = read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'m'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = read();</span><br><span class="line">            <span class="keyword">if</span> (k &gt; col) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x != <span class="number">0</span>) k-= col-x, y = query(y,x,col),x=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memset</span>(posi, <span class="number">-1</span>, <span class="keyword">sizeof</span>(posi));</span><br><span class="line">                circle[<span class="number">0</span>] = y;</span><br><span class="line">                posi[y] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> ci = k / col;</span><br><span class="line">                k -= ci * col;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ci; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    circle[i] = y = query(y, <span class="number">0</span>, col);</span><br><span class="line">                    <span class="keyword">if</span> (posi[y] != <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> len = i - posi[y];</span><br><span class="line">                        y = circle[posi[y] + (ci - posi[y]) % len];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    posi[y] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (k &gt; <span class="number">0</span>) y = query(y, <span class="number">0</span>, k);</span><br><span class="line">                x = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                    y = NY[x][y];x = (x + <span class="number">1</span>) % col;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, y + <span class="number">1</span>, x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> cy = read() - <span class="number">1</span>, cx = read() - <span class="number">1</span>, val = read();</span><br><span class="line">            a[cx][cy] = val;</span><br><span class="line">            <span class="keyword">int</span> px = (cx + col - <span class="number">1</span>) % col;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt;= <span class="number">1</span>; dy++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> py = (cy + dy + row) % row;</span><br><span class="line">                <span class="keyword">int</span> temp = getNY(px, py);</span><br><span class="line">                <span class="keyword">if</span> (NY[px][py] != temp) &#123;</span><br><span class="line">                    NY[px][py] = temp;</span><br><span class="line">                    update(px, py, temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;一个矩形方块，有r*c个格子，水平和垂直方向上都可以将它视为首尾相连的（也即从最右边向右移会回到最左边，从最下边向下移会回来最上边，以此类推）。每个格子上有一个数。每一次移动会往相邻的右边、右上、右下的三个格子中选最大数的格子移动。初始位置在左上角。两种操作：1. 移动k步，输出新位置；2.修改某个格子的数。&lt;/p&gt;
&lt;p&gt;数据范围：r，c $\leq$ 2000, 询问数5000以内。 &lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5249 [KPI] 题解</title>
    <link href="http://dafenghh.github.io/post/a54ea176.html"/>
    <id>http://dafenghh.github.io/post/a54ea176.html</id>
    <published>2018-01-17T07:59:57.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>n次操作，有3种操作的类型：入队、出队、查询队列中的中位数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>区间第K大的简单版本。用权值线段树可以轻松解决。这里尝试使用一下树状数组。这里搞明白树状数组的原理后，findK函数可以写得很清晰。</p><p>稍微解释一下findK函数，从x=1&lt;&lt;16（值的上界）开始定位答案，判定bit[]数组的值来定位答案位于权区间的左半部分还是右半部分。反复执行这个过程，逐步缩小区间得到答案。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10020</span>;</span><br><span class="line"><span class="keyword">int</span> tot, bit[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= tot; i += i &amp; -i) bit[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>); x; x &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans + x &lt; tot &amp;&amp; bit[ans + x] &lt; k) &#123;</span><br><span class="line">            k -= bit[ans += x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> Q[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qn, ti = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;qn) != EOF) &#123;</span><br><span class="line">        init();</span><br><span class="line">        ++ti;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ti);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qn; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            Q[i] = s[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Q[i] == <span class="string">'i'</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[n]);</span><br><span class="line">                b[n] = a[n];</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b, b + n);</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = lower_bound(b, b + n, a[i]) - b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ql = <span class="number">0</span>, qr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qn; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q[i] == <span class="string">'i'</span>) &#123;</span><br><span class="line">                update(a[qr++], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Q[i] == <span class="string">'o'</span>) &#123;</span><br><span class="line">                update(a[ql++], <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[findK((qr - ql + <span class="number">2</span>)/ <span class="number">2</span>)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;n次操作，有3种操作的类型：入队、出队、查询队列中的中位数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1201 [Intervals] 题解</title>
    <link href="http://dafenghh.github.io/post/a568ae24.html"/>
    <id>http://dafenghh.github.io/post/a568ae24.html</id>
    <published>2018-01-17T03:18:14.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定n个区间，现在要从每个区间$[a_i, b_i]$中取出$c_i$个数，所有被取出的数组成一个集合。求这个集合的最小size.</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>这种区间覆盖问题，首先考虑贪心法。如果将所有顶点按右端点排序后，依次取数。对每一个区间，尽量取靠右边的数。这是一个挺好的贪心策略，容易证明其正确性。</p><p>那么，对每个区间，需要做的事情有两步：</p><ol><li>（统计）统计这个区间上已经被取过的数的数量，如果已满足要求，则OK；否则进行第二步。</li><li>（取数）从右往左依次取新数，直到满足要求。</li></ol><p>朴素做法，统计这一步就需要O(n)复杂度，总计O(n^2), 显然不可行。</p><p>我们可以采用BIT，把统计这一步优化到O(log n）。</p><p>但第二步，取数的复杂度呢？</p><p>直觉来看，最坏情况下，每次取数要O(n)的时间，那么总体是O（n^2）复杂度。</p><p>但是，考虑到区间长度有限，也是O(n)的级别，所以实际上达到最坏情况的区间很少；换句话说，需要频繁取数的区间是很少的。（如果一个区间取出了很多数，那么相应的，它之后的重叠区间需要取数的区间个数就会少一些。）</p><p>于是，第二步用朴素算法即可。虽然没能估计确切的复杂度，但提交后跑起来很快，94ms就过了。</p><p>第二种做法，转化成差分约束问题。</p><p>如果用d[i]表示做法一中，BIT的前缀和，那么条件(区间[a,b]中有c个数被取出来)<br>可以表示成不等式<code>d[b]-d[a-1]&gt;=c</code></p><p>有了这个不等关系，就可以很方便的转成差分约束问题了，另外还要加上初始约束：<code>d[i]&lt;=d[i+1]&lt;=d[i]+1</code></p><p>很好理解。</p><p>然后求解最短路，即可得到答案。</p><p>这道题我们求的是d[Max] - d[Min]的最小值，但是最短路求出来后对应的是一个最大值。</p><p>于是我们可以加个负号，求出d[Min] - d[Max]的最大值x，那么-x就是答案。如果一开始将d[Max]赋值为0，那么最后答案就是-d[Min].</p><p>采用经队列优化的Bellmen Ford算法，最坏情况下复杂度仍然为O(VE).但考虑到这题中的图对应了一个规则良好的差分约束系统，很难出现一个极端不均匀的图。所以这种做法耗时仅200ms。</p><p>P.S. POJ没有开O2优化，所以用vector表示邻接表，再一次跪了……</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><h2 id="solution-1-贪心-BIT"><a href="#solution-1-贪心-BIT" class="headerlink" title="solution 1 (贪心+BIT)"></a>solution 1 (贪心+BIT)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50050</span>;</span><br><span class="line"><span class="keyword">int</span> bit[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i; i -= lowbit(i)) s+= bit[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; maxn; i += lowbit(i)) bit[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; b.r;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">bool</span> used[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i].l = read() + <span class="number">1</span>, a[i].r = read() + <span class="number">1</span>, a[i].c = read();</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> need = a[i].c - (sum(a[i].r) - sum(a[i].l - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = a[i].r; x &gt;= a[i].l &amp;&amp; need &gt; <span class="number">0</span>; x--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[x]) &#123;</span><br><span class="line">                used[x] = <span class="literal">true</span>;</span><br><span class="line">                add(x, <span class="number">1</span>);</span><br><span class="line">                need--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(maxn - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solution-2-差分约束"><a href="#solution-2-差分约束" class="headerlink" title="solution 2 (差分约束)"></a>solution 2 (差分约束)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50050</span>, INF = <span class="number">12345634</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cost, next;</span><br><span class="line">    edge(<span class="keyword">int</span> to = <span class="number">0</span>, <span class="keyword">int</span> cost = <span class="number">0</span>, <span class="keyword">int</span> next = <span class="number">0</span>):to(to), cost(cost), next(next)&#123;&#125;</span><br><span class="line">&#125;a[<span class="number">4</span> * maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], ei = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    a[ei] = edge(v, c, head[u]);</span><br><span class="line">    head[u] = ei++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> used[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mini</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maxi</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">int</span> n_ = read();</span><br><span class="line">    <span class="keyword">int</span> L = INF, R = -INF; <span class="comment">// [L, R]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = read() + <span class="number">1</span>, b = read() + <span class="number">1</span>, c = read();</span><br><span class="line">        add_edge(b, a - <span class="number">1</span>, -c);</span><br><span class="line">        Mini(L, a - <span class="number">1</span>);</span><br><span class="line">        Maxi(R, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; R; i++) add_edge(i, i + <span class="number">1</span>, <span class="number">1</span>), add_edge(i + <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">    fill(d, d + R + <span class="number">10</span>, INF);</span><br><span class="line">    d[R] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(R);</span><br><span class="line">    used[R] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        used[v] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[v]; i != <span class="number">-1</span>; i = a[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = a[i].to, cost = a[i].cost;</span><br><span class="line">            <span class="keyword">if</span> (d[v] + cost &lt; d[to]) &#123;</span><br><span class="line">                d[to] = d[v] + cost;</span><br><span class="line">                <span class="keyword">if</span> (!used[to]) que.push(to), used[to] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, -d[L]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定n个区间，现在要从每个区间$[a_i, b_i]$中取出$c_i$个数，所有被取出的数组成一个集合。求这个集合的最小size.&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="greedy" scheme="http://dafenghh.github.io/tags/greedy/"/>
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="graphs" scheme="http://dafenghh.github.io/tags/graphs/"/>
    
      <category term="差分约束" scheme="http://dafenghh.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3368 [Frequent Values] 题解</title>
    <link href="http://dafenghh.github.io/post/c9635eac.html"/>
    <id>http://dafenghh.github.io/post/c9635eac.html</id>
    <published>2018-01-11T01:54:21.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个长度为N的单调不下降的数组，M次询问，每次询问原数组区间[i, j]中，出现频数最多的数的频数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>先使用离散化，然后用lower_bound很方便的求出每一个值在原数组中的始点和终点。（终点可以用下一个值的始点表示）</p><p>然后构造一棵值分布的线段树，也就是说这棵线段树的每一个结点维护的是它所对应区间[l, r）中的值的最大的出现频数。</p><p>询问区间[i, j]， 先求出a[i], a[j]在[i,j]中的出现频数（用第一步求出的a[i]、a[j]的始点、终点位置很容易得到结果）。</p><p>然后往线段树中查询[a[i] + 1, a[j])即可。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, n, Q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], lt[maxn], tr[maxn * <span class="number">2</span>];<span class="comment">//left</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123; <span class="comment">// [l, r)</span></span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        tr[v] = lt[r] - lt[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span>, chr = chl + <span class="number">1</span>;</span><br><span class="line">        build(chl, l, mid);</span><br><span class="line">        build(chr, mid, r);</span><br><span class="line">        tr[v] = max(tr[chl], tr[chr]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;<span class="comment">// query [L, R) </span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || R &lt;= l || r &lt;= L) <span class="keyword">return</span> <span class="number">-12344</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[v];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span>, chr = chl + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> max(query(L, R, chl, l, mid), query(L, R, chr, mid, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        N = read();</span><br><span class="line">        <span class="keyword">if</span> (!N) <span class="keyword">break</span>;</span><br><span class="line">        Q = read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) a[i] = b[i] = read();</span><br><span class="line">        n = unique(b, b + N) - b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) a[i] = lower_bound(b, b + n, a[i]) - b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) lt[i] = lower_bound(a, a + N, i) - a;</span><br><span class="line">        lt[n] = N;</span><br><span class="line">        build();</span><br><span class="line">        <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = read(), r = read(); <span class="comment">//[l, r]</span></span><br><span class="line">            l--;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">-1244</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[l] == a[r]) ans = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                update(ans, lt[a[l] + <span class="number">1</span>] - l);</span><br><span class="line">                update(ans, r - lt[a[r]] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> L = a[l] + <span class="number">1</span>, R = a[r]; <span class="comment">// [L, R)</span></span><br><span class="line">                <span class="keyword">if</span> (L &lt; R)</span><br><span class="line">                update(ans, query(L, R));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个长度为N的单调不下降的数组，M次询问，每次询问原数组区间[i, j]中，出现频数最多的数的频数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2104 [K-th Number] 题解</title>
    <link href="http://dafenghh.github.io/post/76b5095a.html"/>
    <id>http://dafenghh.github.io/post/76b5095a.html</id>
    <published>2018-01-11T01:51:08.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个长度为n的数组，m次查询。每次查询给出三个数（i, j, k），表示要求原数组的区间[i, j]升序排列中的第k个数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>求区间第k小的经典题目！来源于《挑战程序设计竞赛》P185例题。然后发现，这道题在4个月之前，我学习主席树的时候就做过一次。</p><p>书上提供了平方分割和归并树的两种做法，下面我也将重现下这两种解法以及主席树的解法，并在最后对这三种优雅的解法作下对比。</p><h2 id="solution-1-分块"><a href="#solution-1-分块" class="headerlink" title="solution 1 (分块)"></a>solution 1 (分块)</h2><p>假如题目提供了一个函数cnt(i, j, x)，返回原数组区间[i, j]中小于x的数的个数。那么我们要求的区间[i,j]第k小的数，也就是要求满足cnt(i, j, x) &lt; k的最大的x。</p><p>于是，对x进行二分搜索，即可得到答案。</p><p>那么，我们怎么样才能自己写出一个类似于cnt(i, j, x)的函数呢？</p><p>假如数组区间[i, j]是有序的，那么我们很容易用lower_bound写出这个函数。</p><p>虽然原数组不是有序的，但这么想能够给我们带来灵感。</p><p>我们不妨把原数组分成若干块区间，然后对每一块区间进行排序。这就是分块算法。这样，数组在每一块区间内都是有序的。</p><p>于是对于要查询的区间[i, j]所包含的那些完整的区间块，我们采用lower_bound算出cnt值。</p><p>而区间[i, j]两端有一些元素是不在一个完整区间块的，对这些元素逐一检查即可。（反正这部分元素的个数不超过两倍块的长度，所以数量较少，逐一检查OK）</p><h2 id="solution-2-归并树"><a href="#solution-2-归并树" class="headerlink" title="solution 2 (归并树)"></a>solution 2 (归并树)</h2><p>除了使用分块算法算出函数cnt(i, j, x)的值外，我们还可以采用归并树的做法。</p><p>这里的归并树是一种特别的线段树，它完整记录下了归并排序的每一步结果。</p><p>也就是，归并树的每一个结点，维护的是一个vector，这个vector就保存着结点对应区间排序后的结果。</p><p>于是，建树的过程也就是归并排序的过程，只不过每一步merge的时候，要把中间的结果保存在线段树的结点的vector里。</p><p>所以我们计算cnt(i, j, x)的值的时候，用线段树的思想求解即可。</p><p>即，若查询区间与当前结点对应区间无交集，返回0；查询区间完整包含当前结点对应区间在内，则对当前结点的vector采用lower_bound返回结果；否则对线段树左右儿子递归查询，求和即可。</p><h2 id="solution-3-主席树"><a href="#solution-3-主席树" class="headerlink" title="solution 3 (主席树)"></a>solution 3 (主席树)</h2><p>前面两种做法都是采用使数组部分有序后统计cnt值的思想。Solution1 中的部分有序指块数组的部分有序，Solution2中部分有序指线段树维护区间的部分有序。</p><p>而主席树的做法采用完全不一样的思路。</p><p>主席树也是一种特殊的线段树。它不是像Solution2或者往常RMQ问题一样，维护原数组的区间；而是像维护值域的区间。</p><p>就是说，假如这个特殊的线段树的一个结点，维护的区间是[l, r), 记录值为dat，那么dat的意义是原数组中有多少个值位于[l, r)的范围内。</p><p>现在考虑，假设我们已经对要查询的区间[i, j]构造了这样一棵线段树，要查询第k小的值，怎么找？</p><p>其实很简单，从根结点找起，其实根结点对应的区间就是整个值域。考察左儿子的dat值，如果它大于等于k，也就是说有大于等于k个数位于左边的值域，于是我们就对左儿子进行递归查找；否则查找右儿子。直到查找的区间长度为1，那么这个就是答案。</p><p>那么，假如我们对所有O(n^2)个区间都建这样一棵关于值分布的线段树，我们就能对任意区间，查询到第k小的答案了。</p><p>显然，O(n^2)棵线段树是不现实的，根本没有这么多空间。</p><p>用一下前缀和的思想，考虑原数组区间[i, j]对应的线段树，其实它可以由[1, j]和[1, i - 1]两棵线段树的值作差而来。（这里的“作差”就是对线段树每一个结点的dat值求一次差）</p><p>所以我们实际上，只需要n棵线段树即可，n指值域长度。</p><p>但是， O(n)棵线段树仍然不现实，没有这么多空间。</p><p>主席树的巧妙之处就在这里。</p><p>考察第i棵线段树和第i+1棵线段树的区别，也就是原数组区间[1, i]和[1, i + 1]分别对应的线段树。我们发现，后一棵线段树，比前一棵线段树，仅仅多更新了原数组中的一个数，即a[i+1].</p><p>这样一来，两棵线段树仅仅只有从根到a[i+1]对应的叶这一条链是不同了（增加了1），其他结点完全相同。于是我们，只给这更新的一条链创建新结点可以，其他结点沿用旧的线段树的结点即可。</p><p>那么，更新的线段树高度为O(log n)，所以会有O(log n)个结点更新，也就是，这棵线段树实际只占用O(log n)的内存空间，但在逻辑上，它依然是棵完整的线段树。</p><p>另外，对于第零棵线段树，即原数组区间[1, 0]对应的线段树，所有结点dat值都为0，所以这整棵线段树用一个零结点来存就可以。</p><p>这样一来，我们就能够实现，只用了O(nlogn)的内存空间，存放下了n + 1棵线段树（包括第零棵）的信息，因为很多结点都被多棵线段树共享了嘛。</p><p>P.S.其实这种做法与第二种归并树的做法，有异曲同工之妙。归并树是把归并排序的中间结果全部记录下来。而主席树，实际上也是，把更新时的中间结果全部记录下来。对这样一棵表示值分布的线段树，我们依次从左往右拿原数组的值去更新线段树，每一次更新会修改O(log n)个结点，而主席树没有直接修改原树上的O(log n)个结点，而是新建了O(log n)个结点。这样，线段树在动态更新的过程中，每一个历史版本都被完整记录。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><h2 id="solution-1-分块-1"><a href="#solution-1-分块-1" class="headerlink" title="solution 1 (分块)"></a>solution 1 (分块)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100002</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> bucket[maxn / B][B];</span><br><span class="line"><span class="keyword">int</span> a[maxn],nums[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read(), m = read();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">        bucket[i/B][i%B] = a[i];</span><br><span class="line">        nums[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums, nums + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / B; i++) sort(bucket[i], bucket[i] + B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read(); </span><br><span class="line">        <span class="keyword">int</span> ul = <span class="number">0</span>, ur = n;</span><br><span class="line">        <span class="keyword">while</span> (ul + <span class="number">1</span> &lt; ur) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (ul + ur) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, tl = l - <span class="number">1</span>, tr = r; <span class="comment">// the number of items less than nums[mid]</span></span><br><span class="line">            <span class="keyword">while</span> (tl &lt; tr &amp;&amp; tl % B) cnt += (a[tl++] &lt; nums[mid]); </span><br><span class="line">            <span class="keyword">while</span> (tl &lt; tr &amp;&amp; tr % B) cnt += (a[--tr] &lt; nums[mid]);</span><br><span class="line">            <span class="keyword">while</span> (tl &lt; tr) &#123;</span><br><span class="line">                <span class="keyword">int</span> bi = tl / B;</span><br><span class="line">                cnt += lower_bound(bucket[bi], bucket[bi] + B, nums[mid]) - bucket[bi];</span><br><span class="line">                tl += B;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= k) ur = mid;</span><br><span class="line">            <span class="keyword">else</span> ul = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nums[ul]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solution-2-归并树-1"><a href="#solution-2-归并树-1" class="headerlink" title="solution 2 (归并树)"></a>solution 2 (归并树)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n,m,nums[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[maxn * <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        vec[v].push_back(a[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span>, chr = v * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        build(chl, l, mid);</span><br><span class="line">        build(chr, mid, r);</span><br><span class="line">        vec[v].resize(vec[chl].size() + vec[chr].size());</span><br><span class="line">        merge(vec[chl].begin(), vec[chl].end(), vec[chr].begin(), vec[chr].end(), vec[v].begin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> v = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || r &lt;= L || R &lt;= l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = lower_bound(vec[v].begin(), vec[v].end(), x) - vec[v].begin();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, chl = v * <span class="number">2</span>, chr = v * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res= query(L, R, x, chl, l, mid) + query(L, R, x, chr, mid, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(),m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = a[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums, nums + n);</span><br><span class="line">    build();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read();</span><br><span class="line">        l--;</span><br><span class="line">        <span class="keyword">int</span> ul = <span class="number">0</span>, ur = n;</span><br><span class="line">        <span class="keyword">while</span> (ul + <span class="number">1</span> &lt; ur) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (ul + ur) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (query(l, r, nums[mid]) &gt;= k) ur = mid;</span><br><span class="line">            <span class="keyword">else</span> ul = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nums[ul]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solution-3-主席树-1"><a href="#solution-3-主席树-1" class="headerlink" title="solution 3 (主席树)"></a>solution 3 (主席树)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, dat;</span><br><span class="line">    node(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> dat = <span class="number">0</span>):l(l),r(r),dat(dat)&#123;&#125;</span><br><span class="line">&#125;T[maxn * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> rt[maxn], a[maxn], b[maxn], sz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;o, <span class="keyword">int</span> x, <span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// [l, r)</span></span><br><span class="line">    o = ++sz;</span><br><span class="line">    T[o] = T[last];</span><br><span class="line">    T[o].dat++;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; mid) update(T[o].l, x, T[last].l, l, mid);</span><br><span class="line">    <span class="keyword">else</span> update(T[o].r, x, T[last].r, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> t1, <span class="keyword">int</span> t2, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// [l, r)</span></span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> cnt = T[T[t2].l].dat - T[T[t1].l].dat, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= k) <span class="keyword">return</span> query(T[t1].l, T[t2].l, l, mid, k);</span><br><span class="line">    <span class="keyword">return</span> query(T[t1].r, T[t2].r, mid, r, k - cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fill(T, T + maxn * <span class="number">20</span>, node());</span><br><span class="line">    fill(rt, rt + maxn, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> N = read(), Q = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) b[i] = a[i] = read();</span><br><span class="line">    sort(b, b + N);</span><br><span class="line">    <span class="keyword">int</span> n = unique(b, b + N) - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = lower_bound(b, b + n, a[i]) - b;</span><br><span class="line">        update(rt[i + <span class="number">1</span>], a[i], rt[i], <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), k = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[query(rt[l - <span class="number">1</span>], rt[r], <span class="number">0</span>, n, k)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th style="text-align:center">Solution</th><th style="text-align:center">Time(ms)</th><th style="text-align:center">Memory(MB)</th><th style="text-align:center">Code Length</th></tr></thead><tbody><tr><td style="text-align:center">分块</td><td style="text-align:center">11516</td><td style="text-align:center">1.5</td><td style="text-align:center">1337</td></tr><tr><td style="text-align:center">归并树</td><td style="text-align:center">6344</td><td style="text-align:center">37.1</td><td style="text-align:center">1662</td></tr><tr><td style="text-align:center">主席树</td><td style="text-align:center">1735</td><td style="text-align:center">25</td><td style="text-align:center">1469</td></tr></tbody></table><p>最后送上三种解法的耗时，内存占用和代码长度的直观对比。</p><p>分块的实现最简单，代码最短，空间开销也最小，但非常慢，濒临超时。实际上，如果不加读入优化的话，那么分块就超时了。可见，非常凶险。</p><p>完美复现归并排序的归并树显然内存消耗是最高的，因为采用的是和分块一样的思路，也要有两层的二分查找，所以即使使用了线段树，但总耗时也只是节省了一半不到。</p><p>最后一种，主席树的做法，从原理上来讲，最复杂，但同时也最优美。从表中可以看出，时间比归并树快很多，空间开销和代码长度都最小，所以毫无疑问是本题的最佳解法。</p><p>P.S. 有同学可以提供比主席树更好的做法吗？感激不禁。（发现自己能在不同解法的对比中学到更多）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个长度为n的数组，m次查询。每次查询给出三个数（i, j, k），表示要求原数组的区间[i, j]升序排列中的第k个数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="sqrt decomposition" scheme="http://dafenghh.github.io/tags/sqrt-decomposition/"/>
    
      <category term="主席树" scheme="http://dafenghh.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2886 [Who gets the Most Candies] 题解</title>
    <link href="http://dafenghh.github.io/post/63c20c7e.html"/>
    <id>http://dafenghh.github.io/post/63c20c7e.html</id>
    <published>2018-01-10T06:46:27.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>N个孩子围一圈玩游戏， 按顺时针从1到N编号，每个孩子手上有张牌，牌上有个非零数字。给定数字K，一开始第K个孩子走出圈。每个出圈的孩子的牌上的数字将决定下一个出圈孩子是谁。若此时出圈孩子的牌的数字为x，正则往顺时针方向数到第x个孩子，负则逆时针方向数到第|x|个孩子，即为下一个要走出圈的孩子。</p><p>第i个出圈的孩子将获得F[i]个糖果。F[i]定义为正整数i的因数个数。输出获得糖果最多的孩子的名字和糖果数。若有多个答案，则输取出圈最早的孩子作为答案。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>采用取模的方法很容易算出当前需要出圈的是序列中第几个孩子。但这题难在，如果动态、快速地将一个序列中的一项删除呢？</p><p>不妨不存储实际的序列，而只是用一个BIT（树状数组）来表示每个孩子是否在场。</p><p>初始时，1-N的每个点的值都为1，表示每一个孩子都在场。若有一个孩子离场，则将它赋值为0即可。</p><p>很容易想到，若编号为i的孩子在场，那么前缀和sum(i)就表示他现在在队伍中的实际位置。</p><p>所以采用二分法，就可以快速确定队伍中排在第k位的孩子是谁。</p><p>时间复杂度为$O(n\log^2 n)$ n最大为500000，担心超时。但BIT采用lowbit来算的话，时间节省一半，即带上一个1/2的系数。</p><p>那么$0.5\times 500000 \times log_2^2 500000 = 8.96 \times 10^7 $</p><p>所以时间复杂度在可接受的范围内。</p><p>另外，算F[i]时直接用素数筛的方法做一遍预处理即可， O(n log n)的复杂度。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> F[maxn];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i * j &lt; maxn; j++) F[i * j]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bit[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i; i -= lowbit(i)) s += bit[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += lowbit(i)) bit[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kid</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, id;</span><br><span class="line">    kid(<span class="keyword">int</span> p = <span class="number">0</span>, <span class="keyword">int</span> id = <span class="number">0</span>):p(p), id(id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> kid &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (F[p] != F[b.p]) <span class="keyword">return</span> F[p] &lt; F[b.p];</span><br><span class="line">        <span class="keyword">return</span> p &gt; b.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;kid&gt; que;</span><br><span class="line"><span class="keyword">int</span> cards[maxn];</span><br><span class="line"><span class="keyword">char</span> names[maxn][<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">tr</span><span class="params">(ll x, ll n)</span> </span>&#123;</span><br><span class="line">    x += n * <span class="number">100000000L</span>L;</span><br><span class="line">    <span class="keyword">return</span> x % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getP</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum(mid) &lt; k) l = mid; <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> step, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ni = getP(k);</span><br><span class="line">    add(ni, <span class="number">-1</span>);</span><br><span class="line">    que.push(kid(step, ni));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    k += <span class="number">-1</span> + cards[ni];</span><br><span class="line">    <span class="keyword">if</span> (cards[ni] &gt; <span class="number">0</span>) k--;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) k = (<span class="keyword">int</span>)tr(k, n);</span><br><span class="line">    k %= n;</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(priority_queue&lt;kid&gt; &amp;que)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;kid&gt; q1;</span><br><span class="line">    swap(q1, que);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initF();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k) != EOF) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)   <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, names[i], cards + i);</span><br><span class="line">        Clear(que);</span><br><span class="line">        <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) add(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            k = solve(k, i, n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        kid ans = que.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, names[ans.id], F[ans.p]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;N个孩子围一圈玩游戏， 按顺时针从1到N编号，每个孩子手上有张牌，牌上有个非零数字。给定数字K，一开始第K个孩子走出圈。每个出圈的孩子的牌上的数字将决定下一个出圈孩子是谁。若此时出圈孩子的牌的数字为x，正则往顺时针方向数到第x个孩子，负则逆时针方向数到第|x|个孩子，即为下一个要走出圈的孩子。&lt;/p&gt;
&lt;p&gt;第i个出圈的孩子将获得F[i]个糖果。F[i]定义为正整数i的因数个数。输出获得糖果最多的孩子的名字和糖果数。若有多个答案，则输取出圈最早的孩子作为答案。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2155 [Matrix] 题解</title>
    <link href="http://dafenghh.github.io/post/5eb8db9.html"/>
    <id>http://dafenghh.github.io/post/5eb8db9.html</id>
    <published>2018-01-09T14:15:40.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一个N*N的布尔矩阵，初始值全为0，T次询问，两种操作：</p><ol><li>查询某个点的值</li><li>将一个矩形方块的布尔值全部翻转。</li></ol><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>二维BIT的简单题目。一维BIT很容易扩展成二维，直接加多一层循环即可，单次操作复杂度由$O(\log n)$变成$O(\log^2 n)$</p><p>区间更新转化为4个端点的更新即可。</p><p>由于每个点只有两种状态，所以用异或处理非常方便。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1020</span>;</span><br><span class="line"><span class="keyword">int</span> bit[maxn][maxn], n, q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// [1..x, 1..y]</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i))</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &gt; <span class="number">0</span>; j -= lowbit(j))</span><br><span class="line">        res ^= bit[i][j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= n; j += lowbit(j))</span><br><span class="line">        bit[i][j] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    add(x1, y1);</span><br><span class="line">    add(x1, y2 + <span class="number">1</span>);</span><br><span class="line">    add(x2 + <span class="number">1</span>, y1);</span><br><span class="line">    add(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x,y;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(x, y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">                update(x1, y1, x2, y2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;一个N*N的布尔矩阵，初始值全为0，T次询问，两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查询某个点的值&lt;/li&gt;
&lt;li&gt;将一个矩形方块的布尔值全部翻转。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3468 [A Simple Problem with Integers] 题解</title>
    <link href="http://dafenghh.github.io/post/8b465320.html"/>
    <id>http://dafenghh.github.io/post/8b465320.html</id>
    <published>2018-01-09T09:30:31.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出长度为N的数组，Q次询问，每次询问有两种操作：</p><ol><li>查询某个区间的和。</li><li>将某个区间的数全部加上x。</li></ol><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>要同时支持区间更新和区间查询（求和）两种操作，考虑树状数组。</p><p>但我们知道，树状数组只支持区间查询和点更新，或者区间更新和点查询。怎么样才能做到同时更新区间以及对区间求和呢？</p><p>我们先来考察区间更新后，前缀和的增量。记前缀和为S(i)，更新区间[l,r]后前缀和为S’(i).</p><p>$$\begin{eqnarray}S’(i)= \begin{cases} S(i), &amp;i<l\cr s(i)="" +="" x(i-l+1),="" &l\leqslant="" i\leqslant="" r="" \cr="" s(i)+x(r-l+1),="" &i="">r\end{cases} \end{eqnarray} $$</l\cr></p><p>留意到i<l时，增量为0，无需处理；i>r时，增量为常数，像普通BIT那样进行一次点更新即可。</l时，增量为0，无需处理；i></p><p>难就难在， $l\leqslant i\leqslant r$时，增量是一个关于i的一次函数。</p><p>如前面所说，普通BIT进行一次点更新只能导致前缀和增加一个常数。既然如此，我们把上面这个一次函数的增量拆成两项，用两个BIT维护：</p><p>$$\Delta S(i)=xi + x(1-l) $$<br>一次项系数为x，常数项为x(1-l)，分别对应BIT1和BIT0的增量值。</p><p>这样，记BIT0前缀和为s0，BIT1前缀和为s1，则总的前缀和就是<code>s0 + s1 * x</code></p><p>用前缀和来表示原数组的每一个值，然后区间求和就可转化为左右端点的前缀和差值，即点查询+区间更新的模式。</p><p>然后，更新的时候，分别对BIT0和BIT1进行区间更新即可（实质上是更新两个端点）。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line">ll bit[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll s0 = <span class="number">0</span>, s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) s0 += bit[<span class="number">0</span>][i], s1 += bit[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">return</span> s0 + s1 * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> x, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) bit[ti][i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll val)</span> </span>&#123; <span class="comment">// [l, r]</span></span><br><span class="line">    add(<span class="number">0</span>, l, val * (<span class="number">1</span> - l));</span><br><span class="line">    add(<span class="number">1</span>, l, val);</span><br><span class="line">    add(<span class="number">0</span>, r + <span class="number">1</span>, val * r);</span><br><span class="line">    add(<span class="number">1</span>, r + <span class="number">1</span>, -val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        update(i, i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> l, r, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, s, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum(r) - sum(l - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            update(l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给出长度为N的数组，Q次询问，每次询问有两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查询某个区间的和。&lt;/li&gt;
&lt;li&gt;将某个区间的数全部加上x。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>ZOJ 4003 [Distance] 题解</title>
    <link href="http://dafenghh.github.io/post/6c754de8.html"/>
    <id>http://dafenghh.github.io/post/6c754de8.html</id>
    <published>2018-01-09T05:05:12.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>定义两个维度为n的向量 $(a_1,a_2,a_3\dots a_n)$ 和 $(b_1,b_2,b_3\dots b<em>n)$ 间的距离为 $\sum </em>{i=1} ^n \left | a_i - b_i \right |^p$</p><p>现在给出向量$X = (x_1, x_2, x_3 \dots x_n)$ 和 $Y = (y_1, y_2, y_3 \dots y_n)$</p><p>定义子向量（subvector）为原向量的项中连续的一段。从X中取出一个子向量x, 从Y中取出一个子向量y，使得x和y长度相同，x和y的<br>距离小于给定值V。求这样的子向量对(x, y)的个数。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>作一个n*n的矩阵<code>diff[][]</code>，记录X中的每一项到Y中的每一项的距离，</p><p>即 <code>diff[i][j] = |X[i] - Y[j]| ^ p</code></p><p>取出这个矩阵的每一条斜线的值，用尺取法统计结果即可。</p><p>P.S. 写这题时犯了很多智障错误。如%d写成%p，return res写成return x。</p><p>诸如此类。</p><p>如何避免这类typo的发生呢？</p><p>这是一个问题。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y--) res *= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(ll a[], <span class="keyword">int</span> n, ll V)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) &#123;</span><br><span class="line">        r = max(r, l);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; sum + a[r] &lt;= V) &#123;</span><br><span class="line">            sum += a[r];</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += r - l;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; l) sum -= a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1003</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn];</span><br><span class="line">ll diff[maxn][maxn],diag[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs_</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, p;</span><br><span class="line">        ll V;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld%d"</span>, &amp;n, &amp;V, &amp;p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, x + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, y + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            diff[i][j] = Pow(abs_(x[i] - y[j]), p);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> di = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> xi = <span class="number">0</span>, yi = i; xi &lt; n &amp;&amp; yi &lt; n; xi++, yi++)</span><br><span class="line">                diag[di++] = diff[xi][yi];</span><br><span class="line">           </span><br><span class="line">            ans += count(diag, di, V);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> di = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> xi = i, yi = <span class="number">0</span>; xi &lt; n &amp;&amp; yi &lt; n; xi++, yi++)</span><br><span class="line">                diag[di++] = diff[xi][yi];</span><br><span class="line">           </span><br><span class="line">            ans += count(diag, di, V);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;定义两个维度为n的向量 $(a_1,a_2,a_3\dots a_n)$ 和 $(b_1,b_2,b_3\dots b&lt;em&gt;n)$ 间的距离为 $\sum &lt;/em&gt;{i=1} ^n \left | a_i - b_i \right |^p$&lt;/p&gt;
&lt;p&gt;现在给出向量$X = (x_1, x_2, x_3 \dots x_n)$ 和 $Y = (y_1, y_2, y_3 \dots y_n)$&lt;/p&gt;
&lt;p&gt;定义子向量（subvector）为原向量的项中连续的一段。从X中取出一个子向量x, 从Y中取出一个子向量y，使得x和y长度相同，x和y的&lt;br&gt;距离小于给定值V。求这样的子向量对(x, y)的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="尺取法" scheme="http://dafenghh.github.io/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3109 [Inner Vertices] 题解</title>
    <link href="http://dafenghh.github.io/post/c38b5f65.html"/>
    <id>http://dafenghh.github.io/post/c38b5f65.html</id>
    <published>2018-01-05T08:17:54.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一个无限大的棋盘，给出N个点的坐标，初始时这些点上都放置着黑棋。其他所有点放置着白棋。若一个白棋的上下左右方向上都有黑棋，那么它会被替换成黑棋。求最终黑棋的数量。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>与cf 911G如出一辙的扫描线算法。</p><p>将所有点按y坐标排序后（y相同时按x排序），我们可以依次统计，相邻的两个y坐标相同的点之间的白点对答案的贡献。</p><p>假设这两个点为(x1, y0) (x2, y0) 那么我们要算的就是${(x, y) | x \in [x1 + 1, x2 - 1], y = y0}$的范围内有多少个<br>白棋变成了黑棋。</p><p>对于此范围中的一个点(xx, yy)，这一个点变成黑棋的充要条件是，(xx, yy)的上方和下方还有别的黑棋。</p><p>假设在原黑棋的点集合中，当x = xx时，y的最大、最小值分别为Max, Min。那么上面这个充要条件就可以表示为Min &lt; y &lt; Max.</p><p>我们很容易想到，当访问到y = yy的最低点也即(xx, Min)时，给x加上标记（表示此条线x == xx上的点将可能变黑）, 当访问到最高点即(xx, Max)时，给x消除标记（表示此条线x == xx上的点将不再会变黑）。</p><p>用BIT快速统计出区间[x1 + 1, x2 - 1]上会变黑的点的数量, 本题完成。</p><p>P.S. 这题做得也挺尴尬的，一开始写的扫描线算法还要统计出对每个x、y对应的y、x的极值，然后用很累赘的方法打标记，用了很多次vector，导致TLE。后来把vector全部去掉，全部换成数组才过。</p><p>感谢此篇博文<a href="http://blog.csdn.net/lolicon480/article/details/44183397" target="_blank" rel="noopener">by lolicon480</a> 提供的思路！</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">200010</span>;</span><br><span class="line">ll cnt = <span class="number">200020</span>;</span><br><span class="line">ll bit[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maxi</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lowbit</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll i)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i -= lowbit(i)) res += bit[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll i, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= cnt; i += lowbit(i)) bit[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    P(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>):x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(<span class="keyword">const</span> P&amp;a, <span class="keyword">const</span> P&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x != b.x) <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(<span class="keyword">const</span> P&amp;a, <span class="keyword">const</span> P&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.y != b.y) <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mx[maxn];</span><br><span class="line"><span class="keyword">bool</span> sc[maxn]; <span class="comment">// scope</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    sort(a, a + n, cmpx);</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i].x;</span><br><span class="line">        a[i].x = val;</span><br><span class="line">        <span class="keyword">if</span> (temp != a[i + <span class="number">1</span>].x) val++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + n, cmpy);</span><br><span class="line">    val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i].y;</span><br><span class="line">        a[i].y = val;</span><br><span class="line">        <span class="keyword">if</span> (temp != a[i + <span class="number">1</span>].y) val++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        Maxi(mx[a[i].x], a[i].y);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[i].x, y = a[i].y, nx = a[i + <span class="number">1</span>].x, ny = a[i + <span class="number">1</span>].y;</span><br><span class="line">        <span class="keyword">if</span> (!sc[x] &amp;&amp; y &lt; mx[x]) &#123;</span><br><span class="line">            sc[x] = <span class="literal">true</span>;</span><br><span class="line">            add(x, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y == ny &amp;&amp; nx &gt; x + <span class="number">1</span>) &#123;</span><br><span class="line">            ans += sum(nx - <span class="number">1</span>) - sum(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sc[x] &amp;&amp; y == mx[x]) &#123;</span><br><span class="line">            sc[x] = <span class="literal">false</span>;</span><br><span class="line">            add(x, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;一个无限大的棋盘，给出N个点的坐标，初始时这些点上都放置着黑棋。其他所有点放置着白棋。若一个白棋的上下左右方向上都有黑棋，那么它会被替换成黑棋。求最终黑棋的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="scanline" scheme="http://dafenghh.github.io/tags/scanline/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1990 [MooFest] 题解</title>
    <link href="http://dafenghh.github.io/post/a0a6f15.html"/>
    <id>http://dafenghh.github.io/post/a0a6f15.html</id>
    <published>2017-12-30T16:23:57.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>N头牛排成一排，现在给出它们的坐标x[i]和听觉阈值v[i]. 两头牛i和j之间谈话的音量为<code>max(v[i], v[j]) * dist(i, j)</code> dist表示两者距离。求所有N*(N-1)对牛谈话音量的总和。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>按v[i]降序排序。然后用BIT求出每一头牛和后面的牛的距离的和即可。（我用了两个BIT，一个维护累计和，一个维护个数）</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20200</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll bit[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i; i -= lowbit(i)) &#123;</span><br><span class="line">        res += bit[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">        bit[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll bit2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i; i -= lowbit(i)) &#123;</span><br><span class="line">        res += bit2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> i, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">        bit2[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cow</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, x;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> cow &amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; b.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].v, &amp;a[i].x), add(a[i].x, a[i].x), add2(a[i].x, <span class="number">1</span>);</span><br><span class="line">    sort(a, a + N);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        add(a[i].x, -a[i].x);</span><br><span class="line">        add2(a[i].x, <span class="number">-1</span>);</span><br><span class="line">        ll dist_tot = sum2(a[i].x) * a[i].x - sum(a[i].x) + sum(n) - sum(a[i].x) - (sum2(n) - sum2(a[i].x)) * a[i].x;</span><br><span class="line">        ans += dist_tot * a[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;N头牛排成一排，现在给出它们的坐标x[i]和听觉阈值v[i]. 两头牛i和j之间谈话的音量为&lt;code&gt;max(v[i], v[j]) * dist(i, j)&lt;/code&gt; dist表示两者距离。求所有N*(N-1)对牛谈话音量的总和。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="BIT" scheme="http://dafenghh.github.io/tags/BIT/"/>
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 911G [Mass Change Queries] # educational round 35 题解</title>
    <link href="http://dafenghh.github.io/post/360e2773.html"/>
    <id>http://dafenghh.github.io/post/360e2773.html</id>
    <published>2017-12-30T13:20:40.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个数组a，长度为n，q次操作，每次操作给定四个整数，l,r,x,y表示将[l, r]区间中的值为x元素全部变成y，输出最终数组。</p><p>数据范围：<code>n, q &lt;= 200000, a[i], x, y &lt;= 100</code> </p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>educational round的最后一题，本来以为非常难，看了<a href="http://codeforces.com/contest/911/submission/33740346" target="_blank" rel="noopener">pannibal</a> 的代码后，非常惊奇。这道题竟能如此简洁优美地解决。于是关掉网页，用自己的代码习惯重打一遍（当然大部分雷同哈哈，毕竟这个解法真的太简洁了）。</p><p>总结一下思路：</p><ol><li><p>本题的难点在于每次操作，需要更新[l, r]的整段区间。如果直接更新，复杂度将是<code>O(nq)</code> ，不可接受。</p><p> 我们采用类似于用前缀和快速查询区间和的思想，讲区间转化为两个端点处理，即在区间开始处l打上一个标记，表示从这里开始，x将被视作y ，再在区间结束后的r+1处打上标记，表示还原x的状态（将x重新视为x）。</p><p> 或者说，这个修改操作包含两个修改，(1) [l, +inf)区间的x变成y; (2) [r+1, +inf)区间的x变回x.</p></li><li><p>另外，修改的顺序也是很重要的。我们将所有修改按照点的标记位置存在vector里。见main函数代码: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec[l].push_back(Change(t, x, y));</span><br><span class="line">vec[r + 1].push_back(Change(t, x, x));</span><br></pre></td></tr></table></figure><p> 其中t表示修改的顺序。这样一来，我们相当于将所有修改按点的位置重新排序。这么做有什么好处吗？其实，这就是这道题的关键转化步骤。</p><p> 作为一个经验尚浅的ACM选手，我对这题的直觉思路是依次考虑每次修改操作，寻找一种快速的更新区间方法。但注意到这道题只需要一个最终的结果，对中间结果并不关心。所以我们可以采用离线做法，不必完全跟从修改的次序来求解。</p><p> 那么我们采用怎样的求解次序呢？</p><p> 按数组下标依次求解最终结果。这也是很自然的思路，假如我们要求a[x]的最终结果，那么所有在x之后的点的更新对a[x]的值毫无影响。所以我们在输入完成后，依次拿出vec[i]的修改操作，来修改[i, +inf)这个区间. 这样在i后移的同时，我们就能依次得到a[i]的最终结果。</p></li><li><p>下面讨论如果实现每次修改操作。</p><p> 比如现在我们要把x的值变成y，是不是要找出数组中所有的x，然后依次赋值成y呢？显然时间不允许这么做。</p><p> 我们只需要存一份转移表（transition table）即可。一开始所有数字无变化，对所有的i， 有<code>T[i] = i</code>。 当我们将x修改成y时，修改T[x] = y;</p><p> 如果这样一份转移表被构造出来，那么我们要求<code>a[i]</code>的最终结果就很简单了，那就是<code>T[a[i]]</code></p><p> 但转移表既随时间（修改次序）变化，也随区间变化，即受两个维度影响，t维度（修改次序）和i维度（数组下标）。留意到，刚刚第2点说到，我们沿着i维度来提交修改。那么不妨，我们固定t维度，或称，保留下t维度的所有状态，即对每一个修改的时刻构造一张转移表。这道题最多200000次查询，也就是200000张转移表。</p><p> 比如我们在时刻t = 5和t = 6分别做了一次修改，得到两个转移表T_5, T_6, 很明显将T_5, T_6的转移表合并（合并的过程非常简单，相当于函数的组合）,就是这两次修改的最终效果。</p><p> 我们将所有转移表合并后得到的就是最终结果需要的转移表。而在i维度（数组下标）更新的过程中，我们需要快速地修改某些转移表，并将修改结果合并起来，得到a[i]的最终值。</p><p> 于是，线段树呼之欲出！线段树的每个叶子结点就代表一个时刻的转移表，它们的父结点就是合并后的转移表。对特定的x，所有修改合并操作都能在<code>O(log n)</code>时间内完成了。合并也只需要一条代码： <code>seg[t][i] = seg[chr][seg[chl][i]]</code></p><p> 解法非常简洁优美！</p></li></ol><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, x, y;</span><br><span class="line">    Change(<span class="keyword">int</span> t, <span class="keyword">int</span> x, <span class="keyword">int</span> y):t(t),x(x),y(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Change&gt; vec[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn], seg[maxn * <span class="number">2</span> + <span class="number">20</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAll</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, seg[<span class="number">1</span>][i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    seg[t += maxn][x] = y;</span><br><span class="line">    <span class="keyword">for</span> (t &gt;&gt;= <span class="number">1</span>; t; t &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> chl = t &lt;&lt; <span class="number">1</span>, chr = chl | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            seg[t][i] = seg[chr][seg[chl][i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt; maxn * <span class="number">2</span> + <span class="number">20</span>; t++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        seg[t][i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'-'</span>) flag=<span class="number">-1</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        ans=ans*<span class="number">10</span>+(<span class="keyword">int</span>)(c-<span class="string">'0'</span>);</span><br><span class="line">        c=getchar(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans*flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = get(), q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = get();</span><br><span class="line">    q = get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= q; t++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = get(), r = get(), x = get(), y = get();</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            vec[l].push_back(Change(t, x, y));</span><br><span class="line">            vec[r + <span class="number">1</span>].push_back(Change(t, x, x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cg: vec[i]) update(cg.t, cg.x, cg.y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, seg[<span class="number">1</span>][a[i]], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个数组a，长度为n，q次操作，每次操作给定四个整数，l,r,x,y表示将[l, r]区间中的值为x元素全部变成y，输出最终数组。&lt;/p&gt;
&lt;p&gt;数据范围：&lt;code&gt;n, q &amp;lt;= 200000, a[i], x, y &amp;lt;= 100&lt;/code&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="scanline" scheme="http://dafenghh.github.io/tags/scanline/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 908F [New Year and Rainbow Roads] (good bye 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/8234636.html"/>
    <id>http://dafenghh.github.io/post/8234636.html</id>
    <published>2017-12-30T07:05:48.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一维直线上的N个点，每个点有一个颜色标记（红、绿、蓝），现在要连边，一条边的代价为两点距离。现求最小总代价，使红、绿点连通，并且蓝、绿点连通。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>考虑到，红、蓝点连线并无意义，所以可忽略；另外考虑假如出现了连续三个点，颜色分别为红绿红，那么红和红之间连线一定不必红-绿-红这样连线优。所以，以绿点为分割点，分成若干个区间单独考虑即可。</p><p>对于两个连续的绿点之间的区间，有两种连线方式：（1）连接两个绿点，再以从这两个绿点为端点，连出两条线，分别连接中间的红点和蓝点，接着分别去掉这两条线的最长一个区间；（2）直接从这两个绿点为端点，连出两条线，分别连接中间的红点和蓝点。</p><p>分别统计两种连线方式的代价，选最优即可。</p><p>代码写得很丑，要看漂亮代码请戳这：<a href="http://codeforces.com/contest/908/submission/33789715" target="_blank" rel="noopener">by aaaaajack</a></p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; v0, v1, v2;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v.empty()) <span class="keyword">return</span>;</span><br><span class="line">    ans += max(<span class="number">0L</span>L, v0.front() - v.front()) + max(<span class="number">0L</span>L, v.back() - v0.back());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt;::<span class="function">iterator <span class="title">LB</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;v, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(v.begin(), v.end(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll l, ll r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LB(v1, l) == LB(v1, r) &amp;&amp; LB(v2, l) == LB(v2, r)) <span class="keyword">return</span> r - l;</span><br><span class="line">    ll x = l, max_interval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = LB(v1, l); it != v1.end() &amp;&amp; (*it) &lt; r; it++) &#123;</span><br><span class="line">        max_interval = max(max_interval, (*it) - x);</span><br><span class="line">        x = *it;</span><br><span class="line">    &#125;</span><br><span class="line">    max_interval = max(max_interval, r - x);</span><br><span class="line">    ll ans1 = <span class="number">3</span> * (r - l) - max_interval;</span><br><span class="line">    x = l; max_interval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = LB(v2, l); it != v2.end() &amp;&amp; (*it) &lt; r; it++) &#123;</span><br><span class="line">        max_interval = max(max_interval, (*it) - x);</span><br><span class="line">        x = *it;</span><br><span class="line">    &#125;</span><br><span class="line">    max_interval = max(max_interval, r - x);</span><br><span class="line">    ans1 -= max_interval;</span><br><span class="line">    <span class="keyword">return</span> min(ans1, <span class="number">2</span> * (r - l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'G'</span>) v0.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'B'</span>) v1.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> v2.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (v0.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v1.empty()) ans += v1.back() - v1.front();</span><br><span class="line">        <span class="keyword">if</span> (!v2.empty()) ans += v2.back() - v2.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        add(v1);</span><br><span class="line">        add(v2);</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; v0.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans += calc(v0[i], v0[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一维直线上的N个点，每个点有一个颜色标记（红、绿、蓝），现在要连边，一条边的代价为两点距离。现求最小总代价，使红、绿点连通，并且蓝、绿点连通。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="greedy" scheme="http://dafenghh.github.io/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 343D [Water Tree] 题解</title>
    <link href="http://dafenghh.github.io/post/a28d78f2.html"/>
    <id>http://dafenghh.github.io/post/a28d78f2.html</id>
    <published>2017-12-30T06:26:56.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一棵树，可以进行以下三种操作：</p><ol><li>选择一个结点v，使v对应的子树全部充满水。</li><li>选择一个结点v，除去v和v所有的祖先的水。</li><li>选择一个结点v，查询v是否有水。</li></ol><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>看完《挑战程序设计竞赛》的线段树章节后，搜了下codeforces的线段树题目来做，然后就搜到这题。这题做了很长时间哎，而且犯了不少很囧的错误。</p><p>首先看错了题，以为第二种操作是除去子树的水，所以很轻巧的敲了个BIT，跑起来不对才发现自己弄错了题意……</p><p>于是删掉代码重写。想到要更新所有祖先结点，岂不是要用树链剖分？参考了下cf的Tutorial，原来使用一个很巧妙的转化，就能变成普通的线段树问题。</p><p>我思考这题的时候，总是想着加水就是染成1，去水就是染成0，所以这两个操作分别对应子树的更新和路径的更新，这么做起来就很麻烦。Tutorial将思路倒转一下，便是去水只需要在v（最末端结点）上打个标记，加水是将子树上的所有标记去掉，查询某点是否有水是看这个点对应子树是否有标记，只要有一个标记，说明这点没水；没标记才表示有水。</p><p>而初始状态，我们将所有叶子结点打上标记，就可表示全没水的状态。</p><p>这样一来，确定dfs序之后，找出每个结点对应子树区间[L,R], 然后使用std::set即可实现这个算法，还很简单，都不需要线段树了。</p><p>cf上的前排代码求dfs时，将<code>R[v] = cnt + 1</code>写成<code>R[v] = ++cnt</code></p><p>我一开始很疑惑，这样写有什么区别，因为++后，就相当于对每个子树在末端新建了个虚拟的占位位置。</p><p>其实没区别。只是前排代码这么写，那么这一句<code>S.erase(S.lower_bound(L[v]), S.lower_bound(R[v]))</code> 的后半部分<code>S.lower_bound(R[v])</code>既可以用<code>lower_bound</code>, 又可以用<code>upper_bound</code>, 我的代码就只能用<code>lower_bound</code></p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> L[maxn], R[maxn], fa[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt,n ,q;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> par = <span class="number">-1</span>)</span> </span>&#123;</span><br><span class="line">    L[v] = ++cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i:G[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != par) &#123;</span><br><span class="line">            fa[i] = v;dfs(i, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    R[v] = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (R[v] == L[v] + <span class="number">1</span>) S.insert(L[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = S.lower_bound(L[v]);</span><br><span class="line">    <span class="keyword">return</span> it != S.end() &amp;&amp; (*it) &lt; R[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        G[x].push_back(y);</span><br><span class="line">        G[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;c, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">3</span>) <span class="built_in">puts</span>((empty(v) ? <span class="string">"0"</span> : <span class="string">"1"</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[v] &amp;&amp; empty(fa[v])) S.insert(L[fa[v]]);</span><br><span class="line">            S.erase(S.lower_bound(L[v]), S.lower_bound(R[v]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> S.insert(L[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一棵树，可以进行以下三种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择一个结点v，使v对应的子树全部充满水。&lt;/li&gt;
&lt;li&gt;选择一个结点v，除去v和v所有的祖先的水。&lt;/li&gt;
&lt;li&gt;选择一个结点v，查询v是否有水。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="trees" scheme="http://dafenghh.github.io/tags/trees/"/>
    
      <category term="dfs and similar" scheme="http://dafenghh.github.io/tags/dfs-and-similar/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3264 [Balance Lineup] 题解</title>
    <link href="http://dafenghh.github.io/post/de36ffa1.html"/>
    <id>http://dafenghh.github.io/post/de36ffa1.html</id>
    <published>2017-12-29T12:56:34.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>长度为N的数组，Q次查询，查询区间[A, B]的最大值与最小值之差。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>线段树模板题。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1234567</span>;</span><br><span class="line"><span class="keyword">int</span> mx[<span class="number">2</span> * maxn], lx[<span class="number">2</span> * maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123; <span class="comment">// a[x] = y;</span></span><br><span class="line">   <span class="comment">// printf("v = %d, l = %d, r = %d\n", v, l, r);</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || x &lt; l || x &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        mx[v] = lx[v] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        update(x, y, chl, l, mid);</span><br><span class="line">        update(x, y, chr, mid, r);</span><br><span class="line">        mx[v] = max(mx[chl], mx[chr]);</span><br><span class="line">        lx[v] = min(lx[chl], lx[chr]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || R &lt;= l || L &gt;= r) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> mx[v];</span><br><span class="line">    <span class="keyword">int</span> chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> max(queryMax(L, R, chl, l, mid), queryMax(L, R, chr, mid, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || R &lt;= l || L &gt;= r) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> lx[v];</span><br><span class="line">    <span class="keyword">int</span> chl = v * <span class="number">2</span> + <span class="number">1</span>, chr = v * <span class="number">2</span> + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> min(queryMin(L, R, chl, l, mid), queryMin(L, R, chr, mid, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    fill(mx, mx + <span class="number">2</span> * maxn, -INF);</span><br><span class="line">    fill(lx, lx + <span class="number">2</span> * maxn, INF);</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y);</span><br><span class="line">        update(i, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> A, B;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B);</span><br><span class="line">        <span class="keyword">int</span> L = A - <span class="number">1</span>, R = B;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, queryMax(L, R) - queryMin(L, R));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;长度为N的数组，Q次查询，查询区间[A, B]的最大值与最小值之差。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="trees" scheme="http://dafenghh.github.io/tags/trees/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2991 [Crane] 题解</title>
    <link href="http://dafenghh.github.io/post/a9a98564.html"/>
    <id>http://dafenghh.github.io/post/a9a98564.html</id>
    <published>2017-12-29T11:03:22.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>N条线段首尾相连，初始时全都垂直于x轴呈一直线。标号从下往上，1到N。C次询问，每次询问给出S和A，将第S条线段和第S+1条线段的角度修改成A，角度指的是从S开始沿逆时针方向旋转到S+1经过的角度。求每次询问时第N条线段的末端点坐标。</p><a id="more"></a><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>《挑战程序设计竞赛》P170 例题，线段树的经典应用，很启发思维！</p><p>如何转化成线段树问题呢？</p><p>其实也是一种分治的思想。用v(i,j)表示第i条线段的始点到第j条线段的终点的向量，那么题目要求的就是每次更新后的v(1, n)<br>如何求得v(1, n)呢？分而治之，将区间折半，v(1, n) = v(1, n / 2) + v(n / 2 + 1, n),。</p><p>如果我们旋转第i条线段，那么显然i到n的线段坐标都要变化。这样一来，我们就需要对这所有的点更新坐标一次，很明显效率是不足够的。</p><p>我们需要将旋转的特征提取出来，在上面这个例子中，(i..n)的点的相对位置是不变的，只是整体发生了旋转。</p><p>所以，我们可以只记录一个整体旋转的角度$\alpha$ （相对于竖直方向的角度增量，逆时针为正），外加修改原来v(i, j)的定义，变成将第i条线段旋转至与地面垂直的时候，第i条线段的始点到第j条线段的终点的向量。</p><p>这样一来，我们求v(i,j)的实际值时，乘上$\alpha$对应的旋转变换矩阵即可：<br>\begin{bmatrix} \cos \alpha &amp; -\sin \alpha\\ \sin \alpha &amp; \cos \alpha \end{bmatrix}</p><p>所以构造这样一棵线段树，每个结点表示一段连续的线段区间，维护这两个值：</p><p>将线段区间的第一条线段旋转至垂直方向后，第一条线段的起点到最后一条线段的终点的向量 (v[i])<br>两个儿子连接后，右儿子需要旋转的角度 (ang[i])<br>记第i个结点的左右儿子结点为chl,chr，那么<br>v[i] = v[chl] + M(ang[i]) * v[chr]</p><p>P.S. WA了几发，原因是：当更新角度的线段s在当前区间mid之前时，我没有更新当前区间的ang值。后来发现，区间ang值的增量跟线段s角度增量一致。其实这个也很好理解（理解不了在图上画个三角形来旋转也能证明出来），因为旋转变换其实是对整个坐标系旋转，所以点旋转的是相同角度，向量旋转也是相同角度（注意平移变换不改变角度）。</p><p>P.S. 这题POJ有坑，输出格式是假的，样例中间不用加空行。</p><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">double</span> vx[<span class="number">2</span> * maxn], vy[<span class="number">2</span> * maxn], ang[<span class="number">2</span> * maxn], prv[maxn];</span><br><span class="line"><span class="keyword">int</span> len[maxn];</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">// [l, r]</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    ang[v] = <span class="number">0</span>;</span><br><span class="line">    vx[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        vy[v] = len[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> chl = <span class="number">2</span> * v + <span class="number">1</span>, chr = <span class="number">2</span> * v + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    init(chl, l, mid);</span><br><span class="line">    init(chr, mid, r);</span><br><span class="line">    vy[v] = vy[chl] + vy[chr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">double</span> a, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// angle changes a</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= l ||s &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> chl = <span class="number">2</span> * v + <span class="number">1</span>, chr = <span class="number">2</span> * v + <span class="number">2</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    update(s, a, chl, l, mid);</span><br><span class="line">    update(s, a, chr, mid, r);</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= mid) ang[v] += a;</span><br><span class="line">    <span class="keyword">double</span> Co = <span class="built_in">cos</span>(ang[v]), Si = <span class="built_in">sin</span>(ang[v]);</span><br><span class="line">    vx[v] = vx[chl] + Co * vx[chr] - Si * vy[chr];</span><br><span class="line">    vy[v] = vy[chl] + Si * vx[chr] + Co * vy[chr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q)!=EOF) &#123;</span><br><span class="line">        testcnt++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, len + i);</span><br><span class="line">        init(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) prv[i] = PI;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="keyword">int</span> s, angle_360;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;angle_360);</span><br><span class="line">            <span class="keyword">double</span> a = (<span class="keyword">double</span>)angle_360 / <span class="number">180</span> * PI;</span><br><span class="line">            update(s, a - prv[s], <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">            prv[s] = a;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf %.2lf\n"</span>, vx[<span class="number">0</span>], vy[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;N条线段首尾相连，初始时全都垂直于x轴呈一直线。标号从下往上，1到N。C次询问，每次询问给出S和A，将第S条线段和第S+1条线段的角度修改成A，角度指的是从S开始沿逆时针方向旋转到S+1经过的角度。求每次询问时第N条线段的末端点坐标。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
      <category term="segment tree" scheme="http://dafenghh.github.io/tags/segment-tree/"/>
    
      <category term="geometry" scheme="http://dafenghh.github.io/tags/geometry/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2785 [4 Values whose Sum is 0] 题解</title>
    <link href="http://dafenghh.github.io/post/5396864a.html"/>
    <id>http://dafenghh.github.io/post/5396864a.html</id>
    <published>2017-11-30T14:45:20.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>大小都为N的四个数组<code>A[], B[], C[], D[]</code>, 从每个数组中分别选出一个数，<code>a, b, c, d</code> , 使得 <code>a + b + c + d = 0</code>，问有多少种选择方式。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>《挑战程序设计竞赛》P160例题。《挑战》通过这道题介绍了重要的思想方法，即“折半枚举”的方法，将问题一拆为二进行枚举。</p><p>枚举出<code>A[i]+B[j]</code>的所有可能值和<code>C[i]+D[j]</code>的所有可能值, 之后用二分查找互为相反数的两个值的组数即可。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4200</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn], d[maxn];</span><br><span class="line"><span class="keyword">int</span> ab[maxn * maxn], cd[maxn * maxn];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i] &gt;&gt; d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        ab[i * n + j] = a[i] + b[j], cd[i * n + j] = c[i] + d[j];</span><br><span class="line">    sort(cd, cd + n * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * n; i++)</span><br><span class="line">        ans += upper_bound(cd, cd + n * n, -ab[i]) - lower_bound(cd, cd + n * n, -ab[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;大小都为N的四个数组&lt;code&gt;A[], B[], C[], D[]&lt;/code&gt;, 从每个数组中分别选出一个数，&lt;code&gt;a, b, c, d&lt;/code&gt; , 使得 &lt;code&gt;a + b + c + d = 0&lt;/code&gt;，问有多少种选择方式。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3684 [Physics Experiment] 题解</title>
    <link href="http://dafenghh.github.io/post/d839a1f6.html"/>
    <id>http://dafenghh.github.io/post/d839a1f6.html</id>
    <published>2017-11-30T07:30:55.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>N个半径为R厘米的球竖直叠放在H米的高度上。实验开始时释放最下面的第一个球，1s后释放最下面的第二个球，1s后释放第三个球……一次类推。求T秒时每个球底端的高度。所有碰撞都是弹性碰撞， g取10 m/s^2</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这题的转化非常巧妙。</p><p>首先观察到很重要的一点，所有球的顺序在碰撞过程中都是不变的。很明显最下面一个球永远会在最下面，最上面一个球永远在最上面……这个很显然的结论将会给我们下面的转化过程带来帮助。</p><p>考虑两个球碰撞时的情形，根据物理知识，我们知道碰撞时的两个球的速度一定大小相同，方向相反。碰撞后交换速度。</p><p>这时候我们可以将两个球互相弹回的过程视作两个球“穿过了对方”而继续运动。在穿过的这个瞬间，球的速度没有变化，但下面的球高度获得2R的增量，上面的球高度获得-2R的增量。</p><p>然后，最关键的一步转化来了。</p><p>如果我们修改每个球的高度的定义，将每个球的高度h[i]定义为<code>实际高度-2*i*R</code> （球的坐标分别为0..N-1, 从下往上），这样会发生什么？</p><p>首先在初始时刻，所有的球的高度h[i]都是H。</p><p>然后我们再来看两个球碰撞的过程，碰撞时“穿过了对方”也就是“带着自己的速度到了对方的位置”。</p><p>这样想的话，我们就相当于交换了两个相邻的球的顺序，与一开始我们的结论“所有球的顺序一直不变有点矛盾”。</p><p>我们加多一层转化，就是将碰撞过程视作“带着自己的速度到了对方的位置，并变成了对方”。比如i和i+1碰撞，我们看作，i保持着自己的速度瞬间跳转i+1的位置，并变成了i+1；i+1同理。</p><p>i变成i+1的话，高度的定义也发生了改变，从<code>实际高度-2*i*R</code> 变成 <code>实际高度-2*(i+1)*R]</code>， 与实际高度的差值加多了一个2R, 另外这个过程里，i也会获得2R高度的增量，所以两部分抵消，h高度值完全没有变化。</p><p>这么一来，问题就变成，N个球相隔1s依次从高度H开始下落，求T秒后各球高度。另外我们要还原成实际高度，将高度排序后从下往上依次加上<code>2*i*R</code>即可.</p><p>就这样完美转化成一道简单物理题。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> g = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> h, <span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t0 = <span class="built_in">sqrt</span>(<span class="number">2</span> * h / g);</span><br><span class="line">    t -= <span class="number">2</span> * t0 * ((<span class="keyword">int</span>)(t / (<span class="number">2</span> * t0)));</span><br><span class="line">    <span class="keyword">if</span> (t &gt; t0) t = <span class="number">2</span> * t0 - t;</span><br><span class="line">    <span class="keyword">return</span> h - <span class="number">0.5</span> * g * t * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">double</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Test;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Test);</span><br><span class="line">    <span class="keyword">while</span> (Test--)&#123;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> H, R, T;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lf%lf%lf"</span>, &amp;N, &amp;H, &amp;R, &amp;T);</span><br><span class="line">        R /= <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            a[i] = H;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min((<span class="keyword">int</span>)T,N); i++) &#123;</span><br><span class="line">            a[i] = solve(a[i], T - i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf%c"</span>, a[i] + <span class="number">2</span> * i * R, (i == N - <span class="number">1</span> ? <span class="number">10</span>:<span class="number">32</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;N个半径为R厘米的球竖直叠放在H米的高度上。实验开始时释放最下面的第一个球，1s后释放最下面的第二个球，1s后释放第三个球……一次类推。求T秒时每个球底端的高度。所有碰撞都是弹性碰撞， g取10 m/s^2&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
      <category term="巧妙的转化" scheme="http://dafenghh.github.io/tags/%E5%B7%A7%E5%A6%99%E7%9A%84%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3279 [Fliptile] 题解</title>
    <link href="http://dafenghh.github.io/post/bdca6a8a.html"/>
    <id>http://dafenghh.github.io/post/bdca6a8a.html</id>
    <published>2017-11-29T14:39:42.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个游戏，M*N的方格，每个格子可以翻转正反面，一面白色，一面黑色。当翻转一个格子时，它的相邻格子都会被翻转。用最小的翻转次数使所有格子变成白色。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>考虑(1,1)这个格子，翻转(1,1) (1,2) (2,1)三个格子都能改变它的状态。<br>但当我们确定第一行的操作后，就只有翻转(2,1)能够改变(1,1)的状态。</p><p>所以，如果我们指定第一行的操作，就能根据(1,1)的状态来确定(2,1)是否需要翻转。同样的，也能确定余下所有方格是否需要翻转。最后确定一下最下一行是否全部变成白色即可。</p><p>所以这道题，就枚举第一行的所有操作即可。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn], flip[maxn][maxn], ans_flip[maxn][maxn], stat[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forij \</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)\</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    stat[x][y] = <span class="number">1</span> - stat[x][y];</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; <span class="number">4</span>; di++)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + d[di][<span class="number">0</span>], ny = y + d[di][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n) stat[nx][ny] = <span class="number">1</span> - stat[nx][ny];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    Forij <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; n); x++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        Forij stat[i][j] = a[i][j], flip[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> xi = <span class="number">0</span>; xi &lt; n; xi++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; xi)) &#123;</span><br><span class="line">                F(<span class="number">0</span>, xi);</span><br><span class="line">                flip[<span class="number">0</span>][xi] = <span class="number">1</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Forij</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == m - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (stat[i][j])&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stat[i][j])&#123;</span><br><span class="line">                    F(i + <span class="number">1</span>, j);</span><br><span class="line">                    flip[i + <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; (cnt &lt; ans)) &#123;</span><br><span class="line">            ans = cnt;</span><br><span class="line">            Forij ans_flip[i][j] = flip[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">1000</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"IMPOSSIBLE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Forij <span class="built_in">cout</span> &lt;&lt; ans_flip[i][j] &lt;&lt; (j == n - <span class="number">1</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;一个游戏，M*N的方格，每个格子可以翻转正反面，一面白色，一面黑色。当翻转一个格子时，它的相邻格子都会被翻转。用最小的翻转次数使所有格子变成白色。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="反转" scheme="http://dafenghh.github.io/tags/%E5%8F%8D%E8%BD%AC/"/>
    
      <category term="brute force" scheme="http://dafenghh.github.io/tags/brute-force/"/>
    
      <category term="位运算" scheme="http://dafenghh.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 H [Hidden Supervisors] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/2cb42504.html"/>
    <id>http://dafenghh.github.io/post/2cb42504.html</id>
    <published>2017-11-29T14:38:43.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 H题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>给定若干棵树，其中一棵的根结点为1，现在把这所有的树合并成一棵根结点为1的树，并且要使这棵树中能够组成的(a,b)(a是b的父结点)的组数最大。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>先对每棵树做下DFS，用贪心的方式分好组。这棵树的根结点要么分好组，要么没分好。对所有不等于1的根结点，如果它已经分好组，就直接连到1上面；如果没分好组，就连到结点1的树未分组的一个结点上。对没分好组的根结点，用下贪心策略，对应的树的未分组结点越多的根结点越优先连接。</p><p>就这样简单的贪心策略，完成此题……想复杂了，并且细节上犯了弱智错误，debug很久。（根结点的分组居然写在了countUnmatchedNodesForAllTrees函数之前）。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[maxn], rt[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">bool</span> matched[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unmatched_nodes[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUnmatchedNodes</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = rt[v];</span><br><span class="line">    unmatched_nodes[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUnmatchedNodesToRoot</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: unmatched_nodes[v])&#123;</span><br><span class="line">        S.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//unmatched_nodes[v].clear();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    rt[v] = root;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: G[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Match(i, root))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!res)&#123;</span><br><span class="line">                matched[v] = <span class="literal">true</span>;</span><br><span class="line">                matched[i] = <span class="literal">true</span>;</span><br><span class="line">                res = <span class="literal">true</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countUnmatchedNodesForAllTrees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!matched[i]) &#123;</span><br><span class="line">            addUnmatchedNodes(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"hidden.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"hidden.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p + i);</span><br><span class="line">        G[p[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Match(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que0;</span><br><span class="line">    priority_queue&lt;P&gt; que1;<span class="comment">//que0: matched que1: unmatched</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: G[<span class="number">0</span>]) &#123;</span><br><span class="line">        Match(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    countUnmatchedNodesForAllTrees();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: G[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matched[i]) &#123;</span><br><span class="line">            que0.push(i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> que1.push(P(unmatched_nodes[i].size(),i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    addUnmatchedNodesToRoot(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!que0.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que0.front(); que0.pop();</span><br><span class="line">        p[u] = <span class="number">1</span>;</span><br><span class="line">        addUnmatchedNodesToRoot(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que1.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que1.top().second; que1.pop();</span><br><span class="line">        <span class="keyword">if</span> (!S.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> v = *S.begin();</span><br><span class="line">            p[u] = v;</span><br><span class="line">            cnt++;</span><br><span class="line">            addUnmatchedNodesToRoot(u);</span><br><span class="line">            S.erase(u);</span><br><span class="line">            S.erase(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p[u] = <span class="number">1</span>;</span><br><span class="line">            addUnmatchedNodesToRoot(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, p[i], (i == n?<span class="number">10</span>:<span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 H题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定若干棵树，其中一棵的根结点为1，现在把这所有的树合并成一棵根结点为1的树，并且要使这棵树中能够组成的(a,b)(a是b的父结点)的组数最大。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="greedy" scheme="http://dafenghh.github.io/tags/greedy/"/>
    
      <category term="trees" scheme="http://dafenghh.github.io/tags/trees/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 I [Intelligence in Perpendicularia] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/7ec55acf.html"/>
    <id>http://dafenghh.github.io/post/7ec55acf.html</id>
    <published>2017-11-29T14:38:10.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 I题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>给出一个多边形（只包含水平边和垂直边），求所有边中不能从外面看见的部分的长度。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>注意到能被外面看到的边经过平移后刚好能组成一个矩形，所以这题就简单了。先统计出周长，然后减去外接矩形的周长就得到答案了。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">cin</span><span class="params">(<span class="string">"intel.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">cout</span><span class="params">(<span class="string">"intel.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll x[maxn], y[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">abs_</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getL</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x[i] == x[j]) <span class="keyword">return</span> abs_(y[i] - y[j]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> abs_(x[i] - x[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ll len = <span class="number">0</span>;</span><br><span class="line">    ll minX, maxX, minY, maxY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">       len += getL(i , (i + <span class="number">1</span>) % n);</span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">0</span>) minX = maxX = x[i], minY = maxY = y[i];</span><br><span class="line">       <span class="keyword">else</span> minX = min(minX, x[i]), maxX = max(maxX, x[i]),</span><br><span class="line">            minY = min(minY, y[i]), maxY = max(maxY, y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// cout &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; maxX &lt;&lt; " " &lt;&lt; minX &lt;&lt; " " &lt;&lt; maxY &lt;&lt; " " &lt;&lt; minY &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; len - <span class="number">2</span> * (maxX - minX + maxY - minY) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 I题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给出一个多边形（只包含水平边和垂直边），求所有边中不能从外面看见的部分的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 K [Kotlin Island] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/f48dff26.html"/>
    <id>http://dafenghh.github.io/post/f48dff26.html</id>
    <published>2017-11-29T14:36:06.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 K题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>一个岛可以看成一个h*w的网格，现在可以在任意的行或者任意的类挖水渠，目标是将网格剩下没被挖水渠的点划分成k个连通块。给出一种方案即可。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>显然最后分成的连通块数目 = 行的分块数 * 列的分块数。比如有5行，那么我们最多可以分成3块。</p><p>枚举一遍就出答案了。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">bool</span> row[maxn], col[maxn];</span><br><span class="line"><span class="keyword">int</span> h, w, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"kotlin.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"kotlin.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;h, &amp;w, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hi = <span class="number">1</span>; hi &lt;= (h + <span class="number">1</span>) / <span class="number">2</span>; hi++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> wi = <span class="number">1</span>; wi &lt;= (w + <span class="number">1</span>) / <span class="number">2</span>; wi++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi * wi == n)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hi - <span class="number">1</span>; i++) row[<span class="number">1</span> + i * <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wi - <span class="number">1</span>; i++) col[<span class="number">1</span> + i * <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (row[i] || col[j]) <span class="built_in">printf</span>(<span class="string">"#"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 K题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个岛可以看成一个h*w的网格，现在可以在任意的行或者任意的类挖水渠，目标是将网格剩下没被挖水渠的点划分成k个连通块。给出一种方案即可。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="brute force" scheme="http://dafenghh.github.io/tags/brute-force/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 C [Consonant Fencity] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/9c682bc0.html"/>
    <id>http://dafenghh.github.io/post/9c682bc0.html</id>
    <published>2017-11-29T14:35:36.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 C题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>定义辅音字母为除了{a,e,i,o,u,w,y}之外的19个字母。<br>然后定义一个字符串的fencity为串中有多少对相邻的辅音字母，且它们一个大写一个小写。<br>给出一个只包含小写字母的字符串，现在你要指定19个辅音字母中的若干个字母，将字符串中的这些字母全部转换为大写。求fencity最大的串。</p><a id="more"></a> <h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>一共有19个字母要考虑。将这19个字母想象成图中的点。我们先扫一遍字符串，当遇到辅音字母相邻时，就将这两个辅音字母的边权+1.</p><p>然后这题就是说，往19个点染两种颜色（大写或者非大写），当一条边的两个端点颜色不一样时，这条边的边权生效。求边权和最大值。</p><p>由于对称性，我们可以固定一个点的颜色，然后只有18个点需要考虑，那么就是<code>2^18</code>中情况需要枚举。每个情况扫一遍所有的边，那么就是<code>2^18 * 19 * 18 / 2</code>的复杂度，大概为4500万，所以暴力方式能够解决此题。</p><p>P.S.有个小插曲，<code>(1 &lt;&lt; M[s[i]])) &gt; 0</code> 忘了加前面的括号，debug了好长时间。<br>下次打比赛时要先打印一份C/C++运算符优先级列表，然后将它压在台面上。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> fencity[(<span class="number">1</span> &lt;&lt; <span class="number">18</span>)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xn = (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; xn; x++) &#123;</span><br><span class="line"></span><br><span class="line">        fencity[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = (x &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            <span class="keyword">int</span> q = (x &amp; (<span class="number">1</span> &lt;&lt; j));</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">0</span> &amp;&amp; q &gt; <span class="number">0</span> || p &gt; <span class="number">0</span> &amp;&amp; q == <span class="number">0</span>)&#123;</span><br><span class="line">               </span><br><span class="line">                fencity[x] += w[i][j];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">char</span> voewls[] = <span class="string">"aeiouwy"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"consonant.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"consonant.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; S(voewls, voewls+ <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'b'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!S.count(ch)) M[ch] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (M.count(s[i]) &amp;&amp; M.count(s[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            w[M[s[i]]][M[s[i + <span class="number">1</span>]]]++;</span><br><span class="line">            w[M[s[i + <span class="number">1</span>]]][M[s[i]]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, xn = (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xn; x++) <span class="keyword">if</span> (fencity[ans] &lt; fencity[x]) ans = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!S.count(s[i]) &amp;&amp; ((ans &amp; (<span class="number">1</span> &lt;&lt; M[s[i]])) &gt; <span class="number">0</span>)) <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[i] + <span class="string">'A'</span> - <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 C题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定义辅音字母为除了{a,e,i,o,u,w,y}之外的19个字母。&lt;br&gt;然后定义一个字符串的fencity为串中有多少对相邻的辅音字母，且它们一个大写一个小写。&lt;br&gt;给出一个只包含小写字母的字符串，现在你要指定19个辅音字母中的若干个字母，将字符串中的这些字母全部转换为大写。求fencity最大的串。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="brute force" scheme="http://dafenghh.github.io/tags/brute-force/"/>
    
      <category term="位运算" scheme="http://dafenghh.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>codeforces gym 101612 E [Equal Numbers] (ICPC 2017-2018 NEERC Northern Subregional Contest St Petersburg November 4 2017) 题解</title>
    <link href="http://dafenghh.github.io/post/79e97c8b.html"/>
    <id>http://dafenghh.github.io/post/79e97c8b.html</id>
    <published>2017-11-29T14:30:09.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>gym 101612 E题<br>链接： <a href="http://codeforces.com/gym/101612" target="_blank" rel="noopener">gym</a></p><p>给定一个大小为n的正整数的数组，每次操作可以选取数组中一个数，将它乘上若干倍。求经过k次操作后，数组中最少有多少个不同的数？输出所有0&lt;=k&lt;=n的k的结果。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>样例输入是<code>n = 4, a[] = {1, 1, 2, 2, 3, 4}</code></p><p>我们先将相同的数合并成一堆，比如这里<code>a[]</code>可以看作<code>{1(2), 2(2), 3(1), 4(1)}</code></p><p>括号里的数表示这个数字的出现次数。</p><p>假定初始状态有<code>vn</code>堆数，这个样例里<code>vn = 4</code></p><p>题目要求的就是经过若干次操作后，最少剩下多少堆。</p><p>不妨换个思路，我们来求把<code>vn</code>堆数合并成<code>vn - k</code>堆至少需要多少次操作。如果能求出这个结果，我们将数组逆一下，并且空白处的值用前面的值填充好就得到题目要求的答案。</p><p>下面思考把<code>vn</code>堆数合并成<code>vn - k</code>堆， 也就是减少k堆，至少需要多少次操作。</p><p>我们把原来的数分成两类，一类是它的倍数也存在于数组中，另一类是它没有一个倍数存在与数组中，分别记为A类，B类。</p><p>样例中A类为： <code>1(2), 2(2)</code><br>样例中B类为： <code>3(1), 4(1)</code></p><p>为了减少k堆，我们有两种决策方法：</p><ol><li>直接在A类中选取大小最小的k堆，将这些数全部提升为它们的倍数。</li><li>在B类中选取大小最小的两堆，将这两堆数提升为所有数的最小公倍数，这时候减少了原有的2堆，但新增了1堆（所有数的最小公倍数），并且因为出现了所有数的最小公倍数，所以原有的所有数都变成A类，再按方法1选取(k-1)堆即可。</li></ol><p>两种方法分别求出来比较一下，取最优就得到答案了。</p><p>源代码中用x表示第一种决策方式需要的操作数，y表示第二种决策方式需要的操作数。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source_code"></a>source_code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000060</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[maxn], ops[maxn], ans[maxn], bucket[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v0, v1, v2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(bucket, <span class="number">0</span>, <span class="keyword">sizeof</span>(bucket));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) bucket[v[i]]++;</span><br><span class="line">    v.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket[i]; j++) </span><br><span class="line">        v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"equal.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"equal.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i])&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt; maxn; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[i * j]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) v0.push_back(cnt[i]);</span><br><span class="line">            <span class="keyword">else</span> v1.push_back(cnt[i]);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vn = v0.size() + v1.size();</span><br><span class="line">    bucket_sort(v0);</span><br><span class="line">    bucket_sort(v1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v0.size(); i++) v2.push_back(v0[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; v1.size(); i++) v2.push_back(v1[i]);</span><br><span class="line">    bucket_sort(v2);</span><br><span class="line"></span><br><span class="line">    ops[vn] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v1.size() &gt;= <span class="number">2</span>)   y+=v1[<span class="number">0</span>] + v1[<span class="number">1</span>]; <span class="keyword">else</span> y = <span class="number">2</span> * n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; vn; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= v0.size()) x += v0[k - <span class="number">1</span>]; <span class="keyword">else</span> x = <span class="number">2</span> * n;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">1</span>) y+=v2[k - <span class="number">2</span>];</span><br><span class="line">       <span class="comment">// printf("x = %d, y = %d, k = %d\n", x, y, k);</span></span><br><span class="line">        ops[vn - k] = min(x, y);           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vn; i++)&#123;</span><br><span class="line">        ans[ops[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">0</span>) ans[i] = ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], (i == n?<span class="number">10</span>:<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;gym 101612 E题&lt;br&gt;链接： &lt;a href=&quot;http://codeforces.com/gym/101612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个大小为n的正整数的数组，每次操作可以选取数组中一个数，将它乘上若干倍。求经过k次操作后，数组中最少有多少个不同的数？输出所有0&amp;lt;=k&amp;lt;=n的k的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3484 [Showstopper] 题解</title>
    <link href="http://dafenghh.github.io/post/b9568341.html"/>
    <id>http://dafenghh.github.io/post/b9568341.html</id>
    <published>2017-11-28T14:44:04.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定若干等差数列，初项x，公差z，末项不大于y（均为正整数）。在所有数列有，有且仅有一个数的出现次数是奇数，求这个数以及它出现的次数。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>初看此题，真的毫无思路。虽然知道实在《挑战程序设计竞赛》的二分专题中，肯定使用二分算法，但怎么联系到二分上去呢？</p><p>有且只有一个奇数，这就是突破口。对解空间中的所有数，统计它们在数列中的出现次数，记为c[i]，然后对c[i]求个前缀和，那么在答案点x前，前缀和均为偶，答案点x及之后，前缀和均为奇。由此得到二分的单调性，得解。</p><p>有点小插曲，这道题的输入方式很麻烦……最讨厌按行输入了。WA几次后以为是输入有问题，其实是算法部分写错了细节。统计区间的数在数列的出现次数时，左端应该向上取整……</p><p>代码比较累赘，特别是统计的时候，可以写精简些。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tuple</span> &#123;</span></span><br><span class="line">    ll x, y, z;</span><br><span class="line">    Tuple(ll x = <span class="number">0</span>, ll y = <span class="number">0</span>, ll z = <span class="number">0</span>):x(x), y(y), z(z)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Tuple&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">count_</span><span class="params">(ll L, ll R, Tuple t)</span> </span>&#123; <span class="comment">//[L, R]</span></span><br><span class="line">    ll x = t.x, y = t.y, z = t.z;</span><br><span class="line">    <span class="keyword">if</span> (R &lt; x || L &gt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; x) L = x;</span><br><span class="line">    <span class="keyword">if</span> (R &gt; y) R = y;</span><br><span class="line">    ll res =  (R - x ) / z - (L - x) / z + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((L - x) % z) res--;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*printf("-------------\n");</span></span><br><span class="line"><span class="comment">    for (ll i = 0; i &lt; vec.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">        printf("%lld %lld %lld\n", vec[i].x, vec[i].y, vec[i].z);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf("-------------\n");*/</span></span><br><span class="line">    <span class="keyword">if</span> (vec.empty()) <span class="keyword">return</span>;</span><br><span class="line">    ll L = vec[<span class="number">0</span>].x, R = vec[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">        L = min(L, vec[i].x);</span><br><span class="line">        R = max(R, vec[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    L--;</span><br><span class="line"></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">        sum += count_(L, R, vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no corruption\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (L + <span class="number">1</span> &lt; R) &#123;</span><br><span class="line">        ll mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">           sum += count_(L, mid, vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) L = mid;</span><br><span class="line">        <span class="keyword">else</span> R = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">        sum += count_(R, R, vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = (ll)R;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d %I64d\n"</span>, ans, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(s, <span class="string">"%I64d %I64d %I64d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    vec.clear();</span><br><span class="line">    vec.push_back(Tuple(x, y, z));</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="keyword">while</span> (gets(s), *s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(s, <span class="string">"%I64d %I64d %I64d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        vec.push_back(Tuple(x, y, z));</span><br><span class="line">        <span class="built_in">memset</span>(s , <span class="number">0</span> , <span class="keyword">sizeof</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (gets(s)) work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给定若干等差数列，初项x，公差z，末项不大于y（均为正整数）。在所有数列有，有且仅有一个数的出现次数是奇数，求这个数以及它出现的次数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
      <category term="按行输入" scheme="http://dafenghh.github.io/tags/%E6%8C%89%E8%A1%8C%E8%BE%93%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3276 [Face The Right Way] 题解</title>
    <link href="http://dafenghh.github.io/post/49886522.html"/>
    <id>http://dafenghh.github.io/post/49886522.html</id>
    <published>2017-11-28T12:22:37.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>n头牛排成一行，有的牛面朝前，有的牛面朝后，每一次操作可以使连续的K头牛改变方向；求一个K，使得操作次数最少。输出K以及最少的操作次数。当有多个K满足条件时，输出最小的K。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>对一个区间来说，多次进行反转操作是没有意义的；另外反转的顺序对结果是没有影响的。所以这道题只需要对所有的可操作区间（即长度为K的区间）考虑是否需要反转。</p><p>考虑最左边的牛，当它面朝前时无需反转，当它面朝后时，就反转[1, K]区间一次。然后继续考虑第二头牛即可。</p><p>反转的时候不必每头牛都操作一次，只需用一个turns来记录当前区间的反转次数，考虑的下一头牛的状态就由它本身状态+turns的值来决定。随着区间往右移动，我们用区间左右更改的地方来更新turns即可。复杂度为<code>O(n ^ 2)</code></p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100243535</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], f[maxn], cnt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        a[i] = (s[<span class="number">0</span>] == <span class="string">'F'</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">int</span> turns = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> ((a[i] + turns) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + k &gt; n) &#123;</span><br><span class="line">                    cnt[k] = INF;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                f[i] = <span class="number">1</span>;</span><br><span class="line">                cnt[k]++;</span><br><span class="line">                turns++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) turns -= f[i - k + <span class="number">1</span>];</span><br><span class="line">           </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ansK = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n; k++) <span class="keyword">if</span> (cnt[k] &lt; cnt[ansK]) ansK = k;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ansK, cnt[ansK]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;n头牛排成一行，有的牛面朝前，有的牛面朝后，每一次操作可以使连续的K头牛改变方向；求一个K，使得操作次数最少。输出K以及最少的操作次数。当有多个K满足条件时，输出最小的K。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="区间处理" scheme="http://dafenghh.github.io/tags/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
      <category term="反转" scheme="http://dafenghh.github.io/tags/%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3320 [Jessica&#39;s Reading Problem] 题解</title>
    <link href="http://dafenghh.github.io/post/6f199fb1.html"/>
    <id>http://dafenghh.github.io/post/6f199fb1.html</id>
    <published>2017-11-28T04:51:03.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个大小为P的数组，取出一个子区间，要求这个子区间上的数能覆盖整个数组的数，求满足条件的子区间的最小长度。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>《挑战程序设计竞赛》P149例题，采用“尺取法”可以很快地做出这道题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/POJ3320_solution.jpg" alt="挑战程序设计竞赛" title="">                </div>                <div class="image-caption">挑战程序设计竞赛</div>            </figure><p>使用map来记录的时间复杂度为<code>O(P log P)</code>。</p><p>由于P最大为10e6，所以我提交的时候很担心超时。结果真的超时了，但并不是复杂度的锅，而是我用了cin cout，改成scanf printf就过了。</p><p>后来查了下，在windows下不开<code>ios::sync_with_stdio(false)</code>的优化时，cin比scanf慢差不多十倍;开了后，慢三倍。只有在linux下g++编译，并且写上这一句优化的情况下，cin才达到和scanf差不多的效率。</p><p>之后，将map改成hash，将时间复杂度降到线性，并且采用快速读入，这样才能47ms通过。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="solution-1-454ms"><a href="#solution-1-454ms" class="headerlink" title="solution 1 (454ms)"></a>solution 1 (454ms)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000100</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        S.insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sn = S.size();</span><br><span class="line">    S.clear();</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, cnt = <span class="number">0</span>, ans = n;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; n &amp;&amp; cnt &lt; sn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[a[t]] == <span class="number">0</span>) cnt++;</span><br><span class="line">            M[a[t]]++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; sn) <span class="keyword">break</span>;</span><br><span class="line">        ans = min(ans, t - s);</span><br><span class="line">        <span class="keyword">if</span> (M[a[s]] == <span class="number">1</span>) cnt--;</span><br><span class="line">        M[a[s]]--;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-47ms"><a href="#solution-2-47ms" class="headerlink" title="solution 2 (47ms)"></a>solution 2 (47ms)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000100</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> hash_n = <span class="number">535442</span>;</span><br><span class="line"><span class="keyword">int</span> M0[hash_n], M[hash_n];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=getchar() )</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">            f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=getchar() )</span><br><span class="line">        k=k*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = get();</span><br><span class="line">        a[i] %= hash_n;</span><br><span class="line">        M0[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash_n; i++) <span class="keyword">if</span> (M0[i]) sn++;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, cnt = <span class="number">0</span>, ans = n;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; n &amp;&amp; cnt &lt; sn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[a[t]] == <span class="number">0</span>) cnt++;</span><br><span class="line">            M[a[t]]++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; sn) <span class="keyword">break</span>;</span><br><span class="line">        ans = min(ans, t - s);</span><br><span class="line">        <span class="keyword">if</span> (M[a[s]] == <span class="number">1</span>) cnt--;</span><br><span class="line">        M[a[s]]--;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给定一个大小为P的数组，取出一个子区间，要求这个子区间上的数能覆盖整个数组的数，求满足条件的子区间的最小长度。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="尺取法" scheme="http://dafenghh.github.io/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
      <category term="hash" scheme="http://dafenghh.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1759 [Garland] 题解</title>
    <link href="http://dafenghh.github.io/post/68c8caf8.html"/>
    <id>http://dafenghh.github.io/post/68c8caf8.html</id>
    <published>2017-11-28T02:08:39.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个数列H[]，满足下面的关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">H[1] = A</span><br><span class="line">H[i] = (H[i-1] + H[i+1])/2 - 1, for all 1 &lt; i &lt; N </span><br><span class="line">H[N] = B </span><br><span class="line">H[i] &gt;= 0, for all 1 &lt;= i &lt;= N</span><br></pre></td></tr></table></figure></p><p>已知A，求B的最小值。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>化成递推式， 有<code>H[i+1] = 2 * H[i] - H[i-1] + 2</code></p><p>作下变形，有<code>H[i+1] - H[i] = H[i] - H[i-1] + 2</code> </p><p>所以H[i+1] - H[i]是一个等差数列，公差为2，那么：<code>H[i+1] - H[i] = H[2] - H[1] + 2 * (i - 1)</code> </p><p>做累加求和即得H[i]通项公式： <code>H[i] = (i - 1) * H[2] + (2 - i) * H[1] + (i - 1) * (i - 2)</code> </p><p>题目要求B，即<code>H[N] = (N - 1) * H[2] + (2 - N) * H[1] + (N - 1) * (N - 2)</code> </p><p>这个式子中，仅有H[2]为未知项，其他均已知。而且H[2]项前的系数N-1为正，H[N]与H[2]线性正相关，所以H[N]取最小值当且仅当H[2]取最小值。</p><p>于是我们将问题转化为求H[2]最小值即可。对H[2]进行二分，每次验证数列里的所有项是否全部大于零即可。</p><p>P.S. 交了几发WA，因为一不小心交了G++编译器，POJ的G++编译器有点老，浮点支持得不好。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source_code"></a>source_code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> A,B;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = A, b = mid,x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        x = <span class="number">2</span> * b - a + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = x;</span><br><span class="line">    &#125;</span><br><span class="line">    B = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;n, &amp;A);</span><br><span class="line">    <span class="keyword">double</span> L = <span class="number">-1</span>, R = <span class="number">1060</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (judge(mid)) R = mid;</span><br><span class="line">        <span class="keyword">else</span> L = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给定一个数列H[]，满足下面的关系：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;H[1] = A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H[i] = (H[i-1] + H[i+1])/2 - 1, for all 1 &amp;lt; i &amp;lt; N &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H[N] = B &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H[i] &amp;gt;= 0, for all 1 &amp;lt;= i &amp;lt;= N&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;已知A，求B的最小值。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 894E [Ralph and Mushrooms] #round 447 div2E 题解</title>
    <link href="http://dafenghh.github.io/post/2fde12e8.html"/>
    <id>http://dafenghh.github.io/post/2fde12e8.html</id>
    <published>2017-11-27T11:39:47.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个有向图，n个点，m条边，每条边初始有w[i]个蘑菇。有可能存在自环或重边。从点s出发，任意移动，当第一次经过一条边时，能采集w[i]个蘑菇；第二次经过这条边时，能采集w[i] - 1个蘑菇；第三次经过时，能采集w[i] - 1 - 2个；第四次则为w[i] - 1 - 2 - 3个，依次类推。当可采集蘑菇数变成0或负数后，仍能从这条边经过，但不会获得蘑菇。求能采集到的蘑菇的最大数量。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>经过强连通分量(scc)分解后，并缩成一个DAG。显然每个scc上，可以任意次数遍历这个scc包含的边，直至无蘑菇可采。然后scc之间的边，最多只能经过一次。<br>对那些可以无限遍历的边，我们先用二分求出总蘑菇数，然后汇总到所在的scc中。<br>最后应用DAG上的动态规划，算出从点s出发, 能采集到的最大蘑菇数。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source_code"></a>source_code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv= <span class="number">1000010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxv], rG[maxv], vs;</span><br><span class="line"><span class="keyword">bool</span> used[maxv];</span><br><span class="line"><span class="keyword">int</span> cmp[maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    G[from].push_back(to);</span><br><span class="line">    rG[to].push_back(from); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    used[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[G[v][i]]) dfs(G[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vs.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    used[v] = <span class="literal">true</span>;</span><br><span class="line">    cmp[v] = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rG[v].size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[rG[v][i]]) rdfs(rG[v][i], k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">    vs.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= V; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[v]) dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(used, <span class="number">0</span> , <span class="keyword">sizeof</span>(used));</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vs.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[vs[i]]) rdfs(vs[i], k++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sn = <span class="number">22000</span>;</span><br><span class="line">ll sum[sn], accSum[sn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sum[<span class="number">0</span>] = accSum[sn] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sn; i++) sum[i] = sum[i - <span class="number">1</span>] + i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sn; i++) accSum[i] = accSum[i - <span class="number">1</span>] + sum[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calWeight</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> k = upper_bound(sum, sum + sn, x) - sum - <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> (ll)(k+<span class="number">1</span>) * x - accSum[k]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">ll shrink_vertex_weight[maxv], dp[maxv];</span><br><span class="line"><span class="keyword">int</span> sV;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shrink_graph[maxv];</span><br><span class="line"><span class="built_in">map</span>&lt;P, ll&gt; shrink_edge_weight;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> from, to, weight;&#125;;</span><br><span class="line">edge edges[maxv];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll &amp;a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[v] &gt; <span class="number">-1</span>) <span class="keyword">return</span> dp[v];</span><br><span class="line">    ll reward = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: shrink_graph[v]) &#123;</span><br><span class="line">        update(reward, shrink_edge_weight[P(v, i)] + f(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[v] = shrink_vertex_weight[v] + reward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init_sum();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    V = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, weight;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; weight;</span><br><span class="line">        add_edge(from, to);</span><br><span class="line">        edges[i] = edge&#123;from, to, weight&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; start;</span><br><span class="line">    sV = scc();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = edges[i].from, v2 = edges[i].to;</span><br><span class="line">        <span class="keyword">if</span> (cmp[v1] == cmp[v2]) &#123;</span><br><span class="line">            shrink_vertex_weight[cmp[v1]] += calWeight(edges[i].weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            update(shrink_edge_weight[P(cmp[v1], cmp[v2])], edges[i].weight);</span><br><span class="line">            shrink_graph[cmp[v1]].push_back(cmp[v2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(cmp[start]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;一个有向图，n个点，m条边，每条边初始有w[i]个蘑菇。有可能存在自环或重边。从点s出发，任意移动，当第一次经过一条边时，能采集w[i]个蘑菇；第二次经过这条边时，能采集w[i] - 1个蘑菇；第三次经过时，能采集w[i] - 1 - 2个；第四次则为w[i] - 1 - 2 - 3个，依次类推。当可采集蘑菇数变成0或负数后，仍能从这条边经过，但不会获得蘑菇。求能采集到的蘑菇的最大数量。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="dp" scheme="http://dafenghh.github.io/tags/dp/"/>
    
      <category term="graphs" scheme="http://dafenghh.github.io/tags/graphs/"/>
    
      <category term="scc" scheme="http://dafenghh.github.io/tags/scc/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3061 [Subsequence] 题解</title>
    <link href="http://dafenghh.github.io/post/acca6816.html"/>
    <id>http://dafenghh.github.io/post/acca6816.html</id>
    <published>2017-11-27T07:43:53.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长度为N的数列，以及整数S。求出和不小于S的连续子序列的长度的最小值。如果解不存在，则输出0.</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>先求前缀和，然后就能用O(1)的时间, 求出一个区间的和。</p><p>之后用二分就能解决这道题。</p><p>但《挑战程序设计竞赛》(P146)中提供了一种更高效和简单的解法，叫“尺取法”。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1"></a>solution 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], sum[maxn];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum[i + len] - sum[i] &gt;= S) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">       sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum[i + <span class="number">1</span>] = sum[i] + a[i];</span><br><span class="line">       <span class="keyword">if</span> (sum[N] &lt; S) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">int</span> L = <span class="number">0</span>, R = N;</span><br><span class="line">       <span class="keyword">while</span> (L + <span class="number">1</span> &lt; R) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (judge(mid)) R = mid;</span><br><span class="line">           <span class="keyword">else</span> L = mid;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; R &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2"></a>solution 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll S;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">       <span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">       ll sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> ans = N + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">while</span> (t &lt; N &amp;&amp; sum &lt; S) sum += a[t++];</span><br><span class="line">           <span class="keyword">if</span> (sum &lt; S) <span class="keyword">break</span>;</span><br><span class="line">           ans = min(ans, t - s);</span><br><span class="line">           sum -= a[s++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (ans &gt; N) ans = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给定一个长度为N的数列，以及整数S。求出和不小于S的连续子序列的长度的最小值。如果解不存在，则输出0.&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
      <category term="尺取法" scheme="http://dafenghh.github.io/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1064 [Cable master] 题解</title>
    <link href="http://dafenghh.github.io/post/52b6f961.html"/>
    <id>http://dafenghh.github.io/post/52b6f961.html</id>
    <published>2017-11-27T07:13:40.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>N条绳子，长度分别为Li，从它们之中切割出K条长度相同的绳子，求这K条绳子每条最长的长度，答案保留至小数点后二位。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>二分搜索的经典应用，“假定一个解并判断是否可行”。现在我们假定要切割出长度为x的绳子，然后判断能否切割成K条即可。</p><p>这道题卡在最后输出答案上了，不能四舍五入，一定要向下取。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">12000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">double</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        cnt += a[i] / k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &gt;= K;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, a + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> L = <span class="number">0.0001</span>, R = <span class="number">110000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (judge(mid)) L = mid;</span><br><span class="line">        <span class="keyword">else</span> R = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, <span class="built_in">floor</span>(L * <span class="number">100</span>) / <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;N条绳子，长度分别为Li，从它们之中切割出K条长度相同的绳子，求这K条绳子每条最长的长度，答案保留至小数点后二位。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3662 [Telephone Lines] 题解</title>
    <link href="http://dafenghh.github.io/post/e84ff597.html"/>
    <id>http://dafenghh.github.io/post/e84ff597.html</id>
    <published>2017-11-27T06:21:30.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个无向图，N的点，P条边，给出每条边的长度，定义一条路径的代价为省略路径上的K条边后剩余边的边长最大值。求点1到点N代价最小的路径的代价。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>“最小化最大值”的题目，考虑二分。<br>二分时，设当前设定代价为k，然后考虑在代价为k的约束下能否找到一条可行路径。在寻找路径时，碰到一条边长大于k的边，那么连上这条边需要省略它。显然，一条可行路径就是指路径上所有被省略的边数量不超过K。</p><p>那么就可以转化一下，边长大于k的边权值为1，边长小于等于k的边权值为0.然后用dijkstra计算1到n的最短路，如果答案不大于K，说明被省略的边数量不超过K.</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">20344</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">1500</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cost;</span><br><span class="line">    edge(<span class="keyword">int</span> to, <span class="keyword">int</span> cost):to(to),cost(cost)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> d[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class="line">    fill(d + <span class="number">1</span>, d + V + <span class="number">1</span>, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    que.push(P(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        P p = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">int</span> v = p.second;</span><br><span class="line">        <span class="keyword">if</span> (d[v] &lt; p.first) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span> (d[e.to] &gt; d[v] + (e.cost &gt; k ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">                d[e.to] = d[v] + (e.cost &gt; k ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                que.push(P(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> N, P, K;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; P &gt;&gt; K;</span><br><span class="line">    V = N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, cost;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; cost;</span><br><span class="line">        G[from].push_back(edge(to, cost));</span><br><span class="line">        G[to].push_back(edge(from, cost));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">-1</span>, R = <span class="number">1000010</span>;</span><br><span class="line">    <span class="keyword">if</span> (dijkstra(<span class="number">1</span>, N, R) == INF) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (L + <span class="number">1</span> &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dijkstra(<span class="number">1</span>, N, mid) &lt;= K) R = mid;</span><br><span class="line">        <span class="keyword">else</span> L = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; R &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;一个无向图，N的点，P条边，给出每条边的长度，定义一条路径的代价为省略路径上的K条边后剩余边的边长最大值。求点1到点N代价最小的路径的代价。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="binary search" scheme="http://dafenghh.github.io/tags/binary-search/"/>
    
      <category term="graphs" scheme="http://dafenghh.github.io/tags/graphs/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 894D [Ralph And His Tour in Binary Country] round 447 div2D 题解</title>
    <link href="http://dafenghh.github.io/post/2d71363f.html"/>
    <id>http://dafenghh.github.io/post/2d71363f.html</id>
    <published>2017-11-26T01:56:29.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一棵结点数为n的完全二叉树以及所有边的长度，m次查询，每次查询输入两个正整数A和H，A为起始点，任选树上一个结点（可以选择A本身）作为终点来构成一段旅程，定义这段旅程的快乐值为H-起点到终点的路径长度。求所有快乐值为正的旅程的快乐值的和。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>完全二叉树的性质在这道题要好好利用一下。因为是完全二叉树，所以树的高度为O(log n)级别。这样，我们对每一个结点，建一个数组（vector），记录从这个结点出发往它的子树上所有结点的路径长度，并且排好序。</p><p>因为一个结点最多在O(log n)个数组中出现，所以这些数组的总空间为O(n log n).另外每一个结点的数组显然可以由0（到自己的长度）+左儿子数组+右儿子数组 merge而来，那么每次合并使用归并排序，时间复杂度也是O(n log n)</p><p>做好这一步预处理后，我们怎么回答每一次询问呢？其实已经很简单了。对结点A，先统计A的子树上的路径，然后A的父节点上移动，统计A的兄弟子树上的路径；接着不断往上移动，直到根节点即可。因为树高为O(log n), 然后每一次统计时采用二分，所以每次查询的复杂度为O(log^2 n)</p><p>总复杂度为O(n<em>log n + m</em>log^2 n)<br>实现起来还是比较容易的。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> L[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; dist[maxn], accDist[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calDist</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i &lt;= n &amp;&amp; <span class="number">2</span> * i + <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">        calDist(<span class="number">2</span> * i);</span><br><span class="line">        calDist(<span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">        dist[i].push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; dist[<span class="number">2</span> * i].size(); di++) &#123;</span><br><span class="line">            dist[i].push_back(dist[<span class="number">2</span> * i][di] + L[<span class="number">2</span> * i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; dist[<span class="number">2</span> * i + <span class="number">1</span>].size(); di++) &#123;</span><br><span class="line">            dist[i].push_back(dist[<span class="number">2</span> * i + <span class="number">1</span>][di] + L[<span class="number">2</span> * i]);</span><br><span class="line">        &#125;</span><br><span class="line">        inplace_merge(dist[i].begin() + <span class="number">1</span>, dist[i].begin() + <span class="number">1</span> + dist[<span class="number">2</span> * i].size(), dist[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> * i &lt;= n &amp;&amp; <span class="number">2</span> * i + <span class="number">1</span> &gt; n) &#123;</span><br><span class="line">        calDist(<span class="number">2</span> * i);</span><br><span class="line">        dist[i].push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; dist[<span class="number">2</span> * i].size(); di++) &#123;</span><br><span class="line">            dist[i].push_back(dist[<span class="number">2</span> * i][di] + L[<span class="number">2</span> * i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dist[i].push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll acc_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; dist[i].size(); di++)&#123;</span><br><span class="line">        accDist[i].push_back((acc_ += dist[i][di]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">forSubtree</span><span class="params">(<span class="keyword">int</span> v, ll H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (H &lt; <span class="number">0</span> || v &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = upper_bound(dist[v].begin(), dist[v].end(), H) - dist[v].begin();</span><br><span class="line">    <span class="keyword">return</span> H * pos - accDist[v][pos - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">forPar</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> p, ll H)</span> </span>&#123; <span class="comment">// calculate happiness</span></span><br><span class="line">    <span class="keyword">int</span> v_ = (v == <span class="number">2</span> * p ? <span class="number">2</span> * p + <span class="number">1</span> : <span class="number">2</span> * p);</span><br><span class="line">    <span class="keyword">return</span> forSubtree(v_, H - L[v_ - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; L[i];</span><br><span class="line">    calDist(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mi = <span class="number">0</span>; mi &lt; m; mi++) &#123;</span><br><span class="line">        <span class="keyword">int</span> A, H;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; H;</span><br><span class="line">        ll ans = forSubtree(A, H);</span><br><span class="line">        <span class="keyword">while</span> (A &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            H -= L[A - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (H &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            ans += H;</span><br><span class="line">            ans += forPar(A, A / <span class="number">2</span>, H);</span><br><span class="line">            A /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给出一棵结点数为n的完全二叉树以及所有边的长度，m次查询，每次查询输入两个正整数A和H，A为起始点，任选树上一个结点（可以选择A本身）作为终点来构成一段旅程，定义这段旅程的快乐值为H-起点到终点的路径长度。求所有快乐值为正的旅程的快乐值的和。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="data structures" scheme="http://dafenghh.github.io/tags/data-structures/"/>
    
      <category term="trees" scheme="http://dafenghh.github.io/tags/trees/"/>
    
  </entry>
  
  <entry>
    <title>codeforces 894C [Marco and GCD Sequence] #round 447 div2C 题解</title>
    <link href="http://dafenghh.github.io/post/d93115b9.html"/>
    <id>http://dafenghh.github.io/post/d93115b9.html</id>
    <published>2017-11-25T14:04:20.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>将输入的数组求一次gcd, 设求出来的值为s，然后判断s是否在原来的数组中。如果不在，那么无解；否则可以构造出一组解，往输入数组的每两个相邻的数中插入一个s，然后就得到一组解。</p><a id="more"></a><p>简单证明这组解是正确的：</p><p>设输入数组为a[]，依照上面的方式构造出来的数组为b[]，下面证明：b数组中任意一个区间的gcd值恰好构成集合a。</p><p>若i==j，即区间长度为1，那么gcd(b[i]) = b[i]， 而b[i]构成的集合与集合a等价，即表明a[]中的值都是b数组一个区间的gcd值；<br>若i!=j，那么gcd(b[i..j]) = s, s属于集合a。<br>以上两点说明b[]就是答案。</p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>?a:gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        S.insert(a[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> g = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) g = gcd(g, a[i]);</span><br><span class="line">    <span class="keyword">if</span> (S.count(g))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>, <span class="number">2</span> * m - <span class="number">1</span>, a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">1</span>; i &lt; m; i++) <span class="built_in">printf</span>(<span class="string">" %d %d"</span>, g, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;将输入的数组求一次gcd, 设求出来的值为s，然后判断s是否在原来的数组中。如果不在，那么无解；否则可以构造出一组解，往输入数组的每两个相邻的数中插入一个s，然后就得到一组解。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://dafenghh.github.io/categories/ACM/"/>
    
    
      <category term="constructive algorithms" scheme="http://dafenghh.github.io/tags/constructive-algorithms/"/>
    
      <category term="math" scheme="http://dafenghh.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>ACM训练计划</title>
    <link href="http://dafenghh.github.io/post/3c0e0710.html"/>
    <id>http://dafenghh.github.io/post/3c0e0710.html</id>
    <published>2017-11-24T12:49:10.000Z</published>
    <updated>2018-05-02T06:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>从2017年11月25日开始，每天3题的日常任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从2017年11月25日开始，每天3题的日常任务。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
